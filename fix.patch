diff --git a/.claude/settings.local.json b/.claude/settings.local.json
index 5fe0665..d0422f6 100644
--- a/.claude/settings.local.json
+++ b/.claude/settings.local.json
@@ -8,7 +8,28 @@
       "Bash(mkdir:*)",
       "Bash(python scripts/validate_backup_config:*)",
       "Bash(chmod:*)",
-      "Bash(git add:*)"
+      "Bash(git add:*)",
+      "Bash(git commit:*)",
+      "Bash(git push:*)",
+      "Bash(ln:*)",
+      "Bash(diff:*)",
+      "Bash(ls:*)",
+      "Bash(rm:*)",
+      "Bash(tree:*)",
+      "Bash(find:*)",
+      "Bash(cp:*)",
+      "Bash(echo:*)",
+      "Bash(python -m pytest --version)",
+      "Bash(cd:*)",
+      "Bash(python:*)",
+      "Bash(black --version)",
+      "Bash(ruff:*)",
+      "Bash(black:*)",
+      "Bash(npm:*)",
+      "Bash(node:*)",
+      "Bash(pytest:*)",
+      "Bash(docker:*)",
+      "Bash(docker-compose:*)"
     ],
     "deny": []
   }
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 340aaff..e827b5d 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -60,7 +60,8 @@ jobs:
         env:
           SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
         with:
-          args: --severity-threshold=high --sarif-file-output=snyk.sarif
+          command: test
+          args: --all-projects --sarif-file-output=snyk.sarif
 
       - name: Upload Snyk results to GitHub Security
         uses: github/codeql-action/upload-sarif@v3
diff --git a/auto_generate_video_fold6/compliance/gdpr/gdpr-compliance.py b/auto_generate_video_fold6/compliance/gdpr/gdpr-compliance.py
index 29f79d3..e50f509 100644
--- a/auto_generate_video_fold6/compliance/gdpr/gdpr-compliance.py
+++ b/auto_generate_video_fold6/compliance/gdpr/gdpr-compliance.py
@@ -10,7 +10,16 @@ from datetime import datetime, timedelta
 from typing import Dict, List, Optional, Any
 from enum import Enum
 from dataclasses import dataclass, asdict
-from sqlalchemy import create_engine, Column, Integer, String, DateTime, Text, Boolean, JSON
+from sqlalchemy import (
+    create_engine,
+    Column,
+    Integer,
+    String,
+    DateTime,
+    Text,
+    Boolean,
+    JSON,
+)
 from sqlalchemy.ext.declarative import declarative_base
 from sqlalchemy.orm import sessionmaker
 import logging
@@ -82,8 +91,12 @@ class GDPRDataRequest(Base):
 
     id = Column(Integer, primary_key=True)
     user_id = Column(Integer, nullable=False)
-    request_type = Column(String(50), nullable=False)  # access, rectification, erasure, portability
-    status = Column(String(50), default="pending")  # pending, processing, completed, rejected
+    request_type = Column(
+        String(50), nullable=False
+    )  # access, rectification, erasure, portability
+    status = Column(
+        String(50), default="pending"
+    )  # pending, processing, completed, rejected
     requested_at = Column(DateTime, default=datetime.utcnow)
     completed_at = Column(DateTime)
     request_details = Column(JSON)
@@ -126,7 +139,9 @@ class GDPRComplianceManager:
                 ip_address=consent.ip_address,
                 user_agent=consent.user_agent,
                 details={
-                    "expires_at": consent.expires_at.isoformat() if consent.expires_at else None
+                    "expires_at": consent.expires_at.isoformat()
+                    if consent.expires_at
+                    else None
                 },
             )
 
@@ -143,7 +158,9 @@ class GDPRComplianceManager:
             await self.db.rollback()
             return False
 
-    async def withdraw_consent(self, user_id: int, purpose: DataProcessingPurpose) -> bool:
+    async def withdraw_consent(
+        self, user_id: int, purpose: DataProcessingPurpose
+    ) -> bool:
         """撤回同意"""
         try:
             log_entry = GDPRConsentLog(
@@ -157,7 +174,9 @@ class GDPRComplianceManager:
             self.db.add(log_entry)
             await self.db.commit()
 
-            logger.info(f"Consent withdrawn for user {user_id}, purpose: {purpose.value}")
+            logger.info(
+                f"Consent withdrawn for user {user_id}, purpose: {purpose.value}"
+            )
             return True
 
         except Exception as e:
@@ -165,13 +184,18 @@ class GDPRComplianceManager:
             await self.db.rollback()
             return False
 
-    async def check_consent(self, user_id: int, purpose: DataProcessingPurpose) -> bool:
+    async def check_consent(
+        self, user_id: int, purpose: DataProcessingPurpose
+    ) -> bool:
         """檢查同意狀態"""
         try:
             # 查找最新的同意記錄
             latest_consent = (
                 self.db.query(GDPRConsentLog)
-                .filter(GDPRConsentLog.user_id == user_id, GDPRConsentLog.purpose == purpose.value)
+                .filter(
+                    GDPRConsentLog.user_id == user_id,
+                    GDPRConsentLog.purpose == purpose.value,
+                )
                 .order_by(GDPRConsentLog.timestamp.desc())
                 .first()
             )
@@ -236,7 +260,9 @@ class DataRequestHandler:
         """創建資料請求"""
         try:
             # 生成驗證令牌
-            verification_token = self._generate_verification_token(user_id, request_type)
+            verification_token = self._generate_verification_token(
+                user_id, request_type
+            )
 
             request = GDPRDataRequest(
                 user_id=user_id,
@@ -248,7 +274,9 @@ class DataRequestHandler:
             self.db.add(request)
             await self.db.commit()
 
-            logger.info(f"Data request created for user {user_id}, type: {request_type}")
+            logger.info(
+                f"Data request created for user {user_id}, type: {request_type}"
+            )
             return verification_token
 
         except Exception as e:
@@ -261,7 +289,10 @@ class DataRequestHandler:
         try:
             request = (
                 self.db.query(GDPRDataRequest)
-                .filter(GDPRDataRequest.id == request_id, GDPRDataRequest.request_type == "access")
+                .filter(
+                    GDPRDataRequest.id == request_id,
+                    GDPRDataRequest.request_type == "access",
+                )
                 .first()
             )
 
@@ -295,7 +326,10 @@ class DataRequestHandler:
         try:
             request = (
                 self.db.query(GDPRDataRequest)
-                .filter(GDPRDataRequest.id == request_id, GDPRDataRequest.request_type == "erasure")
+                .filter(
+                    GDPRDataRequest.id == request_id,
+                    GDPRDataRequest.request_type == "erasure",
+                )
                 .first()
             )
 
@@ -331,7 +365,8 @@ class DataRequestHandler:
             request = (
                 self.db.query(GDPRDataRequest)
                 .filter(
-                    GDPRDataRequest.id == request_id, GDPRDataRequest.request_type == "portability"
+                    GDPRDataRequest.id == request_id,
+                    GDPRDataRequest.request_type == "portability",
                 )
                 .first()
             )
@@ -369,11 +404,21 @@ class DataRequestHandler:
         """收集用戶所有資料"""
         user_data = {
             "user_profile": await self.user_service.get_user_profile(user_id),
-            "audio_files": await self.data_service.get_user_audio_files(user_id),
-            "training_jobs": await self.data_service.get_user_training_jobs(user_id),
-            "video_projects": await self.data_service.get_user_video_projects(user_id),
-            "social_accounts": await self.data_service.get_user_social_accounts(user_id),
-            "usage_analytics": await self.data_service.get_user_analytics(user_id),
+            "audio_files": await self.data_service.get_user_audio_files(
+                user_id
+            ),
+            "training_jobs": await self.data_service.get_user_training_jobs(
+                user_id
+            ),
+            "video_projects": await self.data_service.get_user_video_projects(
+                user_id
+            ),
+            "social_accounts": await self.data_service.get_user_social_accounts(
+                user_id
+            ),
+            "usage_analytics": await self.data_service.get_user_analytics(
+                user_id
+            ),
             "consent_history": await self._get_user_consent_history(user_id),
             "processing_logs": await self._get_user_processing_logs(user_id),
         }
@@ -386,29 +431,41 @@ class DataRequestHandler:
 
         try:
             # 刪除音頻檔案
-            audio_count = await self.data_service.delete_user_audio_files(user_id)
+            audio_count = await self.data_service.delete_user_audio_files(
+                user_id
+            )
             if audio_count > 0:
                 deleted_items.append(f"audio_files: {audio_count}")
 
             # 刪除訓練任務
-            training_count = await self.data_service.delete_user_training_jobs(user_id)
+            training_count = await self.data_service.delete_user_training_jobs(
+                user_id
+            )
             if training_count > 0:
                 deleted_items.append(f"training_jobs: {training_count}")
 
             # 刪除影片專案
-            video_count = await self.data_service.delete_user_video_projects(user_id)
+            video_count = await self.data_service.delete_user_video_projects(
+                user_id
+            )
             if video_count > 0:
                 deleted_items.append(f"video_projects: {video_count}")
 
             # 刪除社群媒體帳號連結
-            social_count = await self.data_service.delete_user_social_accounts(user_id)
+            social_count = await self.data_service.delete_user_social_accounts(
+                user_id
+            )
             if social_count > 0:
                 deleted_items.append(f"social_accounts: {social_count}")
 
             # 匿名化分析資料（保留聚合統計）
-            analytics_count = await self.data_service.anonymize_user_analytics(user_id)
+            analytics_count = await self.data_service.anonymize_user_analytics(
+                user_id
+            )
             if analytics_count > 0:
-                deleted_items.append(f"analytics_anonymized: {analytics_count}")
+                deleted_items.append(
+                    f"analytics_anonymized: {analytics_count}"
+                )
 
             # 最後刪除用戶帳號
             await self.user_service.delete_user_account(user_id)
@@ -466,7 +523,9 @@ class DataRequestHandler:
             for log in logs
         ]
 
-    def _generate_verification_token(self, user_id: int, request_type: str) -> str:
+    def _generate_verification_token(
+        self, user_id: int, request_type: str
+    ) -> str:
         """生成驗證令牌"""
         content = f"{user_id}:{request_type}:{datetime.utcnow().isoformat()}"
         return hashlib.sha256(content.encode()).hexdigest()
@@ -521,27 +580,40 @@ class DataRetentionManager:
                 # 執行清理動作
                 await self._cleanup_expired_data(category, expired_logs)
                 compliance_report["actions_taken"].append(
-                    {"category": category.value, "cleaned_records": len(expired_logs)}
+                    {
+                        "category": category.value,
+                        "cleaned_records": len(expired_logs),
+                    }
                 )
 
         return compliance_report
 
-    async def _cleanup_expired_data(self, category: DataCategory, expired_logs: List):
+    async def _cleanup_expired_data(
+        self, category: DataCategory, expired_logs: List
+    ):
         """清理過期資料"""
         try:
             for log in expired_logs:
                 if category == DataCategory.AUDIO_DATA:
-                    await self.data_service.delete_expired_audio_files(log.user_id, log.timestamp)
+                    await self.data_service.delete_expired_audio_files(
+                        log.user_id, log.timestamp
+                    )
                 elif category == DataCategory.VIDEO_DATA:
-                    await self.data_service.delete_expired_video_files(log.user_id, log.timestamp)
+                    await self.data_service.delete_expired_video_files(
+                        log.user_id, log.timestamp
+                    )
                 elif category == DataCategory.USAGE_DATA:
-                    await self.data_service.anonymize_expired_usage_data(log.user_id, log.timestamp)
+                    await self.data_service.anonymize_expired_usage_data(
+                        log.user_id, log.timestamp
+                    )
 
                 # 刪除處理日誌記錄
                 self.db.delete(log)
 
             await self.db.commit()
-            logger.info(f"Cleaned up {len(expired_logs)} expired records for {category.value}")
+            logger.info(
+                f"Cleaned up {len(expired_logs)} expired records for {category.value}"
+            )
 
         except Exception as e:
             logger.error(f"Failed to cleanup expired data: {e}")
diff --git a/auto_generate_video_fold6/config/config_manager.py b/auto_generate_video_fold6/config/config_manager.py
index 76dad1d..6b3f2d4 100755
--- a/auto_generate_video_fold6/config/config_manager.py
+++ b/auto_generate_video_fold6/config/config_manager.py
@@ -4,13 +4,13 @@
 支援多層次配置繼承與動態載入
 """
 
+import copy
 import json
-import os
 import logging
-from typing import Dict, Any, Optional, List
-from pathlib import Path
+import os
 from datetime import datetime
-import copy
+from pathlib import Path
+from typing import Any
 
 logger = logging.getLogger(__name__)
 
@@ -19,29 +19,36 @@ class ConfigManager:
     """統一配置管理器"""
 
     def __init__(self, config_dir: str = None):
-        self.config_dir = Path(config_dir or os.path.join(os.path.dirname(__file__)))
-        self.current_config: Dict[str, Any] = {}
-        self.base_config: Dict[str, Any] = {}
-        self.mode_config: Dict[str, Any] = {}
+        self.config_dir = Path(
+            config_dir or os.path.join(os.path.dirname(__file__))
+        )
+        self.current_config: dict[str, Any] = {}
+        self.base_config: dict[str, Any] = {}
+        self.mode_config: dict[str, Any] = {}
         self.current_mode: str = "base"
 
         # 載入基礎配置
         self._load_base_config()
 
+        # 初始化當前配置
+        self._merge_configs()
+
     def _load_base_config(self) -> None:
         """載入基礎配置"""
         base_config_path = self.config_dir / "base-config.json"
 
         if not base_config_path.exists():
             logger.error(f"基礎配置檔案不存在: {base_config_path}")
-            raise FileNotFoundError(f"Base config not found: {base_config_path}")
+            raise FileNotFoundError(
+                f"Base config not found: {base_config_path}"
+            )
 
-        with open(base_config_path, "r", encoding="utf-8") as f:
+        with open(base_config_path, encoding="utf-8") as f:
             self.base_config = json.load(f)
 
         logger.info("已載入基礎配置")
 
-    def load_mode_config(self, mode: str) -> Dict[str, Any]:
+    def load_mode_config(self, mode: str) -> dict[str, Any]:
         """載入特定模式配置"""
         mode_config_path = self.config_dir / f"{mode}-config.json"
 
@@ -49,7 +56,7 @@ class ConfigManager:
             logger.warning(f"模式配置檔案不存在: {mode_config_path}")
             return {}
 
-        with open(mode_config_path, "r", encoding="utf-8") as f:
+        with open(mode_config_path, encoding="utf-8") as f:
             mode_config = json.load(f)
 
         logger.info(f"已載入 {mode} 模式配置")
@@ -83,10 +90,16 @@ class ConfigManager:
             "config_dir": str(self.config_dir),
         }
 
-    def _deep_merge(self, base: Dict[str, Any], override: Dict[str, Any]) -> None:
+    def _deep_merge(
+        self, base: dict[str, Any], override: dict[str, Any]
+    ) -> None:
         """深度合併字典"""
         for key, value in override.items():
-            if key in base and isinstance(base[key], dict) and isinstance(value, dict):
+            if (
+                key in base
+                and isinstance(base[key], dict)
+                and isinstance(value, dict)
+            ):
                 self._deep_merge(base[key], value)
             else:
                 base[key] = value
@@ -117,19 +130,19 @@ class ConfigManager:
         # 設置值
         current[keys[-1]] = value
 
-    def get_service_config(self, service_name: str) -> Dict[str, Any]:
+    def get_service_config(self, service_name: str) -> dict[str, Any]:
         """獲取特定服務配置"""
         return self.get(f"services.{service_name}", {})
 
-    def get_generation_config(self) -> Dict[str, Any]:
+    def get_generation_config(self) -> dict[str, Any]:
         """獲取生成配置"""
         return self.get("generation", {})
 
-    def get_cost_config(self) -> Dict[str, Any]:
+    def get_cost_config(self) -> dict[str, Any]:
         """獲取成本控制配置"""
         return self.get("cost_control", {})
 
-    def get_resource_config(self) -> Dict[str, Any]:
+    def get_resource_config(self) -> dict[str, Any]:
         """獲取資源配置"""
         return self.get("resources", {})
 
@@ -165,7 +178,9 @@ class ConfigManager:
 
     def get_api_rate_limit(self, provider: str) -> int:
         """獲取 API 速率限制"""
-        return self.get(f"cost_control.api_rate_limits.{provider}_requests_per_hour", 100)
+        return self.get(
+            f"cost_control.api_rate_limits.{provider}_requests_per_hour", 100
+        )
 
     def save_current_config(self, filename: str = None) -> str:
         """保存當前配置到檔案"""
@@ -180,7 +195,7 @@ class ConfigManager:
         logger.info(f"已保存當前配置到: {output_path}")
         return str(output_path)
 
-    def validate_config(self) -> List[str]:
+    def validate_config(self) -> list[str]:
         """驗證配置完整性"""
         errors = []
 
@@ -188,7 +203,7 @@ class ConfigManager:
         required_fields = [
             "generation.daily_video_limit",
             "generation.platforms",
-            "ai_services.text_generation.provider",
+            "ai_services.text_generation.primary_provider",
             "ai_services.image_generation.provider",
         ]
 
@@ -207,15 +222,19 @@ class ConfigManager:
 
         return errors
 
-    def get_platform_config(self, platform: str) -> Dict[str, Any]:
+    def get_platform_config(self, platform: str) -> dict[str, Any]:
         """獲取特定平台配置"""
         return self.get(f"video_styles.{platform}", {})
 
-    def get_content_template(self, category: str, template_type: str = "intro") -> List[str]:
+    def get_content_template(
+        self, category: str, template_type: str = "intro"
+    ) -> list[str]:
         """獲取內容模板"""
-        return self.get(f"content_templates.{category}.{template_type}_templates", [])
+        return self.get(
+            f"content_templates.{category}.{template_type}_templates", []
+        )
 
-    def get_enabled_platforms(self) -> List[str]:
+    def get_enabled_platforms(self) -> list[str]:
         """獲取啟用的平台列表"""
         return self.get("generation.platforms", [])
 
@@ -241,7 +260,7 @@ class ConfigManager:
         logger.info(f"已匯出配置到: {export_path}")
         return str(export_path)
 
-    def get_summary(self) -> Dict[str, Any]:
+    def get_summary(self) -> dict[str, Any]:
         """獲取配置摘要"""
         return {
             "current_mode": self.current_mode,
diff --git a/auto_generate_video_fold6/conftest.py b/auto_generate_video_fold6/conftest.py
index 8f43b78..58a0fc0 100644
--- a/auto_generate_video_fold6/conftest.py
+++ b/auto_generate_video_fold6/conftest.py
@@ -52,7 +52,9 @@ async def test_engine():
 async def db_session(test_engine) -> AsyncGenerator[AsyncSession, None]:
     """創建測試用的資料庫會話"""
     async with test_engine.begin() as conn:
-        async_session = sessionmaker(conn, class_=AsyncSession, expire_on_commit=False)
+        async_session = sessionmaker(
+            conn, class_=AsyncSession, expire_on_commit=False
+        )
         async with async_session() as session:
             yield session
 
@@ -89,7 +91,9 @@ def mock_s3():
 @pytest.fixture
 async def async_client() -> AsyncGenerator[AsyncClient, None]:
     """創建異步 HTTP 客戶端供測試使用"""
-    async with AsyncClient(base_url="http://testserver", timeout=30.0) as client:
+    async with AsyncClient(
+        base_url="http://testserver", timeout=30.0
+    ) as client:
         yield client
 
 
@@ -117,7 +121,11 @@ def sample_project_data():
         "description": "A test project for automated testing",
         "status": "draft",
         "user_id": 1,
-        "settings": {"platform": "youtube", "duration": "short", "tone": "professional"},
+        "settings": {
+            "platform": "youtube",
+            "duration": "short",
+            "tone": "professional",
+        },
         "created_at": "2024-01-01T00:00:00Z",
         "updated_at": "2024-01-01T00:00:00Z",
     }
@@ -131,16 +139,30 @@ def sample_script_data():
         "title": "Test Script",
         "content": "This is a test script content for automated testing.",
         "scenes": [
-            {"id": 1, "text": "Welcome to our test video", "duration": 3, "type": "intro"},
+            {
+                "id": 1,
+                "text": "Welcome to our test video",
+                "duration": 3,
+                "type": "intro",
+            },
             {
                 "id": 2,
                 "text": "This is the main content of our test",
                 "duration": 8,
                 "type": "content",
             },
-            {"id": 3, "text": "Thank you for watching", "duration": 2, "type": "outro"},
+            {
+                "id": 3,
+                "text": "Thank you for watching",
+                "duration": 2,
+                "type": "outro",
+            },
         ],
-        "metadata": {"duration": 13, "word_count": 85, "reading_time": "13 seconds"},
+        "metadata": {
+            "duration": 13,
+            "word_count": 85,
+            "reading_time": "13 seconds",
+        },
         "project_id": 1,
         "created_at": "2024-01-01T00:00:00Z",
         "updated_at": "2024-01-01T00:00:00Z",
@@ -158,11 +180,30 @@ def mock_ai_service():
             "title": "Generated Test Script",
             "content": "This is AI generated content for testing.",
             "scenes": [
-                {"id": 1, "text": "Generated intro", "duration": 3, "type": "intro"},
-                {"id": 2, "text": "Generated content", "duration": 8, "type": "content"},
-                {"id": 3, "text": "Generated outro", "duration": 2, "type": "outro"},
+                {
+                    "id": 1,
+                    "text": "Generated intro",
+                    "duration": 3,
+                    "type": "intro",
+                },
+                {
+                    "id": 2,
+                    "text": "Generated content",
+                    "duration": 8,
+                    "type": "content",
+                },
+                {
+                    "id": 3,
+                    "text": "Generated outro",
+                    "duration": 2,
+                    "type": "outro",
+                },
             ],
-            "metadata": {"duration": 13, "word_count": 67, "reading_time": "13 seconds"},
+            "metadata": {
+                "duration": 13,
+                "word_count": 67,
+                "reading_time": "13 seconds",
+            },
         }
     )
 
@@ -214,7 +255,10 @@ def auth_headers(sample_user_data):
     """提供認證標頭"""
     # 在實際實現中，這裡會生成真實的 JWT token
     fake_token = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.test.token"
-    return {"Authorization": f"Bearer {fake_token}", "Content-Type": "application/json"}
+    return {
+        "Authorization": f"Bearer {fake_token}",
+        "Content-Type": "application/json",
+    }
 
 
 # 測試標記設定
@@ -225,11 +269,19 @@ pytest_plugins = []
 def pytest_configure(config):
     """配置 pytest"""
     config.addinivalue_line("markers", "unit: marks tests as unit tests")
-    config.addinivalue_line("markers", "integration: marks tests as integration tests")
+    config.addinivalue_line(
+        "markers", "integration: marks tests as integration tests"
+    )
     config.addinivalue_line("markers", "slow: marks tests as slow running")
-    config.addinivalue_line("markers", "requires_db: marks tests that require database")
-    config.addinivalue_line("markers", "requires_redis: marks tests that require Redis")
-    config.addinivalue_line("markers", "requires_s3: marks tests that require S3")
+    config.addinivalue_line(
+        "markers", "requires_db: marks tests that require database"
+    )
+    config.addinivalue_line(
+        "markers", "requires_redis: marks tests that require Redis"
+    )
+    config.addinivalue_line(
+        "markers", "requires_s3: marks tests that require S3"
+    )
 
 
 # 自動使用 fixtures
diff --git a/auto_generate_video_fold6/examples/ai_integration_demo.py b/auto_generate_video_fold6/examples/ai_integration_demo.py
index 891bab0..4ea2935 100644
--- a/auto_generate_video_fold6/examples/ai_integration_demo.py
+++ b/auto_generate_video_fold6/examples/ai_integration_demo.py
@@ -23,7 +23,11 @@ async def demo_gemini_integration():
         import sys
         import os
 
-        sys.path.append(os.path.join(os.path.dirname(__file__), "..", "services", "ai-service"))
+        sys.path.append(
+            os.path.join(
+                os.path.dirname(__file__), "..", "services", "ai-service"
+            )
+        )
         from gemini_client import (
             generate_video_script,
             analyze_trends,
@@ -59,7 +63,9 @@ async def demo_gemini_integration():
             print("✅ 趨勢分析成功:")
             print(f"病毒潛力: {analysis.get('viral_potential', 'N/A')}/10")
             print(f"目標受眾: {analysis.get('target_audience', 'N/A')}")
-            print(f"推薦平台: {', '.join(analysis.get('recommended_platforms', []))}")
+            print(
+                f"推薦平台: {', '.join(analysis.get('recommended_platforms', []))}"
+            )
         else:
             print(f"❌ 趨勢分析失敗: {analysis.get('error')}")
 
@@ -68,7 +74,9 @@ async def demo_gemini_integration():
         async with GeminiClient(api_key=api_key) as client:
             result = await client.generate_content(
                 prompt="為科技短影片創作吸引人的開場白，要求生動有趣",
-                generation_config=GeminiGenerationConfig(temperature=0.9, max_output_tokens=150),
+                generation_config=GeminiGenerationConfig(
+                    temperature=0.9, max_output_tokens=150
+                ),
             )
 
             if result.success:
@@ -91,8 +99,16 @@ async def demo_suno_integration():
         import sys
         import os
 
-        sys.path.append(os.path.join(os.path.dirname(__file__), "..", "services", "music-service"))
-        from suno_client import generate_music_for_video, SunoClient, MusicGenerationRequest
+        sys.path.append(
+            os.path.join(
+                os.path.dirname(__file__), "..", "services", "music-service"
+            )
+        )
+        from suno_client import (
+            generate_music_for_video,
+            SunoClient,
+            MusicGenerationRequest,
+        )
 
         api_key = os.getenv("SUNO_API_KEY")
         if not api_key:
@@ -119,14 +135,18 @@ async def demo_suno_integration():
             if music_result.audio_url:
                 async with SunoClient(api_key=api_key) as client:
                     output_path = Path("examples/demo_music.mp3")
-                    success = await client.download_audio(music_result.audio_url, output_path)
+                    success = await client.download_audio(
+                        music_result.audio_url, output_path
+                    )
 
                     if success:
                         print(f"✅ 音樂文件已下載到: {output_path}")
                     else:
                         print("❌ 音樂文件下載失敗")
         else:
-            print(f"❌ 音樂生成失敗: {music_result.error_message if music_result else '未知錯誤'}")
+            print(
+                f"❌ 音樂生成失敗: {music_result.error_message if music_result else '未知錯誤'}"
+            )
 
         # 2. 生成不同風格的音樂
         print("\n🎪 生成娛樂風格音樂...")
@@ -139,13 +159,17 @@ async def demo_suno_integration():
                 title="娛樂節目背景音樂",
             )
 
-            entertainment_result = await client.generate_music(entertainment_request)
+            entertainment_result = await client.generate_music(
+                entertainment_request
+            )
 
             if entertainment_result.status == "completed":
                 print("✅ 娛樂風格音樂生成成功!")
                 print(f"標題: {entertainment_result.title}")
             else:
-                print(f"❌ 娛樂風格音樂生成失敗: {entertainment_result.error_message}")
+                print(
+                    f"❌ 娛樂風格音樂生成失敗: {entertainment_result.error_message}"
+                )
 
     except ImportError as e:
         print(f"❌ 導入錯誤: {e}")
@@ -193,7 +217,9 @@ async def demo_ai_orchestrator():
             fallback_enabled=True,
         )
 
-        analysis_response = await orchestrator.process_request(analysis_request)
+        analysis_response = await orchestrator.process_request(
+            analysis_request
+        )
 
         if analysis_response.success:
             print("✅ 內容分析成功:")
@@ -209,7 +235,9 @@ async def demo_ai_orchestrator():
         # 3. 音樂生成
         print("\n🎵 智能音樂生成...")
         music_content = await generate_music_for_video(
-            prompt="科技感十足的背景音樂，適合產品介紹", duration=20, style="futuristic, tech"
+            prompt="科技感十足的背景音樂，適合產品介紹",
+            duration=20,
+            style="futuristic, tech",
         )
 
         if music_content:
@@ -253,7 +281,9 @@ async def demo_complete_workflow():
                 style="professional",
                 api_key=gemini_key,
             )
-            print(f"✅ 腳本: {script[:100]}..." if script else "❌ 腳本生成失敗")
+            print(
+                f"✅ 腳本: {script[:100]}..." if script else "❌ 腳本生成失敗"
+            )
         else:
             script = "AI 技術正在快速發展，改變著我們的生活方式..."
             print("⚠️ 使用預設腳本（未設置 Gemini API Key）")
@@ -278,12 +308,18 @@ async def demo_complete_workflow():
 
         # 3. 分析和優化
         print("\n3️⃣ 內容分析和優化建議...")
-        from services.ai_service.ai_orchestrator import AIOrchestrator, AIRequest, AITaskType
+        from services.ai_service.ai_orchestrator import (
+            AIOrchestrator,
+            AIRequest,
+            AITaskType,
+        )
 
         orchestrator = AIOrchestrator()
 
         trend_request = AIRequest(
-            task_type=AITaskType.TREND_ANALYSIS, prompt=script, fallback_enabled=True
+            task_type=AITaskType.TREND_ANALYSIS,
+            prompt=script,
+            fallback_enabled=True,
         )
 
         trend_response = await orchestrator.process_request(trend_request)
diff --git a/auto_generate_video_fold6/monitoring/analytics/log_analyzer.py b/auto_generate_video_fold6/monitoring/analytics/log_analyzer.py
index 50a5f4d..f97117a 100644
--- a/auto_generate_video_fold6/monitoring/analytics/log_analyzer.py
+++ b/auto_generate_video_fold6/monitoring/analytics/log_analyzer.py
@@ -111,7 +111,9 @@ class LogAnalyzer:
         }
 
         try:
-            result = await self.es.search(index="auto-video-logs-*", body=query, size=0)
+            result = await self.es.search(
+                index="auto-video-logs-*", body=query, size=0
+            )
 
             total_errors = result["hits"]["total"]["value"]
 
@@ -130,7 +132,9 @@ class LogAnalyzer:
                 await self.send_alert(alert)
 
             # 分析錯誤分佈
-            services_with_errors = result["aggregations"]["error_by_service"]["buckets"]
+            services_with_errors = result["aggregations"]["error_by_service"][
+                "buckets"
+            ]
             for service_bucket in services_with_errors:
                 service = service_bucket["key"]
                 error_count = service_bucket["doc_count"]
@@ -168,16 +172,26 @@ class LogAnalyzer:
             },
             "aggs": {
                 "avg_response_time": {"avg": {"field": "duration_ms"}},
-                "p95_response_time": {"percentiles": {"field": "duration_ms", "percents": [95]}},
-                "slow_requests": {"filter": {"range": {"duration_ms": {"gte": 5000}}}},
+                "p95_response_time": {
+                    "percentiles": {"field": "duration_ms", "percents": [95]}
+                },
+                "slow_requests": {
+                    "filter": {"range": {"duration_ms": {"gte": 5000}}}
+                },
             },
         }
 
         try:
-            result = await self.es.search(index="auto-video-logs-*", body=query, size=0)
+            result = await self.es.search(
+                index="auto-video-logs-*", body=query, size=0
+            )
 
-            p95_time = result["aggregations"]["p95_response_time"]["values"]["95.0"]
-            slow_requests = result["aggregations"]["slow_requests"]["doc_count"]
+            p95_time = result["aggregations"]["p95_response_time"]["values"][
+                "95.0"
+            ]
+            slow_requests = result["aggregations"]["slow_requests"][
+                "doc_count"
+            ]
 
             # 檢查回應時間
             if p95_time > self.thresholds["response_time_p95"]:
@@ -224,7 +238,11 @@ class LogAnalyzer:
                     "bool": {
                         "must": [
                             {"match": {"message": "failed login"}},
-                            {"range": {"@timestamp": {"gte": since.isoformat()}}},
+                            {
+                                "range": {
+                                    "@timestamp": {"gte": since.isoformat()}
+                                }
+                            },
                         ]
                     }
                 },
@@ -236,7 +254,11 @@ class LogAnalyzer:
                     "bool": {
                         "must": [
                             {"terms": {"status_code": [401, 403]}},
-                            {"range": {"@timestamp": {"gte": since.isoformat()}}},
+                            {
+                                "range": {
+                                    "@timestamp": {"gte": since.isoformat()}
+                                }
+                            },
                         ]
                     }
                 },
@@ -247,8 +269,16 @@ class LogAnalyzer:
                 "query": {
                     "bool": {
                         "must": [
-                            {"regexp": {"message": ".*(attack|breach|injection|xss).*"}},
-                            {"range": {"@timestamp": {"gte": since.isoformat()}}},
+                            {
+                                "regexp": {
+                                    "message": ".*(attack|breach|injection|xss).*"
+                                }
+                            },
+                            {
+                                "range": {
+                                    "@timestamp": {"gte": since.isoformat()}
+                                }
+                            },
                         ]
                     }
                 },
@@ -258,7 +288,9 @@ class LogAnalyzer:
         for sec_query in security_queries:
             try:
                 result = await self.es.search(
-                    index="auto-video-logs-*", body={"query": sec_query["query"]}, size=100
+                    index="auto-video-logs-*",
+                    body={"query": sec_query["query"]},
+                    size=100,
                 )
 
                 event_count = result["hits"]["total"]["value"]
@@ -269,13 +301,17 @@ class LogAnalyzer:
                     ip_counter = Counter()
                     for event in events:
                         source = event["_source"]
-                        ip = source.get("ip_address") or source.get("source_ip")
+                        ip = source.get("ip_address") or source.get(
+                            "source_ip"
+                        )
                         if ip:
                             ip_counter[ip] += 1
 
                     # 檢查是否有來自同一 IP 的大量事件
                     for ip, count in ip_counter.items():
-                        if count >= self.thresholds.get("failed_login_attempts", 10):
+                        if count >= self.thresholds.get(
+                            "failed_login_attempts", 10
+                        ):
                             alert = Alert(
                                 id=f"security_{sec_query['name']}_{ip}_{int(time.time())}",
                                 type="security",
@@ -293,7 +329,9 @@ class LogAnalyzer:
                             await self.send_alert(alert)
 
             except Exception as e:
-                logger.error(f"Security analysis failed for {sec_query['name']}: {e}")
+                logger.error(
+                    f"Security analysis failed for {sec_query['name']}: {e}"
+                )
 
     async def analyze_business_metrics(self):
         """分析業務指標"""
@@ -324,26 +362,38 @@ class LogAnalyzer:
                     ]
                 }
             },
-            "aggs": {"status_breakdown": {"terms": {"field": "status.keyword"}}},
+            "aggs": {
+                "status_breakdown": {"terms": {"field": "status.keyword"}}
+            },
         }
 
         try:
             # 用戶註冊分析
-            user_result = await self.es.search(index="auto-video-logs-*", body=user_query, size=0)
+            user_result = await self.es.search(
+                index="auto-video-logs-*", body=user_query, size=0
+            )
             user_registrations = user_result["hits"]["total"]["value"]
 
             # 影片生成分析
-            video_result = await self.es.search(index="auto-video-logs-*", body=video_query, size=0)
+            video_result = await self.es.search(
+                index="auto-video-logs-*", body=video_query, size=0
+            )
             total_generations = video_result["hits"]["total"]["value"]
 
             # 計算成功率
-            status_buckets = video_result["aggregations"]["status_breakdown"]["buckets"]
+            status_buckets = video_result["aggregations"]["status_breakdown"][
+                "buckets"
+            ]
             success_count = 0
             for bucket in status_buckets:
                 if bucket["key"] == "success":
                     success_count = bucket["doc_count"]
 
-            success_rate = success_count / total_generations if total_generations > 0 else 1.0
+            success_rate = (
+                success_count / total_generations
+                if total_generations > 0
+                else 1.0
+            )
 
             # 儲存業務指標到 Redis
             metrics = {
@@ -353,7 +403,9 @@ class LogAnalyzer:
                 "timestamp": now.isoformat(),
             }
 
-            self.redis.setex("business_metrics", 3600, json.dumps(metrics))  # 1小時過期
+            self.redis.setex(
+                "business_metrics", 3600, json.dumps(metrics)
+            )  # 1小時過期
 
             # 檢查業務異常
             if success_rate < 0.8 and total_generations > 10:
@@ -365,7 +417,10 @@ class LogAnalyzer:
                     message=f"Video generation success rate is {success_rate:.2%}",
                     service="video-service",
                     timestamp=now,
-                    data={"success_rate": success_rate, "total_generations": total_generations},
+                    data={
+                        "success_rate": success_rate,
+                        "total_generations": total_generations,
+                    },
                 )
                 await self.send_alert(alert)
 
@@ -401,7 +456,9 @@ class LogAnalyzer:
         }
 
         try:
-            result = await self.es.search(index="auto-video-logs-*", body=system_query, size=0)
+            result = await self.es.search(
+                index="auto-video-logs-*", body=system_query, size=0
+            )
 
             if "aggregations" in result:
                 avg_memory = result["aggregations"]["avg_memory"]["value"]
@@ -452,8 +509,12 @@ class LogAnalyzer:
     async def generate_daily_insights(self):
         """生成每日洞察報告"""
         yesterday = datetime.utcnow() - timedelta(days=1)
-        start_of_yesterday = yesterday.replace(hour=0, minute=0, second=0, microsecond=0)
-        end_of_yesterday = yesterday.replace(hour=23, minute=59, second=59, microsecond=999999)
+        start_of_yesterday = yesterday.replace(
+            hour=0, minute=0, second=0, microsecond=0
+        )
+        end_of_yesterday = yesterday.replace(
+            hour=23, minute=59, second=59, microsecond=999999
+        )
 
         insights = {
             "date": yesterday.date().isoformat(),
@@ -503,7 +564,8 @@ class LogAnalyzer:
         # 儲存到 Elasticsearch
         try:
             await self.es.index(
-                index=f"alerts-{datetime.utcnow().strftime('%Y.%m.%d')}", body=alert_data
+                index=f"alerts-{datetime.utcnow().strftime('%Y.%m.%d')}",
+                body=alert_data,
             )
         except Exception as e:
             logger.error(f"Failed to index alert: {e}")
diff --git a/auto_generate_video_fold6/monitoring/analytics_dashboard.py b/auto_generate_video_fold6/monitoring/analytics_dashboard.py
index ab57784..d3f9b5b 100755
--- a/auto_generate_video_fold6/monitoring/analytics_dashboard.py
+++ b/auto_generate_video_fold6/monitoring/analytics_dashboard.py
@@ -50,12 +50,23 @@ class AnalyticsDashboard:
                 # 標題
                 html.Div(
                     [
-                        html.H1("🎬 Auto Video Generation 分析儀表板", className="dashboard-title"),
-                        html.P("實時監控和數據分析", className="dashboard-subtitle"),
+                        html.H1(
+                            "🎬 Auto Video Generation 分析儀表板",
+                            className="dashboard-title",
+                        ),
+                        html.P(
+                            "實時監控和數據分析",
+                            className="dashboard-subtitle",
+                        ),
                         html.Div(
                             [
-                                html.Span("最後更新: ", className="update-label"),
-                                html.Span(id="last-update-time", className="update-time"),
+                                html.Span(
+                                    "最後更新: ", className="update-label"
+                                ),
+                                html.Span(
+                                    id="last-update-time",
+                                    className="update-time",
+                                ),
                             ],
                             className="update-info",
                         ),
@@ -67,16 +78,30 @@ class AnalyticsDashboard:
                     [
                         html.Div(
                             [
-                                html.Label("時間範圍:", className="control-label"),
+                                html.Label(
+                                    "時間範圍:", className="control-label"
+                                ),
                                 dcc.Dropdown(
                                     id="time-range-dropdown",
                                     options=[
                                         {"label": "今天", "value": "today"},
-                                        {"label": "昨天", "value": "yesterday"},
+                                        {
+                                            "label": "昨天",
+                                            "value": "yesterday",
+                                        },
                                         {"label": "過去7天", "value": "7days"},
-                                        {"label": "過去30天", "value": "30days"},
-                                        {"label": "本月", "value": "this_month"},
-                                        {"label": "上月", "value": "last_month"},
+                                        {
+                                            "label": "過去30天",
+                                            "value": "30days",
+                                        },
+                                        {
+                                            "label": "本月",
+                                            "value": "this_month",
+                                        },
+                                        {
+                                            "label": "上月",
+                                            "value": "last_month",
+                                        },
                                     ],
                                     value="7days",
                                     className="control-dropdown",
@@ -86,14 +111,25 @@ class AnalyticsDashboard:
                         ),
                         html.Div(
                             [
-                                html.Label("數據類型:", className="control-label"),
+                                html.Label(
+                                    "數據類型:", className="control-label"
+                                ),
                                 dcc.Dropdown(
                                     id="data-type-dropdown",
                                     options=[
                                         {"label": "成本分析", "value": "cost"},
-                                        {"label": "生成統計", "value": "generation"},
-                                        {"label": "效能指標", "value": "performance"},
-                                        {"label": "錯誤分析", "value": "errors"},
+                                        {
+                                            "label": "生成統計",
+                                            "value": "generation",
+                                        },
+                                        {
+                                            "label": "效能指標",
+                                            "value": "performance",
+                                        },
+                                        {
+                                            "label": "錯誤分析",
+                                            "value": "errors",
+                                        },
                                     ],
                                     value="cost",
                                     className="control-dropdown",
@@ -104,10 +140,14 @@ class AnalyticsDashboard:
                         html.Div(
                             [
                                 html.Button(
-                                    "刷新數據", id="refresh-button", className="refresh-button"
+                                    "刷新數據",
+                                    id="refresh-button",
+                                    className="refresh-button",
                                 ),
                                 html.Button(
-                                    "匯出報告", id="export-button", className="export-button"
+                                    "匯出報告",
+                                    id="export-button",
+                                    className="export-button",
                                 ),
                             ],
                             className="button-group",
@@ -123,14 +163,23 @@ class AnalyticsDashboard:
                 # 主要圖表區域
                 html.Div(
                     [
-                        html.Div([dcc.Graph(id="main-chart")], className="chart-container"),
-                        html.Div([dcc.Graph(id="secondary-chart")], className="chart-container"),
+                        html.Div(
+                            [dcc.Graph(id="main-chart")],
+                            className="chart-container",
+                        ),
+                        html.Div(
+                            [dcc.Graph(id="secondary-chart")],
+                            className="chart-container",
+                        ),
                     ],
                     className="charts-section",
                 ),
                 # 詳細數據表格
                 html.Div(
-                    [html.H3("詳細數據", className="section-title"), html.Div(id="data-table")],
+                    [
+                        html.H3("詳細數據", className="section-title"),
+                        html.Div(id="data-table"),
+                    ],
                     className="table-section",
                 ),
                 # 隱藏的 div 用於存儲數據
@@ -221,7 +270,10 @@ class AnalyticsDashboard:
         """設置回調函數"""
 
         @self.app.callback(
-            [Output("data-store", "children"), Output("last-update-time", "children")],
+            [
+                Output("data-store", "children"),
+                Output("last-update-time", "children"),
+            ],
             [
                 Input("time-range-dropdown", "value"),
                 Input("data-type-dropdown", "value"),
@@ -237,7 +289,10 @@ class AnalyticsDashboard:
                 logger.error(f"獲取數據失敗: {e}")
                 return [json.dumps({}), "獲取失敗"]
 
-        @self.app.callback(Output("metrics-cards", "children"), [Input("data-store", "children")])
+        @self.app.callback(
+            Output("metrics-cards", "children"),
+            [Input("data-store", "children")],
+        )
         def update_metrics_cards(data_json):
             """更新指標卡片"""
             try:
@@ -249,7 +304,10 @@ class AnalyticsDashboard:
 
         @self.app.callback(
             Output("main-chart", "figure"),
-            [Input("data-store", "children"), Input("data-type-dropdown", "value")],
+            [
+                Input("data-store", "children"),
+                Input("data-type-dropdown", "value"),
+            ],
         )
         def update_main_chart(data_json, data_type):
             """更新主圖表"""
@@ -262,7 +320,10 @@ class AnalyticsDashboard:
 
         @self.app.callback(
             Output("secondary-chart", "figure"),
-            [Input("data-store", "children"), Input("data-type-dropdown", "value")],
+            [
+                Input("data-store", "children"),
+                Input("data-type-dropdown", "value"),
+            ],
         )
         def update_secondary_chart(data_json, data_type):
             """更新次圖表"""
@@ -273,7 +334,9 @@ class AnalyticsDashboard:
                 logger.error(f"更新次圖表失敗: {e}")
                 return go.Figure()
 
-        @self.app.callback(Output("data-table", "children"), [Input("data-store", "children")])
+        @self.app.callback(
+            Output("data-table", "children"), [Input("data-store", "children")]
+        )
         def update_data_table(data_json):
             """更新數據表格"""
             try:
@@ -283,7 +346,9 @@ class AnalyticsDashboard:
                 logger.error(f"更新數據表格失敗: {e}")
                 return html.P("數據載入失敗")
 
-    async def _fetch_data(self, time_range: str, data_type: str) -> Dict[str, Any]:
+    async def _fetch_data(
+        self, time_range: str, data_type: str
+    ) -> Dict[str, Any]:
         """獲取數據"""
         end_date = date.today()
 
@@ -305,7 +370,9 @@ class AnalyticsDashboard:
                 end_date = date(end_date.year, 1, 1) - timedelta(days=1)
             else:
                 start_date = date(end_date.year, end_date.month - 1, 1)
-                end_date = date(end_date.year, end_date.month, 1) - timedelta(days=1)
+                end_date = date(end_date.year, end_date.month, 1) - timedelta(
+                    days=1
+                )
         else:
             start_date = end_date - timedelta(days=7)
 
@@ -321,7 +388,9 @@ class AnalyticsDashboard:
         else:
             return {}
 
-    async def _fetch_cost_data(self, start_date: date, end_date: date) -> Dict[str, Any]:
+    async def _fetch_cost_data(
+        self, start_date: date, end_date: date
+    ) -> Dict[str, Any]:
         """獲取成本數據"""
         if not self.cost_tracker:
             return self._get_mock_cost_data(start_date, end_date)
@@ -332,7 +401,10 @@ class AnalyticsDashboard:
                 summary = await self.cost_tracker.get_daily_summary(start_date)
                 return {
                     "type": "cost",
-                    "period": {"start": start_date.isoformat(), "end": end_date.isoformat()},
+                    "period": {
+                        "start": start_date.isoformat(),
+                        "end": end_date.isoformat(),
+                    },
                     "total_cost": summary.total_cost,
                     "api_calls": summary.api_calls_count,
                     "providers": summary.providers_breakdown,
@@ -350,20 +422,31 @@ class AnalyticsDashboard:
                 weekly_report = await self.cost_tracker.get_weekly_report()
                 return {
                     "type": "cost",
-                    "period": {"start": start_date.isoformat(), "end": end_date.isoformat()},
+                    "period": {
+                        "start": start_date.isoformat(),
+                        "end": end_date.isoformat(),
+                    },
                     "total_cost": weekly_report["total_cost"],
                     "api_calls": weekly_report["total_calls"],
                     "average_daily": weekly_report["average_daily_cost"],
                     "daily_data": [
-                        {"date": date_str, "cost": stats["cost"], "calls": stats["calls"]}
-                        for date_str, stats in weekly_report["daily_stats"].items()
+                        {
+                            "date": date_str,
+                            "cost": stats["cost"],
+                            "calls": stats["calls"],
+                        }
+                        for date_str, stats in weekly_report[
+                            "daily_stats"
+                        ].items()
                     ],
                 }
         except Exception as e:
             logger.error(f"獲取成本數據失敗: {e}")
             return self._get_mock_cost_data(start_date, end_date)
 
-    def _get_mock_cost_data(self, start_date: date, end_date: date) -> Dict[str, Any]:
+    def _get_mock_cost_data(
+        self, start_date: date, end_date: date
+    ) -> Dict[str, Any]:
         """獲取模擬成本數據"""
         import random
 
@@ -377,7 +460,11 @@ class AnalyticsDashboard:
             daily_calls = random.randint(30, 80)
 
             daily_data.append(
-                {"date": current_date.isoformat(), "cost": daily_cost, "calls": daily_calls}
+                {
+                    "date": current_date.isoformat(),
+                    "cost": daily_cost,
+                    "calls": daily_calls,
+                }
             )
 
             total_cost += daily_cost
@@ -386,7 +473,10 @@ class AnalyticsDashboard:
 
         return {
             "type": "cost",
-            "period": {"start": start_date.isoformat(), "end": end_date.isoformat()},
+            "period": {
+                "start": start_date.isoformat(),
+                "end": end_date.isoformat(),
+            },
             "total_cost": total_cost,
             "api_calls": total_calls,
             "providers": {
@@ -402,7 +492,9 @@ class AnalyticsDashboard:
             "daily_data": daily_data,
         }
 
-    async def _fetch_generation_data(self, start_date: date, end_date: date) -> Dict[str, Any]:
+    async def _fetch_generation_data(
+        self, start_date: date, end_date: date
+    ) -> Dict[str, Any]:
         """獲取生成數據（模擬）"""
         import random
 
@@ -420,7 +512,9 @@ class AnalyticsDashboard:
                     "date": current_date.isoformat(),
                     "videos": videos,
                     "success": success,
-                    "success_rate": (success / videos) * 100 if videos > 0 else 0,
+                    "success_rate": (success / videos) * 100
+                    if videos > 0
+                    else 0,
                 }
             )
 
@@ -430,10 +524,15 @@ class AnalyticsDashboard:
 
         return {
             "type": "generation",
-            "period": {"start": start_date.isoformat(), "end": end_date.isoformat()},
+            "period": {
+                "start": start_date.isoformat(),
+                "end": end_date.isoformat(),
+            },
             "total_videos": total_videos,
             "total_success": total_success,
-            "success_rate": (total_success / total_videos) * 100 if total_videos > 0 else 0,
+            "success_rate": (total_success / total_videos) * 100
+            if total_videos > 0
+            else 0,
             "platforms": {
                 "TikTok": int(total_videos * 0.45),
                 "Instagram": int(total_videos * 0.35),
@@ -442,7 +541,9 @@ class AnalyticsDashboard:
             "daily_data": daily_data,
         }
 
-    async def _fetch_performance_data(self, start_date: date, end_date: date) -> Dict[str, Any]:
+    async def _fetch_performance_data(
+        self, start_date: date, end_date: date
+    ) -> Dict[str, Any]:
         """獲取效能數據（模擬）"""
         import random
 
@@ -463,20 +564,30 @@ class AnalyticsDashboard:
 
         return {
             "type": "performance",
-            "period": {"start": start_date.isoformat(), "end": end_date.isoformat()},
+            "period": {
+                "start": start_date.isoformat(),
+                "end": end_date.isoformat(),
+            },
             "daily_data": daily_data,
         }
 
-    async def _fetch_error_data(self, start_date: date, end_date: date) -> Dict[str, Any]:
+    async def _fetch_error_data(
+        self, start_date: date, end_date: date
+    ) -> Dict[str, Any]:
         """獲取錯誤數據（模擬）"""
         import random
 
         error_types = ["API錯誤", "網路超時", "資源不足", "配置錯誤", "其他"]
-        error_data = {error_type: random.randint(0, 10) for error_type in error_types}
+        error_data = {
+            error_type: random.randint(0, 10) for error_type in error_types
+        }
 
         return {
             "type": "errors",
-            "period": {"start": start_date.isoformat(), "end": end_date.isoformat()},
+            "period": {
+                "start": start_date.isoformat(),
+                "end": end_date.isoformat(),
+            },
             "total_errors": sum(error_data.values()),
             "error_types": error_data,
         }
@@ -493,14 +604,20 @@ class AnalyticsDashboard:
             cards = [
                 html.Div(
                     [
-                        html.Div(f"${data.get('total_cost', 0):.2f}", className="metric-value"),
+                        html.Div(
+                            f"${data.get('total_cost', 0):.2f}",
+                            className="metric-value",
+                        ),
                         html.Div("總成本", className="metric-label"),
                     ],
                     className="metric-card",
                 ),
                 html.Div(
                     [
-                        html.Div(str(data.get("api_calls", 0)), className="metric-value"),
+                        html.Div(
+                            str(data.get("api_calls", 0)),
+                            className="metric-value",
+                        ),
                         html.Div("API 呼叫次數", className="metric-label"),
                     ],
                     className="metric-card",
@@ -521,21 +638,30 @@ class AnalyticsDashboard:
             cards = [
                 html.Div(
                     [
-                        html.Div(str(data.get("total_videos", 0)), className="metric-value"),
+                        html.Div(
+                            str(data.get("total_videos", 0)),
+                            className="metric-value",
+                        ),
                         html.Div("總影片數", className="metric-label"),
                     ],
                     className="metric-card",
                 ),
                 html.Div(
                     [
-                        html.Div(f"{data.get('success_rate', 0):.1f}%", className="metric-value"),
+                        html.Div(
+                            f"{data.get('success_rate', 0):.1f}%",
+                            className="metric-value",
+                        ),
                         html.Div("成功率", className="metric-label"),
                     ],
                     className="metric-card",
                 ),
                 html.Div(
                     [
-                        html.Div(str(data.get("total_success", 0)), className="metric-value"),
+                        html.Div(
+                            str(data.get("total_success", 0)),
+                            className="metric-value",
+                        ),
                         html.Div("成功生成", className="metric-label"),
                     ],
                     className="metric-card",
@@ -544,10 +670,14 @@ class AnalyticsDashboard:
 
         return cards
 
-    def _create_main_chart(self, data: Dict[str, Any], data_type: str) -> go.Figure:
+    def _create_main_chart(
+        self, data: Dict[str, Any], data_type: str
+    ) -> go.Figure:
         """創建主圖表"""
         if not data:
-            return go.Figure().add_annotation(text="無數據", x=0.5, y=0.5, showarrow=False)
+            return go.Figure().add_annotation(
+                text="無數據", x=0.5, y=0.5, showarrow=False
+            )
 
         if data_type == "cost":
             # 成本趨勢圖
@@ -594,10 +724,14 @@ class AnalyticsDashboard:
 
         return go.Figure()
 
-    def _create_secondary_chart(self, data: Dict[str, Any], data_type: str) -> go.Figure:
+    def _create_secondary_chart(
+        self, data: Dict[str, Any], data_type: str
+    ) -> go.Figure:
         """創建次圖表"""
         if not data:
-            return go.Figure().add_annotation(text="無數據", x=0.5, y=0.5, showarrow=False)
+            return go.Figure().add_annotation(
+                text="無數據", x=0.5, y=0.5, showarrow=False
+            )
 
         if data_type == "cost":
             # 供應商分布圖
@@ -626,7 +760,9 @@ class AnalyticsDashboard:
             error_types = data.get("error_types", {})
             if error_types:
                 fig = px.bar(
-                    x=list(error_types.keys()), y=list(error_types.values()), title="錯誤類型分布"
+                    x=list(error_types.keys()),
+                    y=list(error_types.values()),
+                    title="錯誤類型分布",
                 )
                 return fig
 
@@ -647,12 +783,19 @@ class AnalyticsDashboard:
         # 創建表格
         table_header = [html.Thead([html.Tr([html.Th(h) for h in headers])])]
         table_body = [
-            html.Tbody([html.Tr([html.Td(row.get(h, "")) for h in headers]) for row in daily_data])
+            html.Tbody(
+                [
+                    html.Tr([html.Td(row.get(h, "")) for h in headers])
+                    for row in daily_data
+                ]
+            )
         ]
 
         return html.Table(table_header + table_body, className="table")
 
-    def run(self, host: str = "127.0.0.1", port: int = 8050, debug: bool = False):
+    def run(
+        self, host: str = "127.0.0.1", port: int = 8050, debug: bool = False
+    ):
         """運行儀表板"""
         logger.info(f"啟動分析儀表板: http://{host}:{port}")
         self.app.run_server(host=host, port=port, debug=debug)
diff --git a/auto_generate_video_fold6/monitoring/application_monitoring.py b/auto_generate_video_fold6/monitoring/application_monitoring.py
index e20d00f..c4b7518 100644
--- a/auto_generate_video_fold6/monitoring/application_monitoring.py
+++ b/auto_generate_video_fold6/monitoring/application_monitoring.py
@@ -57,7 +57,9 @@ class ApplicationMonitoring:
         # 業務指標
         self.business_metrics = {
             "user_registrations": Counter(
-                "user_registrations_total", "Total user registrations", ["service"]
+                "user_registrations_total",
+                "Total user registrations",
+                ["service"],
             ),
             "video_generations": Counter(
                 "video_generations_total",
@@ -70,7 +72,9 @@ class ApplicationMonitoring:
                 ["request_type", "status", "service"],
             ),
             "user_sessions": Gauge(
-                "active_user_sessions", "Number of active user sessions", ["service"]
+                "active_user_sessions",
+                "Number of active user sessions",
+                ["service"],
             ),
             "processing_queue_size": Gauge(
                 "processing_queue_size",
@@ -112,7 +116,9 @@ class ApplicationMonitoring:
         # 設定指標中介軟體
         if self.metrics_middleware:
             app.middleware("http")(self.metrics_middleware)
-            from .middleware.prometheus_middleware import setup_metrics_endpoint
+            from .middleware.prometheus_middleware import (
+                setup_metrics_endpoint,
+            )
 
             setup_metrics_endpoint(app, self.metrics_middleware)
 
@@ -168,7 +174,11 @@ class ApplicationMonitoring:
                     if not result:
                         overall_status = "not_ready"
                 except Exception as e:
-                    checks[name] = {"status": "error", "error": str(e), "timestamp": time.time()}
+                    checks[name] = {
+                        "status": "error",
+                        "error": str(e),
+                        "timestamp": time.time(),
+                    }
                     overall_status = "not_ready"
 
             response = {
@@ -274,10 +284,14 @@ class ApplicationMonitoring:
                 metric.labels(**labels).observe(value)
 
     @asynccontextmanager
-    async def monitor_operation(self, operation_name: str, labels: Dict[str, str] = None):
+    async def monitor_operation(
+        self, operation_name: str, labels: Dict[str, str] = None
+    ):
         """監控操作的上下文管理器"""
         labels = labels or {}
-        labels.update({"operation": operation_name, "service": self.service_name})
+        labels.update(
+            {"operation": operation_name, "service": self.service_name}
+        )
 
         start_time = time.time()
 
@@ -292,9 +306,15 @@ class ApplicationMonitoring:
 
                 # 記錄成功指標
                 duration = time.time() - start_time
-                self.metrics_middleware.record_ai_request(operation_name, "success", duration)
+                self.metrics_middleware.record_ai_request(
+                    operation_name, "success", duration
+                )
 
-                self.logger.info("Operation completed successfully", duration=duration, **labels)
+                self.logger.info(
+                    "Operation completed successfully",
+                    duration=duration,
+                    **labels,
+                )
 
             except Exception as e:
                 # 記錄錯誤
@@ -361,7 +381,9 @@ def create_monitored_app(
 
     # 創建監控實例
     monitoring = ApplicationMonitoring(
-        service_name=service_name, service_version=service_version, environment=environment
+        service_name=service_name,
+        service_version=service_version,
+        environment=environment,
     )
 
     # 設定應用程式監控
@@ -375,13 +397,17 @@ def create_monitored_app(
 
     # 添加 Redis 健康檢查
     if redis_url:
-        monitoring.add_health_check("redis", monitoring.create_redis_health_check(redis_url))
+        monitoring.add_health_check(
+            "redis", monitoring.create_redis_health_check(redis_url)
+        )
 
     return app, monitoring
 
 
 # 裝飾器
-def monitor_endpoint(operation_name: str = None, labels: Dict[str, str] = None):
+def monitor_endpoint(
+    operation_name: str = None, labels: Dict[str, str] = None
+):
     """端點監控裝飾器"""
 
     def decorator(func):
diff --git a/auto_generate_video_fold6/monitoring/backup/backup_monitor.py b/auto_generate_video_fold6/monitoring/backup/backup_monitor.py
index faf6bd3..261f849 100644
--- a/auto_generate_video_fold6/monitoring/backup/backup_monitor.py
+++ b/auto_generate_video_fold6/monitoring/backup/backup_monitor.py
@@ -15,24 +15,31 @@ logger = logging.getLogger(__name__)
 
 class BackupMonitor:
     """備份監控器"""
-    
+
     def __init__(self, log_dir: str = "/var/log/backups"):
         self.log_dir = Path(log_dir)
         self.log_dir.mkdir(exist_ok=True)
-    
-    def log_backup_start(self, backup_id: str, backup_type: str, source: str) -> None:
+
+    def log_backup_start(
+        self, backup_id: str, backup_type: str, source: str
+    ) -> None:
         """記錄備份開始"""
         log_entry = {
             "timestamp": datetime.now().isoformat(),
             "event": "backup_started",
             "backup_id": backup_id,
             "backup_type": backup_type,
-            "source": source
+            "source": source,
         }
         self._write_log(log_entry)
-    
-    def log_backup_complete(self, backup_id: str, success: bool, 
-                          size_bytes: int = 0, message: str = "") -> None:
+
+    def log_backup_complete(
+        self,
+        backup_id: str,
+        success: bool,
+        size_bytes: int = 0,
+        message: str = "",
+    ) -> None:
         """記錄備份完成"""
         log_entry = {
             "timestamp": datetime.now().isoformat(),
@@ -40,49 +47,53 @@ class BackupMonitor:
             "backup_id": backup_id,
             "success": success,
             "size_bytes": size_bytes,
-            "message": message
+            "message": message,
         }
         self._write_log(log_entry)
-    
-    def log_restore_start(self, restore_id: str, backup_id: str, target: str) -> None:
+
+    def log_restore_start(
+        self, restore_id: str, backup_id: str, target: str
+    ) -> None:
         """記錄恢復開始"""
         log_entry = {
             "timestamp": datetime.now().isoformat(),
             "event": "restore_started",
             "restore_id": restore_id,
             "backup_id": backup_id,
-            "target": target
+            "target": target,
         }
         self._write_log(log_entry)
-    
-    def log_restore_complete(self, restore_id: str, success: bool, message: str = "") -> None:
+
+    def log_restore_complete(
+        self, restore_id: str, success: bool, message: str = ""
+    ) -> None:
         """記錄恢復完成"""
         log_entry = {
             "timestamp": datetime.now().isoformat(),
             "event": "restore_completed",
             "restore_id": restore_id,
             "success": success,
-            "message": message
+            "message": message,
         }
         self._write_log(log_entry)
-    
+
     def _write_log(self, log_entry: Dict) -> None:
         """寫入日誌"""
         today = datetime.now().strftime("%Y-%m-%d")
         log_file = self.log_dir / f"backup_{today}.log"
-        
+
         with open(log_file, "a", encoding="utf-8") as f:
             f.write(json.dumps(log_entry, ensure_ascii=False) + "\n")
-    
+
     def get_recent_backups(self, days: int = 7) -> List[Dict]:
         """獲取最近的備份記錄"""
         records = []
         start_date = datetime.now() - timedelta(days=days)
-        
+
         for i in range(days + 1):
             date = start_date + timedelta(days=i)
             log_file = self.log_dir / f"backup_{date.strftime('%Y-%m-%d')}.log"
-            
+
             if log_file.exists():
                 with open(log_file, "r", encoding="utf-8") as f:
                     for line in f:
@@ -91,27 +102,45 @@ class BackupMonitor:
                             records.append(record)
                         except json.JSONDecodeError:
                             continue
-        
+
         return sorted(records, key=lambda x: x.get("timestamp", ""))
-    
+
     def generate_backup_report(self, days: int = 7) -> Dict:
         """生成備份報告"""
         records = self.get_recent_backups(days)
-        
+
         # 統計資訊
-        backup_starts = [r for r in records if r.get("event") == "backup_started"]
-        backup_completes = [r for r in records if r.get("event") == "backup_completed"]
-        successful_backups = [r for r in backup_completes if r.get("success", False)]
-        failed_backups = [r for r in backup_completes if not r.get("success", True)]
-        
-        restore_starts = [r for r in records if r.get("event") == "restore_started"]
-        restore_completes = [r for r in records if r.get("event") == "restore_completed"]
-        successful_restores = [r for r in restore_completes if r.get("success", False)]
-        failed_restores = [r for r in restore_completes if not r.get("success", True)]
-        
+        backup_starts = [
+            r for r in records if r.get("event") == "backup_started"
+        ]
+        backup_completes = [
+            r for r in records if r.get("event") == "backup_completed"
+        ]
+        successful_backups = [
+            r for r in backup_completes if r.get("success", False)
+        ]
+        failed_backups = [
+            r for r in backup_completes if not r.get("success", True)
+        ]
+
+        restore_starts = [
+            r for r in records if r.get("event") == "restore_started"
+        ]
+        restore_completes = [
+            r for r in records if r.get("event") == "restore_completed"
+        ]
+        successful_restores = [
+            r for r in restore_completes if r.get("success", False)
+        ]
+        failed_restores = [
+            r for r in restore_completes if not r.get("success", True)
+        ]
+
         # 計算總備份大小
-        total_backup_size = sum(r.get("size_bytes", 0) for r in successful_backups)
-        
+        total_backup_size = sum(
+            r.get("size_bytes", 0) for r in successful_backups
+        )
+
         report = {
             "period": f"最近 {days} 天",
             "generated_at": datetime.now().isoformat(),
@@ -120,20 +149,28 @@ class BackupMonitor:
                 "total_completed": len(backup_completes),
                 "successful": len(successful_backups),
                 "failed": len(failed_backups),
-                "success_rate": (len(successful_backups) / len(backup_completes) * 100) if backup_completes else 0,
+                "success_rate": (
+                    len(successful_backups) / len(backup_completes) * 100
+                )
+                if backup_completes
+                else 0,
                 "total_size_bytes": total_backup_size,
-                "total_size_mb": round(total_backup_size / (1024 * 1024), 2)
+                "total_size_mb": round(total_backup_size / (1024 * 1024), 2),
             },
             "restore_statistics": {
                 "total_started": len(restore_starts),
                 "total_completed": len(restore_completes),
                 "successful": len(successful_restores),
                 "failed": len(failed_restores),
-                "success_rate": (len(successful_restores) / len(restore_completes) * 100) if restore_completes else 0
+                "success_rate": (
+                    len(successful_restores) / len(restore_completes) * 100
+                )
+                if restore_completes
+                else 0,
             },
-            "recent_failures": failed_backups + failed_restores
+            "recent_failures": failed_backups + failed_restores,
         }
-        
+
         return report
 
 
@@ -141,4 +178,4 @@ if __name__ == "__main__":
     # 示例用法
     monitor = BackupMonitor()
     report = monitor.generate_backup_report()
-    print(json.dumps(report, indent=2, ensure_ascii=False))
\ No newline at end of file
+    print(json.dumps(report, indent=2, ensure_ascii=False))
diff --git a/auto_generate_video_fold6/monitoring/budget_controller.py b/auto_generate_video_fold6/monitoring/budget_controller.py
index 7e9a7e8..61a6e26 100644
--- a/auto_generate_video_fold6/monitoring/budget_controller.py
+++ b/auto_generate_video_fold6/monitoring/budget_controller.py
@@ -70,9 +70,15 @@ class BudgetController:
 
         # 預設預算規則
         self.default_rules = [
-            BudgetRule(0.8, ActionType.CONTINUE, "預算使用達到 80%，請注意成本控制"),
-            BudgetRule(0.9, ActionType.THROTTLE, "預算使用達到 90%，啟動限流模式"),
-            BudgetRule(0.95, ActionType.PAUSE, "預算使用達到 95%，暫停非必要操作"),
+            BudgetRule(
+                0.8, ActionType.CONTINUE, "預算使用達到 80%，請注意成本控制"
+            ),
+            BudgetRule(
+                0.9, ActionType.THROTTLE, "預算使用達到 90%，啟動限流模式"
+            ),
+            BudgetRule(
+                0.95, ActionType.PAUSE, "預算使用達到 95%，暫停非必要操作"
+            ),
             BudgetRule(1.0, ActionType.STOP, "預算已用完，停止所有付費操作"),
         ]
 
@@ -118,7 +124,9 @@ class BudgetController:
         rules.sort(key=lambda x: x.threshold_percentage)
         return rules if rules else self.default_rules
 
-    async def check_budget_and_decide(self, estimated_cost: float = 0) -> BudgetDecision:
+    async def check_budget_and_decide(
+        self, estimated_cost: float = 0
+    ) -> BudgetDecision:
         """檢查預算並做出決策"""
         try:
             # 獲取當前預算狀態
@@ -128,10 +136,14 @@ class BudgetController:
             current_cost = budget_status["current_cost"]
             budget_limit = budget_status["budget_limit"]
             estimated_total = current_cost + estimated_cost
-            usage_rate = estimated_total / budget_limit if budget_limit > 0 else 0
+            usage_rate = (
+                estimated_total / budget_limit if budget_limit > 0 else 0
+            )
 
             # 根據規則決定行動
-            decision = self._make_decision(usage_rate, budget_status, estimated_cost)
+            decision = self._make_decision(
+                usage_rate, budget_status, estimated_cost
+            )
 
             # 更新統計
             self._update_stats(decision)
@@ -159,7 +171,10 @@ class BudgetController:
             )
 
     def _make_decision(
-        self, usage_rate: float, budget_status: Dict[str, Any], estimated_cost: float
+        self,
+        usage_rate: float,
+        budget_status: Dict[str, Any],
+        estimated_cost: float,
     ) -> BudgetDecision:
         """根據使用率和規則做出決策"""
 
@@ -190,7 +205,9 @@ class BudgetController:
         # 根據規則生成決策
         status = self._determine_status(usage_rate)
         can_continue = self._can_continue(applicable_rule.action, usage_rate)
-        suggested_actions = self._generate_suggestions(status, usage_rate, estimated_cost)
+        suggested_actions = self._generate_suggestions(
+            status, usage_rate, estimated_cost
+        )
 
         return BudgetDecision(
             status=status,
@@ -230,7 +247,9 @@ class BudgetController:
 
         # 檢查配置中的停止設定
         if self.config_manager:
-            stop_on_exceeded = self.config_manager.get("cost_control.stop_on_budget_exceeded", True)
+            stop_on_exceeded = self.config_manager.get(
+                "cost_control.stop_on_budget_exceeded", True
+            )
             if stop_on_exceeded and usage_rate >= 1.0:
                 return False
 
@@ -289,12 +308,16 @@ class BudgetController:
         # 特殊檢查
         if decision.action == ActionType.THROTTLE:
             # 限流模式下的額外檢查
-            if estimated_cost > decision.remaining_budget * 0.1:  # 超過剩餘預算的10%
+            if (
+                estimated_cost > decision.remaining_budget * 0.1
+            ):  # 超過剩餘預算的10%
                 return False, "限流模式下，單次操作成本過高"
 
         return True, decision.message
 
-    async def post_operation_update(self, actual_cost: float, operation_result: bool = True):
+    async def post_operation_update(
+        self, actual_cost: float, operation_result: bool = True
+    ):
         """操作後更新"""
         if actual_cost > 0:
             # 記錄實際成本（這應該由 CostTracker 處理）
@@ -314,7 +337,9 @@ class BudgetController:
         elif decision.action == ActionType.STOP:
             self.daily_stats["stop_events"] += 1
 
-    async def _log_decision(self, decision: BudgetDecision, budget_status: Dict[str, Any]):
+    async def _log_decision(
+        self, decision: BudgetDecision, budget_status: Dict[str, Any]
+    ):
         """記錄預算決策"""
         log_entry = {
             "timestamp": datetime.now().isoformat(),
@@ -322,7 +347,9 @@ class BudgetController:
             "action": decision.action.value,
             "can_continue": decision.can_continue,
             "message": decision.message,
-            "usage_rate": decision.metadata.get("usage_rate", 0) if decision.metadata else 0,
+            "usage_rate": decision.metadata.get("usage_rate", 0)
+            if decision.metadata
+            else 0,
             "current_cost": decision.current_usage,
             "remaining_budget": decision.remaining_budget,
             "budget_limit": budget_status.get("budget_limit", 0),
@@ -365,17 +392,23 @@ class BudgetController:
                 }
                 for rule in self.rules
             ],
-            "last_check": self.last_check_time.isoformat() if self.last_check_time else None,
+            "last_check": self.last_check_time.isoformat()
+            if self.last_check_time
+            else None,
             "generated_at": datetime.now().isoformat(),
         }
 
-    async def adjust_budget_dynamically(self, new_budget: float, reason: str = ""):
+    async def adjust_budget_dynamically(
+        self, new_budget: float, reason: str = ""
+    ):
         """動態調整預算"""
         if not self.config_manager:
             logger.warning("無配置管理器，無法動態調整預算")
             return False
 
-        old_budget = self.config_manager.get("cost_control.daily_budget_usd", 100.0)
+        old_budget = self.config_manager.get(
+            "cost_control.daily_budget_usd", 100.0
+        )
 
         # 更新配置
         self.config_manager.set("cost_control.daily_budget_usd", new_budget)
@@ -414,7 +447,9 @@ class BudgetController:
         """獲取當前狀態"""
         return {
             "status": self.current_status.value,
-            "last_check": self.last_check_time.isoformat() if self.last_check_time else None,
+            "last_check": self.last_check_time.isoformat()
+            if self.last_check_time
+            else None,
             "daily_stats": self.daily_stats,
             "rules_count": len(self.rules),
         }
@@ -439,7 +474,9 @@ async def main():
     print("=== 預算控制器測試 ===")
 
     # 模擬操作前檢查
-    can_proceed, message = await controller.pre_operation_check("video_generation", 2.5)
+    can_proceed, message = await controller.pre_operation_check(
+        "video_generation", 2.5
+    )
     print(f"操作前檢查: {can_proceed}, 訊息: {message}")
 
     # 模擬預算決策
diff --git a/auto_generate_video_fold6/monitoring/business_metrics/business_metrics_collector.py b/auto_generate_video_fold6/monitoring/business_metrics/business_metrics_collector.py
index 1f52ae2..f895bf2 100644
--- a/auto_generate_video_fold6/monitoring/business_metrics/business_metrics_collector.py
+++ b/auto_generate_video_fold6/monitoring/business_metrics/business_metrics_collector.py
@@ -17,6 +17,7 @@ from enum import Enum
 # Prometheus metrics (optional dependency)
 try:
     from prometheus_client import Counter, Histogram, Gauge, Summary, Info
+
     PROMETHEUS_AVAILABLE = True
 except ImportError:
     PROMETHEUS_AVAILABLE = False
@@ -25,16 +26,20 @@ from ..logging.structured_logger import get_logger
 
 logger = get_logger(__name__)
 
+
 class MetricType(Enum):
     """指標類型枚舉"""
+
     COUNTER = "counter"
     GAUGE = "gauge"
     HISTOGRAM = "histogram"
     SUMMARY = "summary"
 
+
 @dataclass
 class BusinessMetricDefinition:
     """業務指標定義"""
+
     name: str
     type: MetricType
     description: str
@@ -42,62 +47,71 @@ class BusinessMetricDefinition:
     unit: str = ""
     business_impact: str = "medium"  # low, medium, high, critical
     sla_target: str = ""
-    
+
     def __post_init__(self):
         # 確保標籤是清單
         if isinstance(self.labels, str):
             self.labels = [self.labels]
 
+
 @dataclass
 class MetricRecord:
     """指標記錄"""
+
     name: str
     value: Union[int, float]
     labels: Dict[str, str] = field(default_factory=dict)
     timestamp: datetime = field(default_factory=datetime.utcnow)
     unit: str = ""
 
+
 class BusinessMetricsCollector:
     """業務指標收集器"""
-    
+
     def __init__(self, metrics_definitions_path: Optional[str] = None):
         self.metrics_definitions: Dict[str, BusinessMetricDefinition] = {}
         self.prometheus_metrics: Dict[str, Any] = {}
-        self.fallback_metrics: Dict[str, deque] = defaultdict(lambda: deque(maxlen=10000))
+        self.fallback_metrics: Dict[str, deque] = defaultdict(
+            lambda: deque(maxlen=10000)
+        )
         self.metrics_lock = threading.Lock()
-        
+
         # 載入指標定義
         if metrics_definitions_path:
             self.load_metrics_definitions(metrics_definitions_path)
         else:
             self._create_default_metrics()
-        
+
         # 初始化 Prometheus 指標
         self._initialize_prometheus_metrics()
-    
+
     def load_metrics_definitions(self, file_path: str):
         """從 JSON 文件載入指標定義"""
         try:
-            with open(file_path, 'r', encoding='utf-8') as f:
+            with open(file_path, "r", encoding="utf-8") as f:
                 definitions_data = json.load(f)
-            
+
             for name, definition in definitions_data.items():
                 self.metrics_definitions[name] = BusinessMetricDefinition(
                     name=name,
-                    type=MetricType(definition['type']),
-                    description=definition['description'],
-                    labels=definition.get('labels', []),
-                    unit=definition.get('unit', ''),
-                    business_impact=definition.get('business_impact', 'medium'),
-                    sla_target=definition.get('sla_target', '')
+                    type=MetricType(definition["type"]),
+                    description=definition["description"],
+                    labels=definition.get("labels", []),
+                    unit=definition.get("unit", ""),
+                    business_impact=definition.get(
+                        "business_impact", "medium"
+                    ),
+                    sla_target=definition.get("sla_target", ""),
                 )
-            
-            logger.info(f"Loaded {len(self.metrics_definitions)} business metrics definitions")
-            
+
+            logger.info(
+                f"Loaded {len(self.metrics_definitions)} business metrics definitions"
+            )
+
         except Exception as e:
             logger.error(f"Failed to load metrics definitions: {e}")
             self._create_default_metrics()
-    
+
     def _create_default_metrics(self):
         """建立預設業務指標定義"""
         default_metrics = {
@@ -108,7 +122,7 @@ class BusinessMetricsCollector:
                 labels=["status", "video_type", "platform", "user_tier"],
                 unit="count",
                 business_impact="high",
-                sla_target="> 1000 per day"
+                sla_target="> 1000 per day",
             ),
             "user_engagement_rate": BusinessMetricDefinition(
                 name="user_engagement_rate",
@@ -117,7 +131,7 @@ class BusinessMetricsCollector:
                 labels=["platform", "content_type", "user_segment"],
                 unit="percentage",
                 business_impact="high",
-                sla_target="> 5%"
+                sla_target="> 5%",
             ),
             "content_generation_time": BusinessMetricDefinition(
                 name="content_generation_time",
@@ -126,7 +140,7 @@ class BusinessMetricsCollector:
                 labels=["content_type", "quality_level"],
                 unit="seconds",
                 business_impact="medium",
-                sla_target="< 300 seconds (95th percentile)"
+                sla_target="< 300 seconds (95th percentile)",
             ),
             "revenue_per_user": BusinessMetricDefinition(
                 name="revenue_per_user",
@@ -135,88 +149,99 @@ class BusinessMetricsCollector:
                 labels=["user_tier", "billing_period"],
                 unit="currency",
                 business_impact="critical",
-                sla_target="> $10 per month"
-            )
+                sla_target="> $10 per month",
+            ),
         }
-        
+
         self.metrics_definitions.update(default_metrics)
-    
+
     def _initialize_prometheus_metrics(self):
         """初始化 Prometheus 指標"""
         if not PROMETHEUS_AVAILABLE:
-            logger.warning("Prometheus client not available, using fallback metrics storage")
+            logger.warning(
+                "Prometheus client not available, using fallback metrics storage"
+            )
             return
-        
+
         for name, definition in self.metrics_definitions.items():
             try:
                 if definition.type == MetricType.COUNTER:
                     self.prometheus_metrics[name] = Counter(
                         name=name,
                         documentation=definition.description,
-                        labelnames=definition.labels
+                        labelnames=definition.labels,
                     )
                 elif definition.type == MetricType.GAUGE:
                     self.prometheus_metrics[name] = Gauge(
                         name=name,
                         documentation=definition.description,
-                        labelnames=definition.labels
+                        labelnames=definition.labels,
                     )
                 elif definition.type == MetricType.HISTOGRAM:
                     self.prometheus_metrics[name] = Histogram(
                         name=name,
                         documentation=definition.description,
-                        labelnames=definition.labels
+                        labelnames=definition.labels,
                     )
                 elif definition.type == MetricType.SUMMARY:
                     self.prometheus_metrics[name] = Summary(
                         name=name,
                         documentation=definition.description,
-                        labelnames=definition.labels
+                        labelnames=definition.labels,
                     )
-                
+
                 logger.debug(f"Initialized Prometheus metric: {name}")
-                
+
             except Exception as e:
-                logger.error(f"Failed to initialize Prometheus metric {name}: {e}")
-    
-    def record_metric(self, name: str, value: Union[int, float], 
-                     labels: Optional[Dict[str, str]] = None):
+                logger.error(
+                    f"Failed to initialize Prometheus metric {name}: {e}"
+                )
+
+    def record_metric(
+        self,
+        name: str,
+        value: Union[int, float],
+        labels: Optional[Dict[str, str]] = None,
+    ):
         """記錄業務指標"""
         if name not in self.metrics_definitions:
             logger.warning(f"Unknown metric: {name}")
             return
-        
+
         if labels is None:
             labels = {}
-        
+
         definition = self.metrics_definitions[name]
-        
+
         # 記錄到 Prometheus
         if PROMETHEUS_AVAILABLE and name in self.prometheus_metrics:
             try:
                 prometheus_metric = self.prometheus_metrics[name]
-                
+
                 if definition.type == MetricType.COUNTER:
                     if labels:
                         prometheus_metric.labels(**labels).inc(value)
                     else:
                         prometheus_metric.inc(value)
-                        
+
                 elif definition.type == MetricType.GAUGE:
                     if labels:
                         prometheus_metric.labels(**labels).set(value)
                     else:
                         prometheus_metric.set(value)
-                        
-                elif definition.type in [MetricType.HISTOGRAM, MetricType.SUMMARY]:
+
+                elif definition.type in [
+                    MetricType.HISTOGRAM,
+                    MetricType.SUMMARY,
+                ]:
                     if labels:
                         prometheus_metric.labels(**labels).observe(value)
                     else:
                         prometheus_metric.observe(value)
-                        
+
             except Exception as e:
                 logger.error(f"Failed to record Prometheus metric {name}: {e}")
-        
+
         # 後備儲存
         with self.metrics_lock:
             record = MetricRecord(
@@ -224,11 +249,11 @@ class BusinessMetricsCollector:
                 value=value,
                 labels=labels,
                 timestamp=datetime.utcnow(),
-                unit=definition.unit
+                unit=definition.unit,
             )
-            
+
             self.fallback_metrics[name].append(record)
-        
+
         # 記錄日誌
         logger.info(
             f"Business metric recorded: {name} = {value}",
@@ -236,44 +261,58 @@ class BusinessMetricsCollector:
             metric_value=value,
             metric_labels=labels,
             business_impact=definition.business_impact,
-            sla_target=definition.sla_target
+            sla_target=definition.sla_target,
         )
-    
-    def increment_counter(self, name: str, amount: Union[int, float] = 1, 
-                         labels: Optional[Dict[str, str]] = None):
+
+    def increment_counter(
+        self,
+        name: str,
+        amount: Union[int, float] = 1,
+        labels: Optional[Dict[str, str]] = None,
+    ):
         """增加計數器指標"""
         self.record_metric(name, amount, labels)
-    
-    def set_gauge(self, name: str, value: Union[int, float], 
-                  labels: Optional[Dict[str, str]] = None):
+
+    def set_gauge(
+        self,
+        name: str,
+        value: Union[int, float],
+        labels: Optional[Dict[str, str]] = None,
+    ):
         """設定儀表指標"""
         self.record_metric(name, value, labels)
-    
-    def observe_histogram(self, name: str, value: Union[int, float], 
-                         labels: Optional[Dict[str, str]] = None):
+
+    def observe_histogram(
+        self,
+        name: str,
+        value: Union[int, float],
+        labels: Optional[Dict[str, str]] = None,
+    ):
         """觀察直方圖指標"""
         self.record_metric(name, value, labels)
-    
-    def get_metric_summary(self, name: str, 
-                          time_window: timedelta = timedelta(hours=1)) -> Dict[str, Any]:
+
+    def get_metric_summary(
+        self, name: str, time_window: timedelta = timedelta(hours=1)
+    ) -> Dict[str, Any]:
         """獲取指標摘要"""
         if name not in self.metrics_definitions:
             return {}
-        
+
         cutoff_time = datetime.utcnow() - time_window
-        
+
         with self.metrics_lock:
             records = [
-                record for record in self.fallback_metrics[name]
+                record
+                for record in self.fallback_metrics[name]
                 if record.timestamp > cutoff_time
             ]
-        
+
         if not records:
             return {"name": name, "records_count": 0}
-        
+
         values = [record.value for record in records]
         definition = self.metrics_definitions[name]
-        
+
         summary = {
             "name": name,
             "type": definition.type.value,
@@ -283,23 +322,25 @@ class BusinessMetricsCollector:
             "records_count": len(records),
             "time_window_hours": time_window.total_seconds() / 3600,
             "latest_value": values[-1] if values else None,
-            "unit": definition.unit
+            "unit": definition.unit,
         }
-        
+
         if definition.type == MetricType.COUNTER:
             summary["total"] = sum(values)
-            summary["rate_per_hour"] = sum(values) / (time_window.total_seconds() / 3600)
-        
+            summary["rate_per_hour"] = sum(values) / (
+                time_window.total_seconds() / 3600
+            )
+
         elif definition.type == MetricType.GAUGE:
             summary["current_value"] = values[-1] if values else None
             summary["min_value"] = min(values)
             summary["max_value"] = max(values)
             summary["avg_value"] = sum(values) / len(values)
-        
+
         elif definition.type in [MetricType.HISTOGRAM, MetricType.SUMMARY]:
             sorted_values = sorted(values)
             count = len(sorted_values)
-            
+
             summary["min"] = sorted_values[0]
             summary["max"] = sorted_values[-1]
             summary["avg"] = sum(values) / count
@@ -307,53 +348,55 @@ class BusinessMetricsCollector:
             summary["p90"] = sorted_values[int(count * 0.9)]
             summary["p95"] = sorted_values[int(count * 0.95)]
             summary["p99"] = sorted_values[int(count * 0.99)]
-        
+
         return summary
-    
-    def get_all_metrics_summary(self, 
-                               time_window: timedelta = timedelta(hours=1)) -> Dict[str, Any]:
+
+    def get_all_metrics_summary(
+        self, time_window: timedelta = timedelta(hours=1)
+    ) -> Dict[str, Any]:
         """獲取所有指標摘要"""
         summaries = {}
-        
+
         for name in self.metrics_definitions.keys():
             summaries[name] = self.get_metric_summary(name, time_window)
-        
+
         return {
             "timestamp": datetime.utcnow().isoformat(),
             "time_window_hours": time_window.total_seconds() / 3600,
             "metrics": summaries,
-            "total_metrics": len(summaries)
+            "total_metrics": len(summaries),
         }
-    
+
     def collect_metrics(self) -> Dict[str, Any]:
         """收集所有業務指標"""
         return self.get_all_metrics_summary()
-    
+
     def get_critical_metrics_status(self) -> Dict[str, Any]:
         """獲取關鍵指標狀態"""
         critical_metrics = {
-            name: definition for name, definition in self.metrics_definitions.items()
+            name: definition
+            for name, definition in self.metrics_definitions.items()
             if definition.business_impact in ["high", "critical"]
         }
-        
+
         status = {
             "timestamp": datetime.utcnow().isoformat(),
             "critical_metrics_count": len(critical_metrics),
-            "metrics_status": {}
+            "metrics_status": {},
         }
-        
+
         for name, definition in critical_metrics.items():
             summary = self.get_metric_summary(name, timedelta(hours=1))
-            
+
             metric_status = {
                 "name": name,
                 "business_impact": definition.business_impact,
                 "sla_target": definition.sla_target,
                 "records_count": summary.get("records_count", 0),
                 "latest_value": summary.get("latest_value"),
-                "status": "unknown"
+                "status": "unknown",
             }
-            
+
             # 簡單的 SLA 狀態判斷（可以根據實際需求擴展）
             if summary.get("records_count", 0) > 0:
                 if definition.business_impact == "critical":
@@ -362,18 +405,22 @@ class BusinessMetricsCollector:
                     metric_status["status"] = "active"
             else:
                 metric_status["status"] = "no_data"
-            
+
             status["metrics_status"][name] = metric_status
-        
+
         return status
 
+
 # 全域業務指標收集器實例
 business_metrics = BusinessMetricsCollector(
     "/data/data/com.termux/files/home/myProject/auto_generate_video_fold6/monitoring/business_metrics/metrics_definition.json"
 )
 
+
 # 便捷函數
-def record_video_generation(status: str, video_type: str, platform: str, user_tier: str = "free"):
+def record_video_generation(
+    status: str, video_type: str, platform: str, user_tier: str = "free"
+):
     """記錄影片生成指標"""
     business_metrics.increment_counter(
         "video_generation_count",
@@ -381,12 +428,17 @@ def record_video_generation(status: str, video_type: str, platform: str, user_ti
             "status": status,
             "video_type": video_type,
             "platform": platform,
-            "user_tier": user_tier
-        }
+            "user_tier": user_tier,
+        },
     )
 
-def record_user_engagement(platform: str, engagement_rate: float, 
-                          content_type: str = "video", user_segment: str = "general"):
+
+def record_user_engagement(
+    platform: str,
+    engagement_rate: float,
+    content_type: str = "video",
+    user_segment: str = "general",
+):
     """記錄用戶參與度"""
     business_metrics.set_gauge(
         "user_engagement_rate",
@@ -394,85 +446,92 @@ def record_user_engagement(platform: str, engagement_rate: float,
         labels={
             "platform": platform,
             "content_type": content_type,
-            "user_segment": user_segment
-        }
+            "user_segment": user_segment,
+        },
     )
 
-def record_content_generation_time(duration_seconds: float, content_type: str, 
-                                  quality_level: str = "standard"):
+
+def record_content_generation_time(
+    duration_seconds: float, content_type: str, quality_level: str = "standard"
+):
     """記錄內容生成時間"""
     business_metrics.observe_histogram(
         "content_generation_time",
         duration_seconds,
-        labels={
-            "content_type": content_type,
-            "quality_level": quality_level
-        }
+        labels={"content_type": content_type, "quality_level": quality_level},
     )
 
-def record_revenue_per_user(revenue: float, user_tier: str, billing_period: str = "monthly"):
+
+def record_revenue_per_user(
+    revenue: float, user_tier: str, billing_period: str = "monthly"
+):
     """記錄每用戶收入"""
     business_metrics.set_gauge(
         "revenue_per_user",
         revenue,
-        labels={
-            "user_tier": user_tier,
-            "billing_period": billing_period
-        }
+        labels={"user_tier": user_tier, "billing_period": billing_period},
     )
 
+
 async def collect_system_metrics():
     """收集系統層級的業務指標"""
     try:
         # 這個函數可以定期執行以收集系統指標
         # 例如：用戶數量、存儲使用量、處理任務數等
-        
+
         logger.info("Collecting system-level business metrics")
-        
+
         # 示例：記錄系統可用性（這裡使用模擬數據）
         import random
+
         system_availability = random.uniform(99.0, 100.0)
         business_metrics.set_gauge(
             "system_availability",
             system_availability,
-            labels={"service": "overall", "region": "default"}
+            labels={"service": "overall", "region": "default"},
         )
-        
+
     except Exception as e:
         logger.error(f"Failed to collect system metrics: {e}")
 
+
 class MetricsReporter:
     """指標報告器"""
-    
+
     def __init__(self, collector: BusinessMetricsCollector):
         self.collector = collector
         self.logger = get_logger("metrics_reporter")
-    
+
     async def generate_daily_report(self) -> Dict[str, Any]:
         """生成每日指標報告"""
         report = {
             "report_type": "daily",
             "timestamp": datetime.utcnow().isoformat(),
             "date": datetime.utcnow().date().isoformat(),
-            "summary": self.collector.get_all_metrics_summary(timedelta(days=1)),
-            "critical_status": self.collector.get_critical_metrics_status()
+            "summary": self.collector.get_all_metrics_summary(
+                timedelta(days=1)
+            ),
+            "critical_status": self.collector.get_critical_metrics_status(),
         }
-        
+
         self.logger.info("Generated daily metrics report")
         return report
-    
+
     async def generate_hourly_report(self) -> Dict[str, Any]:
         """生成每小時指標報告"""
         report = {
             "report_type": "hourly",
             "timestamp": datetime.utcnow().isoformat(),
             "hour": datetime.utcnow().strftime("%Y-%m-%d %H:00"),
-            "summary": self.collector.get_all_metrics_summary(timedelta(hours=1)),
-            "critical_status": self.collector.get_critical_metrics_status()
+            "summary": self.collector.get_all_metrics_summary(
+                timedelta(hours=1)
+            ),
+            "critical_status": self.collector.get_critical_metrics_status(),
         }
-        
+
         self.logger.info("Generated hourly metrics report")
         return report
 
+
 # 全域指標報告器
-metrics_reporter = MetricsReporter(business_metrics)
\ No newline at end of file
+metrics_reporter = MetricsReporter(business_metrics)
diff --git a/auto_generate_video_fold6/monitoring/business_metrics/metrics_collector.py b/auto_generate_video_fold6/monitoring/business_metrics/metrics_collector.py
index c68966b..8195259 100644
--- a/auto_generate_video_fold6/monitoring/business_metrics/metrics_collector.py
+++ b/auto_generate_video_fold6/monitoring/business_metrics/metrics_collector.py
@@ -17,6 +17,7 @@ from enum import Enum
 # Prometheus metrics (optional dependency)
 try:
     from prometheus_client import Counter, Histogram, Gauge, Summary, Info
+
     PROMETHEUS_AVAILABLE = True
 except ImportError:
     PROMETHEUS_AVAILABLE = False
@@ -25,16 +26,20 @@ from ..logging.structured_logger import get_logger
 
 logger = get_logger(__name__)
 
+
 class MetricType(Enum):
     """指標類型枚舉"""
+
     COUNTER = "counter"
     GAUGE = "gauge"
     HISTOGRAM = "histogram"
     SUMMARY = "summary"
 
+
 @dataclass
 class BusinessMetricDefinition:
     """業務指標定義"""
+
     name: str
     type: MetricType
     description: str
@@ -42,62 +47,71 @@ class BusinessMetricDefinition:
     unit: str = ""
     business_impact: str = "medium"  # low, medium, high, critical
     sla_target: str = ""
-    
+
     def __post_init__(self):
         # 確保標籤是清單
         if isinstance(self.labels, str):
             self.labels = [self.labels]
 
+
 @dataclass
 class MetricRecord:
     """指標記錄"""
+
     name: str
     value: Union[int, float]
     labels: Dict[str, str] = field(default_factory=dict)
     timestamp: datetime = field(default_factory=datetime.utcnow)
     unit: str = ""
 
+
 class BusinessMetricsCollector:
     """業務指標收集器"""
-    
+
     def __init__(self, metrics_definitions_path: Optional[str] = None):
         self.metrics_definitions: Dict[str, BusinessMetricDefinition] = {}
         self.prometheus_metrics: Dict[str, Any] = {}
-        self.fallback_metrics: Dict[str, deque] = defaultdict(lambda: deque(maxlen=10000))
+        self.fallback_metrics: Dict[str, deque] = defaultdict(
+            lambda: deque(maxlen=10000)
+        )
         self.metrics_lock = threading.Lock()
-        
+
         # 載入指標定義
         if metrics_definitions_path:
             self.load_metrics_definitions(metrics_definitions_path)
         else:
             self._create_default_metrics()
-        
+
         # 初始化 Prometheus 指標
         self._initialize_prometheus_metrics()
-    
+
     def load_metrics_definitions(self, file_path: str):
         """從 JSON 文件載入指標定義"""
         try:
-            with open(file_path, 'r', encoding='utf-8') as f:
+            with open(file_path, "r", encoding="utf-8") as f:
                 definitions_data = json.load(f)
-            
+
             for name, definition in definitions_data.items():
                 self.metrics_definitions[name] = BusinessMetricDefinition(
                     name=name,
-                    type=MetricType(definition['type']),
-                    description=definition['description'],
-                    labels=definition.get('labels', []),
-                    unit=definition.get('unit', ''),
-                    business_impact=definition.get('business_impact', 'medium'),
-                    sla_target=definition.get('sla_target', '')
+                    type=MetricType(definition["type"]),
+                    description=definition["description"],
+                    labels=definition.get("labels", []),
+                    unit=definition.get("unit", ""),
+                    business_impact=definition.get(
+                        "business_impact", "medium"
+                    ),
+                    sla_target=definition.get("sla_target", ""),
                 )
-            
-            logger.info(f"Loaded {len(self.metrics_definitions)} business metrics definitions")
-            
+
+            logger.info(
+                f"Loaded {len(self.metrics_definitions)} business metrics definitions"
+            )
+
         except Exception as e:
             logger.error(f"Failed to load metrics definitions: {e}")
             self._create_default_metrics()
-    
+
     def _create_default_metrics(self):
         """建立預設業務指標定義"""
         default_metrics = {
@@ -108,7 +122,7 @@ class BusinessMetricsCollector:
                 labels=["status", "video_type", "platform", "user_tier"],
                 unit="count",
                 business_impact="high",
-                sla_target="> 1000 per day"
+                sla_target="> 1000 per day",
             ),
             "user_engagement_rate": BusinessMetricDefinition(
                 name="user_engagement_rate",
@@ -117,7 +131,7 @@ class BusinessMetricsCollector:
                 labels=["platform", "content_type", "user_segment"],
                 unit="percentage",
                 business_impact="high",
-                sla_target="> 5%"
+                sla_target="> 5%",
             ),
             "content_generation_time": BusinessMetricDefinition(
                 name="content_generation_time",
@@ -126,7 +140,7 @@ class BusinessMetricsCollector:
                 labels=["content_type", "quality_level"],
                 unit="seconds",
                 business_impact="medium",
-                sla_target="< 300 seconds (95th percentile)"
+                sla_target="< 300 seconds (95th percentile)",
             ),
             "revenue_per_user": BusinessMetricDefinition(
                 name="revenue_per_user",
@@ -135,88 +149,99 @@ class BusinessMetricsCollector:
                 labels=["user_tier", "billing_period"],
                 unit="currency",
                 business_impact="critical",
-                sla_target="> $10 per month"
-            )
+                sla_target="> $10 per month",
+            ),
         }
-        
+
         self.metrics_definitions.update(default_metrics)
-    
+
     def _initialize_prometheus_metrics(self):
         """初始化 Prometheus 指標"""
         if not PROMETHEUS_AVAILABLE:
-            logger.warning("Prometheus client not available, using fallback metrics storage")
+            logger.warning(
+                "Prometheus client not available, using fallback metrics storage"
+            )
             return
-        
+
         for name, definition in self.metrics_definitions.items():
             try:
                 if definition.type == MetricType.COUNTER:
                     self.prometheus_metrics[name] = Counter(
                         name=name,
                         documentation=definition.description,
-                        labelnames=definition.labels
+                        labelnames=definition.labels,
                     )
                 elif definition.type == MetricType.GAUGE:
                     self.prometheus_metrics[name] = Gauge(
                         name=name,
                         documentation=definition.description,
-                        labelnames=definition.labels
+                        labelnames=definition.labels,
                     )
                 elif definition.type == MetricType.HISTOGRAM:
                     self.prometheus_metrics[name] = Histogram(
                         name=name,
                         documentation=definition.description,
-                        labelnames=definition.labels
+                        labelnames=definition.labels,
                     )
                 elif definition.type == MetricType.SUMMARY:
                     self.prometheus_metrics[name] = Summary(
                         name=name,
                         documentation=definition.description,
-                        labelnames=definition.labels
+                        labelnames=definition.labels,
                     )
-                
+
                 logger.debug(f"Initialized Prometheus metric: {name}")
-                
+
             except Exception as e:
-                logger.error(f"Failed to initialize Prometheus metric {name}: {e}")
-    
-    def record_metric(self, name: str, value: Union[int, float], 
-                     labels: Optional[Dict[str, str]] = None):
+                logger.error(
+                    f"Failed to initialize Prometheus metric {name}: {e}"
+                )
+
+    def record_metric(
+        self,
+        name: str,
+        value: Union[int, float],
+        labels: Optional[Dict[str, str]] = None,
+    ):
         """記錄業務指標"""
         if name not in self.metrics_definitions:
             logger.warning(f"Unknown metric: {name}")
             return
-        
+
         if labels is None:
             labels = {}
-        
+
         definition = self.metrics_definitions[name]
-        
+
         # 記錄到 Prometheus
         if PROMETHEUS_AVAILABLE and name in self.prometheus_metrics:
             try:
                 prometheus_metric = self.prometheus_metrics[name]
-                
+
                 if definition.type == MetricType.COUNTER:
                     if labels:
                         prometheus_metric.labels(**labels).inc(value)
                     else:
                         prometheus_metric.inc(value)
-                        
+
                 elif definition.type == MetricType.GAUGE:
                     if labels:
                         prometheus_metric.labels(**labels).set(value)
                     else:
                         prometheus_metric.set(value)
-                        
-                elif definition.type in [MetricType.HISTOGRAM, MetricType.SUMMARY]:
+
+                elif definition.type in [
+                    MetricType.HISTOGRAM,
+                    MetricType.SUMMARY,
+                ]:
                     if labels:
                         prometheus_metric.labels(**labels).observe(value)
                     else:
                         prometheus_metric.observe(value)
-                        
+
             except Exception as e:
                 logger.error(f"Failed to record Prometheus metric {name}: {e}")
-        
+
         # 後備儲存
         with self.metrics_lock:
             record = MetricRecord(
@@ -224,11 +249,11 @@ class BusinessMetricsCollector:
                 value=value,
                 labels=labels,
                 timestamp=datetime.utcnow(),
-                unit=definition.unit
+                unit=definition.unit,
             )
-            
+
             self.fallback_metrics[name].append(record)
-        
+
         # 記錄日誌
         logger.info(
             f"Business metric recorded: {name} = {value}",
@@ -236,44 +261,58 @@ class BusinessMetricsCollector:
             metric_value=value,
             metric_labels=labels,
             business_impact=definition.business_impact,
-            sla_target=definition.sla_target
+            sla_target=definition.sla_target,
         )
-    
-    def increment_counter(self, name: str, amount: Union[int, float] = 1, 
-                         labels: Optional[Dict[str, str]] = None):
+
+    def increment_counter(
+        self,
+        name: str,
+        amount: Union[int, float] = 1,
+        labels: Optional[Dict[str, str]] = None,
+    ):
         """增加計數器指標"""
         self.record_metric(name, amount, labels)
-    
-    def set_gauge(self, name: str, value: Union[int, float], 
-                  labels: Optional[Dict[str, str]] = None):
+
+    def set_gauge(
+        self,
+        name: str,
+        value: Union[int, float],
+        labels: Optional[Dict[str, str]] = None,
+    ):
         """設定儀表指標"""
         self.record_metric(name, value, labels)
-    
-    def observe_histogram(self, name: str, value: Union[int, float], 
-                         labels: Optional[Dict[str, str]] = None):
+
+    def observe_histogram(
+        self,
+        name: str,
+        value: Union[int, float],
+        labels: Optional[Dict[str, str]] = None,
+    ):
         """觀察直方圖指標"""
         self.record_metric(name, value, labels)
-    
-    def get_metric_summary(self, name: str, 
-                          time_window: timedelta = timedelta(hours=1)) -> Dict[str, Any]:
+
+    def get_metric_summary(
+        self, name: str, time_window: timedelta = timedelta(hours=1)
+    ) -> Dict[str, Any]:
         """獲取指標摘要"""
         if name not in self.metrics_definitions:
             return {}
-        
+
         cutoff_time = datetime.utcnow() - time_window
-        
+
         with self.metrics_lock:
             records = [
-                record for record in self.fallback_metrics[name]
+                record
+                for record in self.fallback_metrics[name]
                 if record.timestamp > cutoff_time
             ]
-        
+
         if not records:
             return {"name": name, "records_count": 0}
-        
+
         values = [record.value for record in records]
         definition = self.metrics_definitions[name]
-        
+
         summary = {
             "name": name,
             "type": definition.type.value,
@@ -283,23 +322,25 @@ class BusinessMetricsCollector:
             "records_count": len(records),
             "time_window_hours": time_window.total_seconds() / 3600,
             "latest_value": values[-1] if values else None,
-            "unit": definition.unit
+            "unit": definition.unit,
         }
-        
+
         if definition.type == MetricType.COUNTER:
             summary["total"] = sum(values)
-            summary["rate_per_hour"] = sum(values) / (time_window.total_seconds() / 3600)
-        
+            summary["rate_per_hour"] = sum(values) / (
+                time_window.total_seconds() / 3600
+            )
+
         elif definition.type == MetricType.GAUGE:
             summary["current_value"] = values[-1] if values else None
             summary["min_value"] = min(values)
             summary["max_value"] = max(values)
             summary["avg_value"] = sum(values) / len(values)
-        
+
         elif definition.type in [MetricType.HISTOGRAM, MetricType.SUMMARY]:
             sorted_values = sorted(values)
             count = len(sorted_values)
-            
+
             summary["min"] = sorted_values[0]
             summary["max"] = sorted_values[-1]
             summary["avg"] = sum(values) / count
@@ -307,49 +348,51 @@ class BusinessMetricsCollector:
             summary["p90"] = sorted_values[int(count * 0.9)]
             summary["p95"] = sorted_values[int(count * 0.95)]
             summary["p99"] = sorted_values[int(count * 0.99)]
-        
+
         return summary
-    
-    def get_all_metrics_summary(self, 
-                               time_window: timedelta = timedelta(hours=1)) -> Dict[str, Any]:
+
+    def get_all_metrics_summary(
+        self, time_window: timedelta = timedelta(hours=1)
+    ) -> Dict[str, Any]:
         """獲取所有指標摘要"""
         summaries = {}
-        
+
         for name in self.metrics_definitions.keys():
             summaries[name] = self.get_metric_summary(name, time_window)
-        
+
         return {
             "timestamp": datetime.utcnow().isoformat(),
             "time_window_hours": time_window.total_seconds() / 3600,
             "metrics": summaries,
-            "total_metrics": len(summaries)
+            "total_metrics": len(summaries),
         }
-    
+
     def get_critical_metrics_status(self) -> Dict[str, Any]:
         """獲取關鍵指標狀態"""
         critical_metrics = {
-            name: definition for name, definition in self.metrics_definitions.items()
+            name: definition
+            for name, definition in self.metrics_definitions.items()
             if definition.business_impact in ["high", "critical"]
         }
-        
+
         status = {
             "timestamp": datetime.utcnow().isoformat(),
             "critical_metrics_count": len(critical_metrics),
-            "metrics_status": {}
+            "metrics_status": {},
         }
-        
+
         for name, definition in critical_metrics.items():
             summary = self.get_metric_summary(name, timedelta(hours=1))
-            
+
             metric_status = {
                 "name": name,
                 "business_impact": definition.business_impact,
                 "sla_target": definition.sla_target,
                 "records_count": summary.get("records_count", 0),
                 "latest_value": summary.get("latest_value"),
-                "status": "unknown"
+                "status": "unknown",
             }
-            
+
             # 簡單的 SLA 狀態判斷（可以根據實際需求擴展）
             if summary.get("records_count", 0) > 0:
                 if definition.business_impact == "critical":
@@ -358,18 +401,22 @@ class BusinessMetricsCollector:
                     metric_status["status"] = "active"
             else:
                 metric_status["status"] = "no_data"
-            
+
             status["metrics_status"][name] = metric_status
-        
+
         return status
 
+
 # 全域業務指標收集器實例
 business_metrics = BusinessMetricsCollector(
     "/data/data/com.termux/files/home/myProject/auto_generate_video_fold6/monitoring/business_metrics/metrics_definition.json"
 )
 
+
 # 便捷函數
-def record_video_generation(status: str, video_type: str, platform: str, user_tier: str = "free"):
+def record_video_generation(
+    status: str, video_type: str, platform: str, user_tier: str = "free"
+):
     """記錄影片生成指標"""
     business_metrics.increment_counter(
         "video_generation_count",
@@ -377,12 +424,17 @@ def record_video_generation(status: str, video_type: str, platform: str, user_ti
             "status": status,
             "video_type": video_type,
             "platform": platform,
-            "user_tier": user_tier
-        }
+            "user_tier": user_tier,
+        },
     )
 
-def record_user_engagement(platform: str, engagement_rate: float, 
-                          content_type: str = "video", user_segment: str = "general"):
+
+def record_user_engagement(
+    platform: str,
+    engagement_rate: float,
+    content_type: str = "video",
+    user_segment: str = "general",
+):
     """記錄用戶參與度"""
     business_metrics.set_gauge(
         "user_engagement_rate",
@@ -390,85 +442,92 @@ def record_user_engagement(platform: str, engagement_rate: float,
         labels={
             "platform": platform,
             "content_type": content_type,
-            "user_segment": user_segment
-        }
+            "user_segment": user_segment,
+        },
     )
 
-def record_content_generation_time(duration_seconds: float, content_type: str, 
-                                  quality_level: str = "standard"):
+
+def record_content_generation_time(
+    duration_seconds: float, content_type: str, quality_level: str = "standard"
+):
     """記錄內容生成時間"""
     business_metrics.observe_histogram(
         "content_generation_time",
         duration_seconds,
-        labels={
-            "content_type": content_type,
-            "quality_level": quality_level
-        }
+        labels={"content_type": content_type, "quality_level": quality_level},
     )
 
-def record_revenue_per_user(revenue: float, user_tier: str, billing_period: str = "monthly"):
+
+def record_revenue_per_user(
+    revenue: float, user_tier: str, billing_period: str = "monthly"
+):
     """記錄每用戶收入"""
     business_metrics.set_gauge(
         "revenue_per_user",
         revenue,
-        labels={
-            "user_tier": user_tier,
-            "billing_period": billing_period
-        }
+        labels={"user_tier": user_tier, "billing_period": billing_period},
     )
 
+
 async def collect_system_metrics():
     """收集系統層級的業務指標"""
     try:
         # 這個函數可以定期執行以收集系統指標
         # 例如：用戶數量、存儲使用量、處理任務數等
-        
+
         logger.info("Collecting system-level business metrics")
-        
+
         # 示例：記錄系統可用性（這裡使用模擬數據）
         import random
+
         system_availability = random.uniform(99.0, 100.0)
         business_metrics.set_gauge(
             "system_availability",
             system_availability,
-            labels={"service": "overall", "region": "default"}
+            labels={"service": "overall", "region": "default"},
         )
-        
+
     except Exception as e:
         logger.error(f"Failed to collect system metrics: {e}")
 
+
 class MetricsReporter:
     """指標報告器"""
-    
+
     def __init__(self, collector: BusinessMetricsCollector):
         self.collector = collector
         self.logger = get_logger("metrics_reporter")
-    
+
     async def generate_daily_report(self) -> Dict[str, Any]:
         """生成每日指標報告"""
         report = {
             "report_type": "daily",
             "timestamp": datetime.utcnow().isoformat(),
             "date": datetime.utcnow().date().isoformat(),
-            "summary": self.collector.get_all_metrics_summary(timedelta(days=1)),
-            "critical_status": self.collector.get_critical_metrics_status()
+            "summary": self.collector.get_all_metrics_summary(
+                timedelta(days=1)
+            ),
+            "critical_status": self.collector.get_critical_metrics_status(),
         }
-        
+
         self.logger.info("Generated daily metrics report")
         return report
-    
+
     async def generate_hourly_report(self) -> Dict[str, Any]:
         """生成每小時指標報告"""
         report = {
             "report_type": "hourly",
             "timestamp": datetime.utcnow().isoformat(),
             "hour": datetime.utcnow().strftime("%Y-%m-%d %H:00"),
-            "summary": self.collector.get_all_metrics_summary(timedelta(hours=1)),
-            "critical_status": self.collector.get_critical_metrics_status()
+            "summary": self.collector.get_all_metrics_summary(
+                timedelta(hours=1)
+            ),
+            "critical_status": self.collector.get_critical_metrics_status(),
         }
-        
+
         self.logger.info("Generated hourly metrics report")
         return report
 
+
 # 全域指標報告器
-metrics_reporter = MetricsReporter(business_metrics)
\ No newline at end of file
+metrics_reporter = MetricsReporter(business_metrics)
diff --git a/auto_generate_video_fold6/monitoring/cost_tracker.py b/auto_generate_video_fold6/monitoring/cost_tracker.py
index cc4f8c7..f125eed 100644
--- a/auto_generate_video_fold6/monitoring/cost_tracker.py
+++ b/auto_generate_video_fold6/monitoring/cost_tracker.py
@@ -80,22 +80,42 @@ class CostTracker:
         self.cost_rates = {
             ProviderType.OPENAI.value: {
                 "gpt-4": {"input_per_1k": 0.03, "output_per_1k": 0.06},
-                "gpt-3.5-turbo": {"input_per_1k": 0.0015, "output_per_1k": 0.002},
+                "gpt-3.5-turbo": {
+                    "input_per_1k": 0.0015,
+                    "output_per_1k": 0.002,
+                },
                 "gpt-4-turbo": {"input_per_1k": 0.01, "output_per_1k": 0.03},
             },
             ProviderType.STABILITY_AI.value: {
                 "stable-diffusion-xl": {"per_image": 0.04},
                 "stable-diffusion-3": {"per_image": 0.065},
             },
-            ProviderType.ELEVENLABS.value: {"voice_synthesis": {"per_character": 0.00003}},
+            ProviderType.ELEVENLABS.value: {
+                "voice_synthesis": {"per_character": 0.00003}
+            },
             ProviderType.ANTHROPIC.value: {
-                "claude-3-opus": {"input_per_1k": 0.015, "output_per_1k": 0.075},
-                "claude-3-sonnet": {"input_per_1k": 0.003, "output_per_1k": 0.015},
+                "claude-3-opus": {
+                    "input_per_1k": 0.015,
+                    "output_per_1k": 0.075,
+                },
+                "claude-3-sonnet": {
+                    "input_per_1k": 0.003,
+                    "output_per_1k": 0.015,
+                },
             },
             ProviderType.GEMINI.value: {
-                "gemini-pro": {"input_per_1k": 0.0005, "output_per_1k": 0.0015},
-                "gemini-1.5-pro": {"input_per_1k": 0.0035, "output_per_1k": 0.0105},
-                "gemini-1.5-flash": {"input_per_1k": 0.000075, "output_per_1k": 0.0003},
+                "gemini-pro": {
+                    "input_per_1k": 0.0005,
+                    "output_per_1k": 0.0015,
+                },
+                "gemini-1.5-pro": {
+                    "input_per_1k": 0.0035,
+                    "output_per_1k": 0.0105,
+                },
+                "gemini-1.5-flash": {
+                    "input_per_1k": 0.000075,
+                    "output_per_1k": 0.0003,
+                },
             },
             ProviderType.SUNO.value: {
                 "chirp-v3": {"per_minute": 0.5},  # 估算價格
@@ -179,7 +199,12 @@ class CostTracker:
 
         # 計算成本
         cost = self._calculate_cost(
-            provider, model, operation_type, tokens_used, characters_used, images_generated
+            provider,
+            model,
+            operation_type,
+            tokens_used,
+            characters_used,
+            images_generated,
         )
 
         # 建立記錄
@@ -190,7 +215,8 @@ class CostTracker:
             operation_type=operation_type,
             tokens_used=tokens_used,
             cost_usd=cost,
-            request_id=request_id or f"{provider}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
+            request_id=request_id
+            or f"{provider}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
             success=success,
             metadata=metadata,
         )
@@ -233,8 +259,12 @@ class CostTracker:
         # 根據操作類型計算成本
         if operation_type == "text_generation":
             # 假設輸入輸出比例 1:1
-            input_cost = (tokens_used / 2 / 1000) * model_rates.get("input_per_1k", 0)
-            output_cost = (tokens_used / 2 / 1000) * model_rates.get("output_per_1k", 0)
+            input_cost = (tokens_used / 2 / 1000) * model_rates.get(
+                "input_per_1k", 0
+            )
+            output_cost = (tokens_used / 2 / 1000) * model_rates.get(
+                "output_per_1k", 0
+            )
             return input_cost + output_cost
 
         elif operation_type == "image_generation":
@@ -245,7 +275,9 @@ class CostTracker:
 
         elif operation_type == "music_generation":
             # Suno 音樂生成成本按分鐘計算
-            duration_minutes = tokens_used / 60.0 if tokens_used > 0 else 0.5  # 預設30秒
+            duration_minutes = (
+                tokens_used / 60.0 if tokens_used > 0 else 0.5
+            )  # 預設30秒
             return duration_minutes * model_rates.get("per_minute", 0.5)
 
         else:
@@ -305,7 +337,12 @@ class CostTracker:
             results = cursor.fetchall()
 
         # 重建快取
-        self._daily_cache = {"total_cost": 0.0, "call_count": 0, "providers": {}, "operations": {}}
+        self._daily_cache = {
+            "total_cost": 0.0,
+            "call_count": 0,
+            "providers": {},
+            "operations": {},
+        }
 
         for row in results:
             total_cost, call_count, provider, operation_type = row
@@ -327,7 +364,9 @@ class CostTracker:
         if not self.config_manager:
             return
 
-        daily_budget = self.config_manager.get("cost_control.daily_budget_usd", 100.0)
+        daily_budget = self.config_manager.get(
+            "cost_control.daily_budget_usd", 100.0
+        )
         current_cost = self._daily_cache.get("total_cost", 0) + new_cost
 
         # 預算使用率警告
@@ -337,12 +376,16 @@ class CostTracker:
             logger.warning(
                 f"⚠️  預算警告: 已使用 {usage_rate:.1%} ({current_cost:.2f}/${daily_budget})"
             )
-            await self._send_budget_alert("critical", usage_rate, current_cost, daily_budget)
+            await self._send_budget_alert(
+                "critical", usage_rate, current_cost, daily_budget
+            )
         elif usage_rate >= 0.8:
             logger.warning(
                 f"📊 預算提醒: 已使用 {usage_rate:.1%} ({current_cost:.2f}/${daily_budget})"
             )
-            await self._send_budget_alert("warning", usage_rate, current_cost, daily_budget)
+            await self._send_budget_alert(
+                "warning", usage_rate, current_cost, daily_budget
+            )
 
     async def _send_budget_alert(
         self, level: str, usage_rate: float, current_cost: float, budget: float
@@ -375,7 +418,9 @@ class CostTracker:
         async with aiofiles.open(alert_file, "w", encoding="utf-8") as f:
             await f.write(json.dumps(alerts, indent=2, ensure_ascii=False))
 
-    async def get_daily_summary(self, target_date: date = None) -> DailyCostSummary:
+    async def get_daily_summary(
+        self, target_date: date = None
+    ) -> DailyCostSummary:
         """獲取每日成本摘要"""
         if target_date is None:
             target_date = date.today()
@@ -386,7 +431,9 @@ class CostTracker:
 
             daily_budget = 100.0
             if self.config_manager:
-                daily_budget = self.config_manager.get("cost_control.daily_budget_usd", 100.0)
+                daily_budget = self.config_manager.get(
+                    "cost_control.daily_budget_usd", 100.0
+                )
 
             total_cost = self._daily_cache.get("total_cost", 0)
 
@@ -461,7 +508,12 @@ class CostTracker:
         for row in results:
             call_date, daily_cost, daily_calls, provider, operation_type = row
             if call_date not in daily_stats:
-                daily_stats[call_date] = {"cost": 0, "calls": 0, "providers": {}, "operations": {}}
+                daily_stats[call_date] = {
+                    "cost": 0,
+                    "calls": 0,
+                    "providers": {},
+                    "operations": {},
+                }
 
             daily_stats[call_date]["cost"] += daily_cost or 0
             daily_stats[call_date]["calls"] += daily_calls or 0
@@ -472,13 +524,18 @@ class CostTracker:
                 daily_stats[call_date]["operations"][operation_type] = 0
 
             daily_stats[call_date]["providers"][provider] += daily_cost or 0
-            daily_stats[call_date]["operations"][operation_type] += daily_cost or 0
+            daily_stats[call_date]["operations"][operation_type] += (
+                daily_cost or 0
+            )
 
             total_cost += daily_cost or 0
             total_calls += daily_calls or 0
 
         return {
-            "period": {"start": start_date.isoformat(), "end": end_date.isoformat()},
+            "period": {
+                "start": start_date.isoformat(),
+                "end": end_date.isoformat(),
+            },
             "total_cost": total_cost,
             "total_calls": total_calls,
             "average_daily_cost": total_cost / 7,
@@ -494,7 +551,8 @@ class CostTracker:
             "current_cost": summary.total_cost,
             "budget_limit": summary.budget_limit,
             "budget_remaining": summary.budget_remaining,
-            "usage_percentage": (summary.total_cost / summary.budget_limit) * 100,
+            "usage_percentage": (summary.total_cost / summary.budget_limit)
+            * 100,
             "is_over_budget": summary.is_over_budget,
             "can_continue": not summary.is_over_budget
             or not self._should_stop_on_budget_exceeded(),
@@ -506,7 +564,9 @@ class CostTracker:
         """檢查是否應該在預算超支時停止"""
         if not self.config_manager:
             return True
-        return self.config_manager.get("cost_control.stop_on_budget_exceeded", True)
+        return self.config_manager.get(
+            "cost_control.stop_on_budget_exceeded", True
+        )
 
     async def export_cost_data(self, days: int = 30) -> str:
         """匯出成本資料"""
@@ -542,13 +602,18 @@ class CostTracker:
 
         export_data = {
             "export_date": datetime.now().isoformat(),
-            "period": {"start": start_date.isoformat(), "end": end_date.isoformat()},
+            "period": {
+                "start": start_date.isoformat(),
+                "end": end_date.isoformat(),
+            },
             "total_records": len(data),
             "records": data,
         }
 
         async with aiofiles.open(export_file, "w", encoding="utf-8") as f:
-            await f.write(json.dumps(export_data, indent=2, ensure_ascii=False))
+            await f.write(
+                json.dumps(export_data, indent=2, ensure_ascii=False)
+            )
 
         logger.info(f"成本資料已匯出至: {export_file}")
         return str(export_file)
@@ -573,9 +638,14 @@ async def main():
     print("=== 成本追蹤器測試 ===")
 
     # 模擬一些 API 呼叫
-    await tracker.track_api_call("openai", "gpt-4", "text_generation", tokens_used=1000)
     await tracker.track_api_call(
-        "stability_ai", "stable-diffusion-xl", "image_generation", images_generated=2
+        "openai", "gpt-4", "text_generation", tokens_used=1000
+    )
+    await tracker.track_api_call(
+        "stability_ai",
+        "stable-diffusion-xl",
+        "image_generation",
+        images_generated=2,
     )
     await tracker.track_api_call(
         "elevenlabs", "voice_synthesis", "voice_synthesis", characters_used=500
diff --git a/auto_generate_video_fold6/monitoring/docker-performance-monitor.py b/auto_generate_video_fold6/monitoring/docker-performance-monitor.py
index a47b26d..804ee35 100644
--- a/auto_generate_video_fold6/monitoring/docker-performance-monitor.py
+++ b/auto_generate_video_fold6/monitoring/docker-performance-monitor.py
@@ -20,17 +20,19 @@ import sys
 # Configure logging
 logging.basicConfig(
     level=logging.INFO,
-    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
+    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
     handlers=[
-        logging.FileHandler('docker-performance.log'),
-        logging.StreamHandler()
-    ]
+        logging.FileHandler("docker-performance.log"),
+        logging.StreamHandler(),
+    ],
 )
 logger = logging.getLogger(__name__)
 
+
 @dataclass
 class ContainerMetrics:
     """Container performance metrics"""
+
     name: str
     id: str
     status: str
@@ -45,9 +47,11 @@ class ContainerMetrics:
     pids: int
     timestamp: str
 
+
 @dataclass
 class SystemMetrics:
     """System-wide performance metrics"""
+
     cpu_percent: float
     memory_total: int
     memory_available: int
@@ -56,9 +60,11 @@ class SystemMetrics:
     load_average: List[float]
     timestamp: str
 
+
 @dataclass
 class PerformanceAlert:
     """Performance alert definition"""
+
     type: str
     severity: str
     message: str
@@ -67,9 +73,10 @@ class PerformanceAlert:
     threshold: float
     timestamp: str
 
+
 class DockerPerformanceMonitor:
     """Advanced Docker performance monitoring and optimization"""
-    
+
     def __init__(self, config_file: str = "monitor-config.json"):
         self.client = docker.from_env()
         self.config = self._load_config(config_file)
@@ -77,17 +84,19 @@ class DockerPerformanceMonitor:
         self.alerts: List[PerformanceAlert] = []
         self.running = False
         self.monitor_thread = None
-        
+
         # Performance thresholds
-        self.cpu_threshold = self.config.get('cpu_threshold', 80.0)
-        self.memory_threshold = self.config.get('memory_threshold', 85.0)
-        self.disk_threshold = self.config.get('disk_threshold', 90.0)
-        self.network_threshold = self.config.get('network_threshold', 100 * 1024 * 1024)  # 100MB/s
-        
+        self.cpu_threshold = self.config.get("cpu_threshold", 80.0)
+        self.memory_threshold = self.config.get("memory_threshold", 85.0)
+        self.disk_threshold = self.config.get("disk_threshold", 90.0)
+        self.network_threshold = self.config.get(
+            "network_threshold", 100 * 1024 * 1024
+        )  # 100MB/s
+
         # Monitoring intervals
-        self.monitor_interval = self.config.get('monitor_interval', 30)
-        self.history_retention = self.config.get('history_retention_hours', 24)
-        
+        self.monitor_interval = self.config.get("monitor_interval", 30)
+        self.history_retention = self.config.get("history_retention_hours", 24)
+
         # Setup signal handlers
         signal.signal(signal.SIGINT, self._signal_handler)
         signal.signal(signal.SIGTERM, self._signal_handler)
@@ -96,9 +105,15 @@ class DockerPerformanceMonitor:
         """Load monitoring configuration"""
         default_config = {
             "services_to_monitor": [
-                "frontend", "api-gateway", "trend-service", 
-                "video-service", "social-service", "scheduler-service",
-                "postgres", "redis", "minio"
+                "frontend",
+                "api-gateway",
+                "trend-service",
+                "video-service",
+                "social-service",
+                "scheduler-service",
+                "postgres",
+                "redis",
+                "minio",
             ],
             "cpu_threshold": 80.0,
             "memory_threshold": 85.0,
@@ -108,17 +123,17 @@ class DockerPerformanceMonitor:
             "history_retention_hours": 24,
             "enable_auto_restart": True,
             "enable_scaling_recommendations": True,
-            "alert_webhook_url": None
+            "alert_webhook_url": None,
         }
-        
+
         try:
             if Path(config_file).exists():
-                with open(config_file, 'r') as f:
+                with open(config_file, "r") as f:
                     user_config = json.load(f)
                     default_config.update(user_config)
         except Exception as e:
             logger.warning(f"Could not load config file: {e}")
-        
+
         return default_config
 
     def _signal_handler(self, signum, frame):
@@ -132,42 +147,54 @@ class DockerPerformanceMonitor:
         try:
             # Get container stats
             stats = container.stats(stream=False)
-            
+
             # Calculate CPU percentage
-            cpu_delta = stats['cpu_stats']['cpu_usage']['total_usage'] - \
-                       stats['precpu_stats']['cpu_usage']['total_usage']
-            system_delta = stats['cpu_stats']['system_cpu_usage'] - \
-                          stats['precpu_stats']['system_cpu_usage']
-            
+            cpu_delta = (
+                stats["cpu_stats"]["cpu_usage"]["total_usage"]
+                - stats["precpu_stats"]["cpu_usage"]["total_usage"]
+            )
+            system_delta = (
+                stats["cpu_stats"]["system_cpu_usage"]
+                - stats["precpu_stats"]["system_cpu_usage"]
+            )
+
             cpu_percent = 0.0
             if system_delta > 0:
-                cpu_percent = (cpu_delta / system_delta) * \
-                             len(stats['cpu_stats']['cpu_usage']['percpu_usage']) * 100.0
-            
+                cpu_percent = (
+                    (cpu_delta / system_delta)
+                    * len(stats["cpu_stats"]["cpu_usage"]["percpu_usage"])
+                    * 100.0
+                )
+
             # Memory metrics
-            memory_usage = stats['memory_stats']['usage']
-            memory_limit = stats['memory_stats']['limit']
+            memory_usage = stats["memory_stats"]["usage"]
+            memory_limit = stats["memory_stats"]["limit"]
             memory_percent = (memory_usage / memory_limit) * 100.0
-            
+
             # Network metrics
             network_rx = network_tx = 0
-            if 'networks' in stats:
-                for interface in stats['networks'].values():
-                    network_rx += interface.get('rx_bytes', 0)
-                    network_tx += interface.get('tx_bytes', 0)
-            
+            if "networks" in stats:
+                for interface in stats["networks"].values():
+                    network_rx += interface.get("rx_bytes", 0)
+                    network_tx += interface.get("tx_bytes", 0)
+
             # Block I/O metrics
             block_read = block_write = 0
-            if 'blkio_stats' in stats and 'io_service_bytes_recursive' in stats['blkio_stats']:
-                for entry in stats['blkio_stats']['io_service_bytes_recursive']:
-                    if entry['op'] == 'Read':
-                        block_read += entry['value']
-                    elif entry['op'] == 'Write':
-                        block_write += entry['value']
-            
+            if (
+                "blkio_stats" in stats
+                and "io_service_bytes_recursive" in stats["blkio_stats"]
+            ):
+                for entry in stats["blkio_stats"][
+                    "io_service_bytes_recursive"
+                ]:
+                    if entry["op"] == "Read":
+                        block_read += entry["value"]
+                    elif entry["op"] == "Write":
+                        block_write += entry["value"]
+
             # PIDs count
-            pids = stats.get('pids_stats', {}).get('current', 0)
-            
+            pids = stats.get("pids_stats", {}).get("current", 0)
+
             return ContainerMetrics(
                 name=container.name,
                 id=container.short_id,
@@ -181,9 +208,9 @@ class DockerPerformanceMonitor:
                 block_read=block_read,
                 block_write=block_write,
                 pids=pids,
-                timestamp=datetime.utcnow().isoformat()
+                timestamp=datetime.utcnow().isoformat(),
             )
-            
+
         except Exception as e:
             logger.error(f"Error getting metrics for {container.name}: {e}")
             return None
@@ -194,13 +221,13 @@ class DockerPerformanceMonitor:
             # CPU and memory
             cpu_percent = psutil.cpu_percent(interval=1)
             memory = psutil.virtual_memory()
-            
+
             # Disk usage for root filesystem
-            disk = psutil.disk_usage('/')
-            
+            disk = psutil.disk_usage("/")
+
             # Load average
             load_avg = list(psutil.getloadavg())
-            
+
             return SystemMetrics(
                 cpu_percent=cpu_percent,
                 memory_total=memory.total,
@@ -208,159 +235,207 @@ class DockerPerformanceMonitor:
                 memory_percent=memory.percent,
                 disk_usage_percent=disk.percent,
                 load_average=load_avg,
-                timestamp=datetime.utcnow().isoformat()
+                timestamp=datetime.utcnow().isoformat(),
             )
-            
+
         except Exception as e:
             logger.error(f"Error getting system metrics: {e}")
             return None
 
-    def check_performance_alerts(self, container_metrics: List[ContainerMetrics], 
-                               system_metrics: SystemMetrics):
+    def check_performance_alerts(
+        self,
+        container_metrics: List[ContainerMetrics],
+        system_metrics: SystemMetrics,
+    ):
         """Check for performance issues and generate alerts"""
         alerts = []
-        
+
         # System-level alerts
         if system_metrics.cpu_percent > self.cpu_threshold:
-            alerts.append(PerformanceAlert(
-                type="system_cpu",
-                severity="warning" if system_metrics.cpu_percent < 95 else "critical",
-                message=f"High system CPU usage: {system_metrics.cpu_percent:.1f}%",
-                container=None,
-                value=system_metrics.cpu_percent,
-                threshold=self.cpu_threshold,
-                timestamp=datetime.utcnow().isoformat()
-            ))
-        
+            alerts.append(
+                PerformanceAlert(
+                    type="system_cpu",
+                    severity="warning"
+                    if system_metrics.cpu_percent < 95
+                    else "critical",
+                    message=f"High system CPU usage: {system_metrics.cpu_percent:.1f}%",
+                    container=None,
+                    value=system_metrics.cpu_percent,
+                    threshold=self.cpu_threshold,
+                    timestamp=datetime.utcnow().isoformat(),
+                )
+            )
+
         if system_metrics.memory_percent > self.memory_threshold:
-            alerts.append(PerformanceAlert(
-                type="system_memory",
-                severity="warning" if system_metrics.memory_percent < 95 else "critical",
-                message=f"High system memory usage: {system_metrics.memory_percent:.1f}%",
-                container=None,
-                value=system_metrics.memory_percent,
-                threshold=self.memory_threshold,
-                timestamp=datetime.utcnow().isoformat()
-            ))
-        
+            alerts.append(
+                PerformanceAlert(
+                    type="system_memory",
+                    severity="warning"
+                    if system_metrics.memory_percent < 95
+                    else "critical",
+                    message=f"High system memory usage: {system_metrics.memory_percent:.1f}%",
+                    container=None,
+                    value=system_metrics.memory_percent,
+                    threshold=self.memory_threshold,
+                    timestamp=datetime.utcnow().isoformat(),
+                )
+            )
+
         if system_metrics.disk_usage_percent > self.disk_threshold:
-            alerts.append(PerformanceAlert(
-                type="system_disk",
-                severity="warning" if system_metrics.disk_usage_percent < 95 else "critical",
-                message=f"High disk usage: {system_metrics.disk_usage_percent:.1f}%",
-                container=None,
-                value=system_metrics.disk_usage_percent,
-                threshold=self.disk_threshold,
-                timestamp=datetime.utcnow().isoformat()
-            ))
-        
+            alerts.append(
+                PerformanceAlert(
+                    type="system_disk",
+                    severity="warning"
+                    if system_metrics.disk_usage_percent < 95
+                    else "critical",
+                    message=f"High disk usage: {system_metrics.disk_usage_percent:.1f}%",
+                    container=None,
+                    value=system_metrics.disk_usage_percent,
+                    threshold=self.disk_threshold,
+                    timestamp=datetime.utcnow().isoformat(),
+                )
+            )
+
         # Container-level alerts
         for metrics in container_metrics:
             if metrics.cpu_percent > self.cpu_threshold:
-                alerts.append(PerformanceAlert(
-                    type="container_cpu",
-                    severity="warning" if metrics.cpu_percent < 95 else "critical",
-                    message=f"High CPU usage in {metrics.name}: {metrics.cpu_percent:.1f}%",
-                    container=metrics.name,
-                    value=metrics.cpu_percent,
-                    threshold=self.cpu_threshold,
-                    timestamp=datetime.utcnow().isoformat()
-                ))
-            
+                alerts.append(
+                    PerformanceAlert(
+                        type="container_cpu",
+                        severity="warning"
+                        if metrics.cpu_percent < 95
+                        else "critical",
+                        message=f"High CPU usage in {metrics.name}: {metrics.cpu_percent:.1f}%",
+                        container=metrics.name,
+                        value=metrics.cpu_percent,
+                        threshold=self.cpu_threshold,
+                        timestamp=datetime.utcnow().isoformat(),
+                    )
+                )
+
             if metrics.memory_percent > self.memory_threshold:
-                alerts.append(PerformanceAlert(
-                    type="container_memory",
-                    severity="warning" if metrics.memory_percent < 95 else "critical",
-                    message=f"High memory usage in {metrics.name}: {metrics.memory_percent:.1f}%",
-                    container=metrics.name,
-                    value=metrics.memory_percent,
-                    threshold=self.memory_threshold,
-                    timestamp=datetime.utcnow().isoformat()
-                ))
-        
+                alerts.append(
+                    PerformanceAlert(
+                        type="container_memory",
+                        severity="warning"
+                        if metrics.memory_percent < 95
+                        else "critical",
+                        message=f"High memory usage in {metrics.name}: {metrics.memory_percent:.1f}%",
+                        container=metrics.name,
+                        value=metrics.memory_percent,
+                        threshold=self.memory_threshold,
+                        timestamp=datetime.utcnow().isoformat(),
+                    )
+                )
+
         # Add new alerts to the list
         self.alerts.extend(alerts)
-        
+
         # Log alerts
         for alert in alerts:
-            level = logging.WARNING if alert.severity == "warning" else logging.CRITICAL
+            level = (
+                logging.WARNING
+                if alert.severity == "warning"
+                else logging.CRITICAL
+            )
             logger.log(level, f"ALERT: {alert.message}")
-        
+
         return alerts
 
-    def generate_optimization_recommendations(self, 
-                                           container_metrics: List[ContainerMetrics], 
-                                           system_metrics: SystemMetrics) -> List[str]:
+    def generate_optimization_recommendations(
+        self,
+        container_metrics: List[ContainerMetrics],
+        system_metrics: SystemMetrics,
+    ) -> List[str]:
         """Generate performance optimization recommendations"""
         recommendations = []
-        
+
         # Analyze container resource usage
-        high_cpu_containers = [m for m in container_metrics if m.cpu_percent > 70]
-        high_memory_containers = [m for m in container_metrics if m.memory_percent > 70]
-        
+        high_cpu_containers = [
+            m for m in container_metrics if m.cpu_percent > 70
+        ]
+        high_memory_containers = [
+            m for m in container_metrics if m.memory_percent > 70
+        ]
+
         if high_cpu_containers:
             for container in high_cpu_containers:
                 recommendations.append(
                     f"Consider increasing CPU limits for {container.name} "
                     f"(current usage: {container.cpu_percent:.1f}%)"
                 )
-        
+
         if high_memory_containers:
             for container in high_memory_containers:
                 recommendations.append(
                     f"Consider increasing memory limits for {container.name} "
                     f"(current usage: {container.memory_percent:.1f}%)"
                 )
-        
+
         # System-level recommendations
         if system_metrics.memory_percent > 80:
             recommendations.append(
                 "System memory usage is high. Consider adding more RAM or optimizing applications."
             )
-        
+
         if system_metrics.load_average[0] > psutil.cpu_count():
             recommendations.append(
                 f"System load average ({system_metrics.load_average[0]:.2f}) exceeds CPU count. "
                 "Consider reducing container concurrency or scaling horizontally."
             )
-        
+
         return recommendations
 
-    def save_metrics_to_file(self, container_metrics: List[ContainerMetrics], 
-                           system_metrics: SystemMetrics):
+    def save_metrics_to_file(
+        self,
+        container_metrics: List[ContainerMetrics],
+        system_metrics: SystemMetrics,
+    ):
         """Save metrics to JSON file for analysis"""
         try:
             metrics_data = {
                 "timestamp": datetime.utcnow().isoformat(),
                 "system": asdict(system_metrics),
-                "containers": [asdict(m) for m in container_metrics if m]
+                "containers": [asdict(m) for m in container_metrics if m],
             }
-            
+
             # Add to history
             self.metrics_history.append(metrics_data)
-            
+
             # Cleanup old data
-            cutoff_time = datetime.utcnow() - timedelta(hours=self.history_retention)
+            cutoff_time = datetime.utcnow() - timedelta(
+                hours=self.history_retention
+            )
             self.metrics_history = [
-                m for m in self.metrics_history 
-                if datetime.fromisoformat(m['timestamp'].replace('Z', '')) > cutoff_time
+                m
+                for m in self.metrics_history
+                if datetime.fromisoformat(m["timestamp"].replace("Z", ""))
+                > cutoff_time
             ]
-            
+
             # Save to file
-            with open('docker-performance-metrics.json', 'w') as f:
-                json.dump({
-                    "current": metrics_data,
-                    "history": self.metrics_history[-100:],  # Keep last 100 entries
-                    "alerts": [asdict(a) for a in self.alerts[-50:]]  # Keep last 50 alerts
-                }, f, indent=2)
-                
+            with open("docker-performance-metrics.json", "w") as f:
+                json.dump(
+                    {
+                        "current": metrics_data,
+                        "history": self.metrics_history[
+                            -100:
+                        ],  # Keep last 100 entries
+                        "alerts": [
+                            asdict(a) for a in self.alerts[-50:]
+                        ],  # Keep last 50 alerts
+                    },
+                    f,
+                    indent=2,
+                )
+
         except Exception as e:
             logger.error(f"Error saving metrics: {e}")
 
     def monitor_loop(self):
         """Main monitoring loop"""
         logger.info("Starting Docker performance monitoring...")
-        
+
         while self.running:
             try:
                 # Get system metrics
@@ -368,43 +443,47 @@ class DockerPerformanceMonitor:
                 if not system_metrics:
                     time.sleep(self.monitor_interval)
                     continue
-                
+
                 # Get container metrics
                 container_metrics = []
                 containers = self.client.containers.list()
-                
+
                 for container in containers:
                     # Filter by configured services
-                    if container.name in self.config['services_to_monitor']:
+                    if container.name in self.config["services_to_monitor"]:
                         metrics = self.get_container_metrics(container)
                         if metrics:
                             container_metrics.append(metrics)
-                
+
                 # Check for alerts
-                alerts = self.check_performance_alerts(container_metrics, system_metrics)
-                
+                alerts = self.check_performance_alerts(
+                    container_metrics, system_metrics
+                )
+
                 # Generate recommendations
                 recommendations = self.generate_optimization_recommendations(
                     container_metrics, system_metrics
                 )
-                
+
                 # Log recommendations
                 if recommendations:
                     logger.info("Performance recommendations:")
                     for rec in recommendations:
                         logger.info(f"  - {rec}")
-                
+
                 # Save metrics
                 self.save_metrics_to_file(container_metrics, system_metrics)
-                
+
                 # Print summary
-                logger.info(f"Monitored {len(container_metrics)} containers. "
-                          f"System: CPU {system_metrics.cpu_percent:.1f}%, "
-                          f"Memory {system_metrics.memory_percent:.1f}%, "
-                          f"Disk {system_metrics.disk_usage_percent:.1f}%")
-                
+                logger.info(
+                    f"Monitored {len(container_metrics)} containers. "
+                    f"System: CPU {system_metrics.cpu_percent:.1f}%, "
+                    f"Memory {system_metrics.memory_percent:.1f}%, "
+                    f"Disk {system_metrics.disk_usage_percent:.1f}%"
+                )
+
                 time.sleep(self.monitor_interval)
-                
+
             except Exception as e:
                 logger.error(f"Error in monitoring loop: {e}")
                 time.sleep(self.monitor_interval)
@@ -414,9 +493,11 @@ class DockerPerformanceMonitor:
         if self.running:
             logger.warning("Monitoring is already running")
             return
-        
+
         self.running = True
-        self.monitor_thread = threading.Thread(target=self.monitor_loop, daemon=True)
+        self.monitor_thread = threading.Thread(
+            target=self.monitor_loop, daemon=True
+        )
         self.monitor_thread.start()
         logger.info("Docker performance monitoring started")
 
@@ -424,7 +505,7 @@ class DockerPerformanceMonitor:
         """Stop the monitoring process"""
         if not self.running:
             return
-        
+
         self.running = False
         if self.monitor_thread:
             self.monitor_thread.join(timeout=5)
@@ -434,58 +515,71 @@ class DockerPerformanceMonitor:
         """Generate a comprehensive performance report"""
         if not self.metrics_history:
             return {"error": "No metrics data available"}
-        
+
         latest_metrics = self.metrics_history[-1]
-        
+
         # Calculate averages over last hour
         hour_ago = datetime.utcnow() - timedelta(hours=1)
         recent_metrics = [
-            m for m in self.metrics_history
-            if datetime.fromisoformat(m['timestamp'].replace('Z', '')) > hour_ago
+            m
+            for m in self.metrics_history
+            if datetime.fromisoformat(m["timestamp"].replace("Z", ""))
+            > hour_ago
         ]
-        
+
         if recent_metrics:
-            avg_system_cpu = sum(m['system']['cpu_percent'] for m in recent_metrics) / len(recent_metrics)
-            avg_system_memory = sum(m['system']['memory_percent'] for m in recent_metrics) / len(recent_metrics)
+            avg_system_cpu = sum(
+                m["system"]["cpu_percent"] for m in recent_metrics
+            ) / len(recent_metrics)
+            avg_system_memory = sum(
+                m["system"]["memory_percent"] for m in recent_metrics
+            ) / len(recent_metrics)
         else:
-            avg_system_cpu = latest_metrics['system']['cpu_percent']
-            avg_system_memory = latest_metrics['system']['memory_percent']
-        
+            avg_system_cpu = latest_metrics["system"]["cpu_percent"]
+            avg_system_memory = latest_metrics["system"]["memory_percent"]
+
         return {
             "report_time": datetime.utcnow().isoformat(),
-            "monitoring_duration_hours": len(self.metrics_history) * self.monitor_interval / 3600,
+            "monitoring_duration_hours": len(self.metrics_history)
+            * self.monitor_interval
+            / 3600,
             "current_metrics": latest_metrics,
             "hourly_averages": {
                 "system_cpu_percent": round(avg_system_cpu, 2),
-                "system_memory_percent": round(avg_system_memory, 2)
+                "system_memory_percent": round(avg_system_memory, 2),
             },
             "recent_alerts": [asdict(a) for a in self.alerts[-10:]],
-            "total_alerts": len(self.alerts)
+            "total_alerts": len(self.alerts),
         }
 
 
 def main():
     """Main function"""
     import argparse
-    
+
     parser = argparse.ArgumentParser(description="Docker Performance Monitor")
-    parser.add_argument("--config", default="monitor-config.json", 
-                       help="Configuration file path")
-    parser.add_argument("--daemon", action="store_true", 
-                       help="Run as daemon")
-    parser.add_argument("--report", action="store_true", 
-                       help="Generate and display performance report")
-    
+    parser.add_argument(
+        "--config",
+        default="monitor-config.json",
+        help="Configuration file path",
+    )
+    parser.add_argument("--daemon", action="store_true", help="Run as daemon")
+    parser.add_argument(
+        "--report",
+        action="store_true",
+        help="Generate and display performance report",
+    )
+
     args = parser.parse_args()
-    
+
     monitor = DockerPerformanceMonitor(args.config)
-    
+
     if args.report:
         # Generate and display report
         report = monitor.get_performance_report()
         print(json.dumps(report, indent=2))
         return
-    
+
     if args.daemon:
         # Run as daemon
         monitor.start_monitoring()
@@ -499,11 +593,11 @@ def main():
         monitor.start_monitoring()
         time.sleep(monitor.monitor_interval + 5)  # Wait for one cycle
         monitor.stop_monitoring()
-        
+
         # Display report
         report = monitor.get_performance_report()
         print(json.dumps(report, indent=2))
 
 
 if __name__ == "__main__":
-    main()
\ No newline at end of file
+    main()
diff --git a/auto_generate_video_fold6/monitoring/health-check/health_monitor.py b/auto_generate_video_fold6/monitoring/health-check/health_monitor.py
index 3d91d66..1b1e308 100644
--- a/auto_generate_video_fold6/monitoring/health-check/health_monitor.py
+++ b/auto_generate_video_fold6/monitoring/health-check/health_monitor.py
@@ -19,7 +19,12 @@ import docker
 import redis
 import sqlalchemy as sa
 from sqlalchemy import create_engine
-from prometheus_client import CollectorRegistry, Gauge, Counter, start_http_server
+from prometheus_client import (
+    CollectorRegistry,
+    Gauge,
+    Counter,
+    start_http_server,
+)
 import smtplib
 from email.mime.text import MIMEText
 from email.mime.multipart import MIMEMultipart
@@ -53,7 +58,9 @@ class SystemMetrics:
 class HealthMonitor:
     """健康檢查監控器"""
 
-    def __init__(self, config_path: str = "./monitoring/health-check/config.yaml"):
+    def __init__(
+        self, config_path: str = "./monitoring/health-check/config.yaml"
+    ):
         self.config_path = Path(config_path)
         self.config = self._load_config()
         self.logger = self._setup_logging()
@@ -106,7 +113,12 @@ class HealthMonitor:
     def _get_default_config(self) -> Dict[str, Any]:
         """獲取預設配置"""
         return {
-            "monitoring": {"interval": 30, "timeout": 10, "retries": 3, "alert_threshold": 3},
+            "monitoring": {
+                "interval": 30,
+                "timeout": 10,
+                "retries": 3,
+                "alert_threshold": 3,
+            },
             "services": [
                 {
                     "name": "api-gateway",
@@ -163,7 +175,10 @@ class HealthMonitor:
                     "from": "health@auto-video-system.com",
                     "to": ["ops@auto-video-system.com"],
                 },
-                "webhook": {"enabled": True, "url": "http://alertmanager:9093/api/v1/alerts"},
+                "webhook": {
+                    "enabled": True,
+                    "url": "http://alertmanager:9093/api/v1/alerts",
+                },
             },
         }
 
@@ -172,7 +187,10 @@ class HealthMonitor:
         logging.basicConfig(
             level=logging.INFO,
             format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
-            handlers=[logging.FileHandler("./logs/health_monitor.log"), logging.StreamHandler()],
+            handlers=[
+                logging.FileHandler("./logs/health_monitor.log"),
+                logging.StreamHandler(),
+            ],
         )
         return logging.getLogger(__name__)
 
@@ -205,13 +223,21 @@ class HealthMonitor:
             self.docker_client = docker.from_env()
 
             # Redis 連接
-            redis_config = next((s for s in self.config["services"] if s["name"] == "redis"), None)
+            redis_config = next(
+                (s for s in self.config["services"] if s["name"] == "redis"),
+                None,
+            )
             if redis_config:
                 self.redis_client = redis.from_url(redis_config["connection"])
 
             # 資料庫連接
             db_config = next(
-                (s for s in self.config["services"] if s["name"] == "postgresql"), None
+                (
+                    s
+                    for s in self.config["services"]
+                    if s["name"] == "postgresql"
+                ),
+                None,
             )
             if db_config:
                 self.db_engine = create_engine(db_config["connection"])
@@ -224,7 +250,9 @@ class HealthMonitor:
         check_tasks = []
 
         for service_config in self.config["services"]:
-            task = asyncio.create_task(self._check_service_health(service_config))
+            task = asyncio.create_task(
+                self._check_service_health(service_config)
+            )
             check_tasks.append(task)
 
         # 系統指標檢查
@@ -253,7 +281,9 @@ class HealthMonitor:
         # 評估整體系統健康
         await self._evaluate_system_health(health_statuses)
 
-    async def _check_service_health(self, service_config: Dict[str, Any]) -> HealthStatus:
+    async def _check_service_health(
+        self, service_config: Dict[str, Any]
+    ) -> HealthStatus:
         """檢查單個服務健康狀態"""
         service_name = service_config["name"]
         service_type = service_config["type"]
@@ -285,7 +315,9 @@ class HealthMonitor:
             self.health_gauge.labels(service_name=service_name).set(
                 1 if status.status == "healthy" else 0
             )
-            self.response_time_gauge.labels(service_name=service_name).set(response_time)
+            self.response_time_gauge.labels(service_name=service_name).set(
+                response_time
+            )
 
             return status
 
@@ -301,7 +333,9 @@ class HealthMonitor:
                 error_message=str(e),
             )
 
-    async def _check_http_service(self, service_config: Dict[str, Any]) -> HealthStatus:
+    async def _check_http_service(
+        self, service_config: Dict[str, Any]
+    ) -> HealthStatus:
         """檢查 HTTP 服務"""
         url = service_config["url"]
         timeout = self.config["monitoring"]["timeout"]
@@ -317,7 +351,9 @@ class HealthMonitor:
                             response_time=0,  # 將在上層設定
                             timestamp=datetime.now(),
                             details=response_data,
-                            dependencies=service_config.get("dependencies", []),
+                            dependencies=service_config.get(
+                                "dependencies", []
+                            ),
                         )
                     else:
                         return HealthStatus(
@@ -326,7 +362,9 @@ class HealthMonitor:
                             response_time=0,
                             timestamp=datetime.now(),
                             details={"http_status": response.status},
-                            dependencies=service_config.get("dependencies", []),
+                            dependencies=service_config.get(
+                                "dependencies", []
+                            ),
                             error_message=f"HTTP {response.status}",
                         )
             except asyncio.TimeoutError:
@@ -340,7 +378,9 @@ class HealthMonitor:
                     error_message="Request timeout",
                 )
 
-    async def _check_database_service(self, service_config: Dict[str, Any]) -> HealthStatus:
+    async def _check_database_service(
+        self, service_config: Dict[str, Any]
+    ) -> HealthStatus:
         """檢查資料庫服務"""
         try:
             if self.db_engine:
@@ -370,11 +410,15 @@ class HealthMonitor:
                 error_message=str(e),
             )
 
-    async def _check_redis_service(self, service_config: Dict[str, Any]) -> HealthStatus:
+    async def _check_redis_service(
+        self, service_config: Dict[str, Any]
+    ) -> HealthStatus:
         """檢查 Redis 服務"""
         try:
             if self.redis_client:
-                await asyncio.get_event_loop().run_in_executor(None, self.redis_client.ping)
+                await asyncio.get_event_loop().run_in_executor(
+                    None, self.redis_client.ping
+                )
 
                 return HealthStatus(
                     service_name=service_config["name"],
@@ -398,15 +442,21 @@ class HealthMonitor:
                 error_message=str(e),
             )
 
-    async def _check_docker_service(self, service_config: Dict[str, Any]) -> HealthStatus:
+    async def _check_docker_service(
+        self, service_config: Dict[str, Any]
+    ) -> HealthStatus:
         """檢查 Docker 容器服務"""
         try:
-            container_name = service_config.get("container_name", service_config["name"])
+            container_name = service_config.get(
+                "container_name", service_config["name"]
+            )
 
             if self.docker_client:
                 container = self.docker_client.containers.get(container_name)
 
-                status = "healthy" if container.status == "running" else "unhealthy"
+                status = (
+                    "healthy" if container.status == "running" else "unhealthy"
+                )
 
                 return HealthStatus(
                     service_name=service_config["name"],
@@ -449,7 +499,10 @@ class HealthMonitor:
 
             # 網路 I/O
             network = psutil.net_io_counters()
-            network_io = {"bytes_sent": network.bytes_sent, "bytes_recv": network.bytes_recv}
+            network_io = {
+                "bytes_sent": network.bytes_sent,
+                "bytes_recv": network.bytes_recv,
+            }
 
             # 活躍連接數
             connections = len(psutil.net_connections())
@@ -506,13 +559,19 @@ class HealthMonitor:
 
             if failure_count >= alert_threshold:
                 last_alert = previous_state.get("last_alert")
-                if not last_alert or (current_time - last_alert).seconds > 300:  # 5分鐘間隔
+                if (
+                    not last_alert or (current_time - last_alert).seconds > 300
+                ):  # 5分鐘間隔
                     await self._send_alert(health_status, failure_count)
-                    self.service_states[service_name]["last_alert"] = current_time
+                    self.service_states[service_name]["last_alert"] = (
+                        current_time
+                    )
 
     async def _check_dependencies(self, health_statuses: List[HealthStatus]):
         """檢查服務依賴關係"""
-        status_map = {status.service_name: status for status in health_statuses}
+        status_map = {
+            status.service_name: status for status in health_statuses
+        }
 
         for status in health_statuses:
             for dependency in status.dependencies:
@@ -522,17 +581,24 @@ class HealthMonitor:
                         service_name=status.service_name, dependency=dependency
                     ).set(1 if dep_status.status == "healthy" else 0)
 
-    async def _evaluate_system_health(self, health_statuses: List[HealthStatus]):
+    async def _evaluate_system_health(
+        self, health_statuses: List[HealthStatus]
+    ):
         """評估整體系統健康"""
         total_services = len(health_statuses)
-        healthy_services = sum(1 for s in health_statuses if s.status == "healthy")
+        healthy_services = sum(
+            1 for s in health_statuses if s.status == "healthy"
+        )
         critical_services = [
             s
             for s in health_statuses
-            if s.status != "healthy" and self._is_critical_service(s.service_name)
+            if s.status != "healthy"
+            and self._is_critical_service(s.service_name)
         ]
 
-        system_health_score = healthy_services / total_services if total_services > 0 else 0
+        system_health_score = (
+            healthy_services / total_services if total_services > 0 else 0
+        )
 
         # 記錄系統健康狀態
         self.logger.info(
@@ -542,11 +608,16 @@ class HealthMonitor:
 
         # 如果有關鍵服務故障，發送系統級告警
         if critical_services:
-            await self._send_system_alert(critical_services, system_health_score)
+            await self._send_system_alert(
+                critical_services, system_health_score
+            )
 
     def _is_critical_service(self, service_name: str) -> bool:
         """檢查是否為關鍵服務"""
-        service_config = next((s for s in self.config["services"] if s["name"] == service_name), {})
+        service_config = next(
+            (s for s in self.config["services"] if s["name"] == service_name),
+            {},
+        )
         return service_config.get("critical", False)
 
     async def _update_system_metrics(self, metrics: SystemMetrics):
@@ -554,7 +625,9 @@ class HealthMonitor:
         # 可以在這裡添加系統指標的 Prometheus 更新
         pass
 
-    async def _send_alert(self, health_status: HealthStatus, failure_count: int):
+    async def _send_alert(
+        self, health_status: HealthStatus, failure_count: int
+    ):
         """發送告警"""
         alert_data = {
             "service": health_status.service_name,
@@ -578,7 +651,9 @@ class HealthMonitor:
         if self.config["alerts"]["webhook"]["enabled"]:
             await self._send_webhook_alert(alert_data)
 
-        self.logger.warning(f"Alert sent for {health_status.service_name}: {health_status.status}")
+        self.logger.warning(
+            f"Alert sent for {health_status.service_name}: {health_status.status}"
+        )
 
     async def _send_recovery_alert(self, health_status: HealthStatus):
         """發送恢復告警"""
@@ -591,12 +666,16 @@ class HealthMonitor:
 
         self.logger.info(f"Service recovered: {health_status.service_name}")
 
-    async def _send_system_alert(self, critical_services: List[HealthStatus], health_score: float):
+    async def _send_system_alert(
+        self, critical_services: List[HealthStatus], health_score: float
+    ):
         """發送系統級告警"""
         system_alert = {
             "alert_type": "system_health",
             "health_score": health_score,
-            "critical_services_down": [s.service_name for s in critical_services],
+            "critical_services_down": [
+                s.service_name for s in critical_services
+            ],
             "timestamp": datetime.now().isoformat(),
         }
 
@@ -615,9 +694,13 @@ class HealthMonitor:
         try:
             webhook_url = self.config["alerts"]["webhook"]["url"]
             async with aiohttp.ClientSession() as session:
-                async with session.post(webhook_url, json=alert_data) as response:
+                async with session.post(
+                    webhook_url, json=alert_data
+                ) as response:
                     if response.status != 200:
-                        self.logger.error(f"Webhook alert failed: {response.status}")
+                        self.logger.error(
+                            f"Webhook alert failed: {response.status}"
+                        )
         except Exception as e:
             self.logger.error(f"Failed to send webhook alert: {e}")
 
diff --git a/auto_generate_video_fold6/monitoring/health_monitor.py b/auto_generate_video_fold6/monitoring/health_monitor.py
index 2e85fbe..a8482bd 100755
--- a/auto_generate_video_fold6/monitoring/health_monitor.py
+++ b/auto_generate_video_fold6/monitoring/health_monitor.py
@@ -94,7 +94,8 @@ class HealthMonitor:
                     data = json.load(f)
 
                 self.services = [
-                    ServiceCheck(**service_data) for service_data in data.get("services", [])
+                    ServiceCheck(**service_data)
+                    for service_data in data.get("services", [])
                 ]
             else:
                 # 使用預設配置
@@ -125,12 +126,24 @@ class HealthMonitor:
                 auto_restart=True,
                 restart_command="bash scripts/start_backend.sh",
             ),
-            ServiceCheck(name="redis", type="tcp", target="localhost:6379", timeout=5, interval=60),
             ServiceCheck(
-                name="disk_space", type="custom", target="check_disk_space", interval=300  # 5分鐘
+                name="redis",
+                type="tcp",
+                target="localhost:6379",
+                timeout=5,
+                interval=60,
             ),
             ServiceCheck(
-                name="memory_usage", type="custom", target="check_memory_usage", interval=60
+                name="disk_space",
+                type="custom",
+                target="check_disk_space",
+                interval=300,  # 5分鐘
+            ),
+            ServiceCheck(
+                name="memory_usage",
+                type="custom",
+                target="check_memory_usage",
+                interval=60,
             ),
         ]
 
@@ -138,7 +151,9 @@ class HealthMonitor:
 
         # 保存預設配置
         try:
-            config_data = {"services": [asdict(service) for service in self.services]}
+            config_data = {
+                "services": [asdict(service) for service in self.services]
+            }
 
             config_path = Path(self.config_file)
             config_path.parent.mkdir(parents=True, exist_ok=True)
@@ -217,7 +232,9 @@ class HealthMonitor:
 
             # 嘗試建立 TCP 連接
             future = asyncio.open_connection(host, port)
-            reader, writer = await asyncio.wait_for(future, timeout=service.timeout)
+            reader, writer = await asyncio.wait_for(
+                future, timeout=service.timeout
+            )
 
             writer.close()
             await writer.wait_closed()
@@ -250,7 +267,9 @@ class HealthMonitor:
                 timestamp=datetime.now(),
             )
 
-    async def _check_custom_service(self, service: ServiceCheck) -> HealthResult:
+    async def _check_custom_service(
+        self, service: ServiceCheck
+    ) -> HealthResult:
         """檢查自定義服務"""
         start_time = time.time()
 
@@ -262,7 +281,9 @@ class HealthMonitor:
             else:
                 # 執行自定義命令
                 process = await asyncio.create_subprocess_shell(
-                    service.target, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
+                    service.target,
+                    stdout=asyncio.subprocess.PIPE,
+                    stderr=asyncio.subprocess.PIPE,
                 )
 
                 stdout, stderr = await asyncio.wait_for(
@@ -277,7 +298,8 @@ class HealthMonitor:
                 else:
                     status = HealthStatus.CRITICAL
                     message = (
-                        stderr.decode().strip() or f"命令執行失敗 (退出代碼: {process.returncode})"
+                        stderr.decode().strip()
+                        or f"命令執行失敗 (退出代碼: {process.returncode})"
                     )
 
                 return HealthResult(
@@ -306,7 +328,9 @@ class HealthMonitor:
                 timestamp=datetime.now(),
             )
 
-    async def _check_disk_space(self, service: ServiceCheck, start_time: float) -> HealthResult:
+    async def _check_disk_space(
+        self, service: ServiceCheck, start_time: float
+    ) -> HealthResult:
         """檢查磁盤空間"""
         try:
             disk_usage = psutil.disk_usage("/")
@@ -347,7 +371,9 @@ class HealthMonitor:
                 timestamp=datetime.now(),
             )
 
-    async def _check_memory_usage(self, service: ServiceCheck, start_time: float) -> HealthResult:
+    async def _check_memory_usage(
+        self, service: ServiceCheck, start_time: float
+    ) -> HealthResult:
         """檢查記憶體使用"""
         try:
             memory = psutil.virtual_memory()
@@ -409,7 +435,10 @@ class HealthMonitor:
             )
 
         # 重試機制
-        if result.status in [HealthStatus.CRITICAL, HealthStatus.DOWN] and service.retries > 0:
+        if (
+            result.status in [HealthStatus.CRITICAL, HealthStatus.DOWN]
+            and service.retries > 0
+        ):
             for retry in range(service.retries):
                 logger.info(f"重試檢查 {service.name} (第 {retry + 1} 次)")
                 await asyncio.sleep(2)  # 等待2秒再重試
@@ -421,7 +450,10 @@ class HealthMonitor:
                 elif service.type == "custom":
                     retry_result = await self._check_custom_service(service)
 
-                if retry_result.status not in [HealthStatus.CRITICAL, HealthStatus.DOWN]:
+                if retry_result.status not in [
+                    HealthStatus.CRITICAL,
+                    HealthStatus.DOWN,
+                ]:
                     result = retry_result
                     result.message += f" (重試 {retry + 1} 次後成功)"
                     break
@@ -453,7 +485,9 @@ class HealthMonitor:
             if process.returncode == 0:
                 logger.info(f"服務 {service.name} 重啟成功")
             else:
-                logger.error(f"服務 {service.name} 重啟失敗: {stderr.decode()}")
+                logger.error(
+                    f"服務 {service.name} 重啟失敗: {stderr.decode()}"
+                )
 
         except Exception as e:
             logger.error(f"重啟服務 {service.name} 時發生錯誤: {e}")
@@ -469,7 +503,9 @@ class HealthMonitor:
 
         for i, result in enumerate(results):
             if isinstance(result, Exception):
-                logger.error(f"檢查服務 {self.services[i].name} 時發生錯誤: {result}")
+                logger.error(
+                    f"檢查服務 {self.services[i].name} 時發生錯誤: {result}"
+                )
                 result = HealthResult(
                     service=self.services[i].name,
                     status=HealthStatus.UNKNOWN,
@@ -489,19 +525,27 @@ class HealthMonitor:
             latest_file = self.monitor_dir / "latest_results.json"
             results_data = {
                 "timestamp": datetime.now().isoformat(),
-                "results": {name: result.to_dict() for name, result in self.results.items()},
+                "results": {
+                    name: result.to_dict()
+                    for name, result in self.results.items()
+                },
             }
 
             async with aiofiles.open(latest_file, "w", encoding="utf-8") as f:
-                await f.write(json.dumps(results_data, indent=2, ensure_ascii=False))
+                await f.write(
+                    json.dumps(results_data, indent=2, ensure_ascii=False)
+                )
 
             # 保存歷史記錄
             history_file = (
-                self.monitor_dir / f"health_history_{datetime.now().strftime('%Y%m%d')}.jsonl"
+                self.monitor_dir
+                / f"health_history_{datetime.now().strftime('%Y%m%d')}.jsonl"
             )
 
             async with aiofiles.open(history_file, "a", encoding="utf-8") as f:
-                await f.write(json.dumps(results_data, ensure_ascii=False) + "\n")
+                await f.write(
+                    json.dumps(results_data, ensure_ascii=False) + "\n"
+                )
 
             logger.debug("健康檢查結果已保存")
 
@@ -531,7 +575,9 @@ class HealthMonitor:
         status_counts = {}
         for status in HealthStatus:
             status_counts[status.value] = sum(
-                1 for result in self.results.values() if result.status == status
+                1
+                for result in self.results.values()
+                if result.status == status
             )
 
         return {
@@ -539,7 +585,9 @@ class HealthMonitor:
             "total_services": len(self.services),
             "status_counts": status_counts,
             "last_check": datetime.now().isoformat(),
-            "services": {name: result.to_dict() for name, result in self.results.items()},
+            "services": {
+                name: result.to_dict() for name, result in self.results.items()
+            },
         }
 
     async def run_continuous_monitoring(self):
@@ -560,11 +608,18 @@ class HealthMonitor:
 
                 # 如果有嚴重問題，記錄詳細信息
                 for name, result in self.results.items():
-                    if result.status in [HealthStatus.CRITICAL, HealthStatus.DOWN]:
-                        logger.warning(f"服務 {name} 狀態異常: {result.message}")
+                    if result.status in [
+                        HealthStatus.CRITICAL,
+                        HealthStatus.DOWN,
+                    ]:
+                        logger.warning(
+                            f"服務 {name} 狀態異常: {result.message}"
+                        )
 
                 # 等待下次檢查 (使用最小間隔)
-                min_interval = min(service.interval for service in self.services)
+                min_interval = min(
+                    service.interval for service in self.services
+                )
                 await asyncio.sleep(min_interval)
 
             except Exception as e:
diff --git a/auto_generate_video_fold6/monitoring/intelligent_cost_optimizer.py b/auto_generate_video_fold6/monitoring/intelligent_cost_optimizer.py
index a0161f9..336a5c9 100644
--- a/auto_generate_video_fold6/monitoring/intelligent_cost_optimizer.py
+++ b/auto_generate_video_fold6/monitoring/intelligent_cost_optimizer.py
@@ -132,7 +132,9 @@ class CostDataCollector:
 
             for record_json in daily_records:
                 record_data = json.loads(record_json)
-                record_data["timestamp"] = datetime.fromisoformat(record_data["timestamp"])
+                record_data["timestamp"] = datetime.fromisoformat(
+                    record_data["timestamp"]
+                )
                 record_data["category"] = CostCategory(record_data["category"])
 
                 record = CostRecord(**record_data)
@@ -165,7 +167,9 @@ class CostPredictor:
         end_date = datetime.utcnow()
         start_date = end_date - timedelta(days=90)  # 90天歷史數據
 
-        cost_data = await self.cost_collector.get_cost_data(start_date, end_date)
+        cost_data = await self.cost_collector.get_cost_data(
+            start_date, end_date
+        )
 
         if len(cost_data) < 30:  # 需要至少30個數據點
             logger.warning("歷史數據不足，無法訓練預測模型")
@@ -179,11 +183,15 @@ class CostPredictor:
 
         logger.info(f"完成 {len(categories)} 個類別的預測模型訓練")
 
-    async def _train_category_model(self, cost_data: List[CostRecord], category: CostCategory):
+    async def _train_category_model(
+        self, cost_data: List[CostRecord], category: CostCategory
+    ):
         """為特定類別訓練預測模型"""
 
         # 篩選類別數據
-        category_data = [record for record in cost_data if record.category == category]
+        category_data = [
+            record for record in cost_data if record.category == category
+        ]
 
         if len(category_data) < 10:
             return
@@ -205,9 +213,15 @@ class CostPredictor:
 
         # 創建時間序列特徵
         df = df.sort_values("timestamp")
-        df["days_since_start"] = (df["timestamp"] - df["timestamp"].min()).dt.days
-        df["rolling_mean_7d"] = df["amount"].rolling(window=7, min_periods=1).mean()
-        df["rolling_std_7d"] = df["amount"].rolling(window=7, min_periods=1).std().fillna(0)
+        df["days_since_start"] = (
+            df["timestamp"] - df["timestamp"].min()
+        ).dt.days
+        df["rolling_mean_7d"] = (
+            df["amount"].rolling(window=7, min_periods=1).mean()
+        )
+        df["rolling_std_7d"] = (
+            df["amount"].rolling(window=7, min_periods=1).std().fillna(0)
+        )
 
         # 準備特徵矩陣
         features = [
@@ -225,7 +239,10 @@ class CostPredictor:
 
         # 訓練隨機森林模型
         model = RandomForestRegressor(
-            n_estimators=100, max_depth=10, random_state=42, min_samples_split=5
+            n_estimators=100,
+            max_depth=10,
+            random_state=42,
+            min_samples_split=5,
         )
 
         model.fit(X, y)
@@ -235,7 +252,9 @@ class CostPredictor:
 
         # 計算特徵重要性
         feature_importance = dict(zip(features, model.feature_importances_))
-        logger.info(f"{category.value} 模型訓練完成，特徵重要性: {feature_importance}")
+        logger.info(
+            f"{category.value} 模型訓練完成，特徵重要性: {feature_importance}"
+        )
 
     async def predict_future_costs(
         self, category: CostCategory, days_ahead: int = 30
@@ -248,7 +267,10 @@ class CostPredictor:
         model = self.models[category]
 
         # 生成未來時間點的特徵
-        future_dates = [datetime.utcnow() + timedelta(days=i) for i in range(1, days_ahead + 1)]
+        future_dates = [
+            datetime.utcnow() + timedelta(days=i)
+            for i in range(1, days_ahead + 1)
+        ]
 
         predictions = []
 
@@ -277,7 +299,10 @@ class CostPredictor:
         # 計算置信區間 (使用樹的標準差)
         # 這是簡化的置信區間計算
         std_dev = np.std(predictions)
-        confidence_interval = (total_predicted - 1.96 * std_dev, total_predicted + 1.96 * std_dev)
+        confidence_interval = (
+            total_predicted - 1.96 * std_dev,
+            total_predicted + 1.96 * std_dev,
+        )
 
         # 分析趋势
         trend = self._analyze_trend(predictions)
@@ -311,7 +336,9 @@ class CostPredictor:
         else:
             return "stable"
 
-    async def _analyze_cost_factors(self, category: CostCategory) -> Dict[str, float]:
+    async def _analyze_cost_factors(
+        self, category: CostCategory
+    ) -> Dict[str, float]:
         """分析成本影響因素"""
 
         if category not in self.models:
@@ -336,7 +363,9 @@ class CostPredictor:
 class CostOptimizer:
     """成本優化器"""
 
-    def __init__(self, cost_collector: CostDataCollector, cost_predictor: CostPredictor):
+    def __init__(
+        self, cost_collector: CostDataCollector, cost_predictor: CostPredictor
+    ):
         self.cost_collector = cost_collector
         self.cost_predictor = cost_predictor
         self.optimization_rules = {}
@@ -403,7 +432,9 @@ class CostOptimizer:
         # 獲取最近30天的成本數據
         end_date = datetime.utcnow()
         start_date = end_date - timedelta(days=30)
-        cost_data = await self.cost_collector.get_cost_data(start_date, end_date)
+        cost_data = await self.cost_collector.get_cost_data(
+            start_date, end_date
+        )
 
         # 按類別分析成本
         category_costs = {}
@@ -418,8 +449,10 @@ class CostOptimizer:
             avg_daily_cost = total_cost / 30
 
             if category in self.optimization_rules:
-                category_recommendations = await self._generate_category_recommendations(
-                    category, total_cost, avg_daily_cost, strategy
+                category_recommendations = (
+                    await self._generate_category_recommendations(
+                        category, total_cost, avg_daily_cost, strategy
+                    )
                 )
                 recommendations.extend(category_recommendations)
 
@@ -442,7 +475,9 @@ class CostOptimizer:
 
         for rule_name, rule_config in rules.items():
             # 計算潛在節省
-            potential_savings = total_cost * rule_config["potential_savings_rate"]
+            potential_savings = (
+                total_cost * rule_config["potential_savings_rate"]
+            )
 
             # 根據策略調整建議優先級
             if strategy == OptimizationStrategy.COST_FIRST:
@@ -469,7 +504,9 @@ class CostOptimizer:
 
         return recommendations
 
-    def _assess_risk_level(self, rule_name: str, category: CostCategory) -> str:
+    def _assess_risk_level(
+        self, rule_name: str, category: CostCategory
+    ) -> str:
         """評估風險等級"""
         high_risk_rules = ["spot_instances", "aggressive_caching"]
         medium_risk_rules = ["auto_scaling", "model_selection"]
@@ -486,7 +523,9 @@ class CostOptimizer:
         effort_to_days = {"low": 3, "medium": 7, "high": 14}
         return effort_to_days.get(implementation_effort, 7)
 
-    def _generate_action_items(self, rule_name: str, category: CostCategory) -> List[str]:
+    def _generate_action_items(
+        self, rule_name: str, category: CostCategory
+    ) -> List[str]:
         """生成行動項目"""
         action_templates = {
             "model_selection": [
@@ -494,12 +533,18 @@ class CostOptimizer:
                 "實施動態模型選擇邏輯",
                 "設置模型性能監控",
             ],
-            "batch_processing": ["設計批量處理API", "實施請求聚合邏輯", "優化批處理調度"],
+            "batch_processing": [
+                "設計批量處理API",
+                "實施請求聚合邏輯",
+                "優化批處理調度",
+            ],
             "caching": ["設計緩存策略", "實施緩存失效機制", "監控緩存命中率"],
             "auto_scaling": ["配置HPA規則", "設置性能閾值", "實施預測性擴展"],
         }
 
-        return action_templates.get(rule_name, ["分析當前配置", "制定優化計劃", "實施並監控"])
+        return action_templates.get(
+            rule_name, ["分析當前配置", "制定優化計劃", "實施並監控"]
+        )
 
 
 class CostAnomalyDetector:
@@ -509,13 +554,17 @@ class CostAnomalyDetector:
         self.cost_collector = cost_collector
         self.anomaly_threshold = 2.0  # 標準差倍數
 
-    async def detect_anomalies(self, lookback_days: int = 7) -> List[Dict[str, Any]]:
+    async def detect_anomalies(
+        self, lookback_days: int = 7
+    ) -> List[Dict[str, Any]]:
         """檢測成本異常"""
 
         end_date = datetime.utcnow()
         start_date = end_date - timedelta(days=lookback_days)
 
-        cost_data = await self.cost_collector.get_cost_data(start_date, end_date)
+        cost_data = await self.cost_collector.get_cost_data(
+            start_date, end_date
+        )
 
         # 按服務分組
         service_costs = {}
@@ -529,7 +578,9 @@ class CostAnomalyDetector:
         anomalies = []
 
         for service, costs in service_costs.items():
-            service_anomalies = await self._detect_service_anomalies(service, costs)
+            service_anomalies = await self._detect_service_anomalies(
+                service, costs
+            )
             anomalies.extend(service_anomalies)
 
         return anomalies
@@ -598,7 +649,9 @@ class BudgetManager:
         budget_key = f"budget:{period}:{budget_config['category']}"
         self.redis_client.set(budget_key, json.dumps(budget_config))
 
-        logger.info(f"設置 {period} 預算: ${amount} ({budget_config['category']})")
+        logger.info(
+            f"設置 {period} 預算: ${amount} ({budget_config['category']})"
+        )
 
     async def check_budget_status(self) -> List[Dict[str, Any]]:
         """檢查預算狀態"""
@@ -612,7 +665,9 @@ class BudgetManager:
             # 計算當前期間的實際成本
             actual_cost = await self._calculate_period_cost(
                 budget_data["period"],
-                CostCategory(budget_data["category"]) if budget_data["category"] != "all" else None,
+                CostCategory(budget_data["category"])
+                if budget_data["category"] != "all"
+                else None,
             )
 
             # 計算使用率
@@ -623,7 +678,10 @@ class BudgetManager:
             for threshold in budget_data["alert_thresholds"]:
                 if usage_rate >= threshold:
                     alerts.append(
-                        {"threshold": threshold, "message": f"預算使用率達到 {threshold*100:.0f}%"}
+                        {
+                            "threshold": threshold,
+                            "message": f"預算使用率達到 {threshold * 100:.0f}%",
+                        }
                     )
 
             status = {
@@ -649,17 +707,25 @@ class BudgetManager:
         end_date = datetime.utcnow()
 
         if period == "daily":
-            start_date = end_date.replace(hour=0, minute=0, second=0, microsecond=0)
+            start_date = end_date.replace(
+                hour=0, minute=0, second=0, microsecond=0
+            )
         elif period == "weekly":
             days_since_monday = end_date.weekday()
             start_date = end_date - timedelta(days=days_since_monday)
-            start_date = start_date.replace(hour=0, minute=0, second=0, microsecond=0)
+            start_date = start_date.replace(
+                hour=0, minute=0, second=0, microsecond=0
+            )
         elif period == "monthly":
-            start_date = end_date.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
+            start_date = end_date.replace(
+                day=1, hour=0, minute=0, second=0, microsecond=0
+            )
         else:
             raise ValueError(f"不支持的期間類型: {period}")
 
-        cost_data = await self.cost_collector.get_cost_data(start_date, end_date, category=category)
+        cost_data = await self.cost_collector.get_cost_data(
+            start_date, end_date, category=category
+        )
 
         return sum(record.amount for record in cost_data)
 
@@ -683,7 +749,9 @@ class IntelligentCostOptimizer:
     def __init__(self):
         self.cost_collector = CostDataCollector()
         self.cost_predictor = CostPredictor(self.cost_collector)
-        self.cost_optimizer = CostOptimizer(self.cost_collector, self.cost_predictor)
+        self.cost_optimizer = CostOptimizer(
+            self.cost_collector, self.cost_predictor
+        )
         self.anomaly_detector = CostAnomalyDetector(self.cost_collector)
         self.budget_manager = BudgetManager(self.cost_collector)
 
@@ -708,7 +776,11 @@ class IntelligentCostOptimizer:
             predictions = {}
             for category in CostCategory:
                 try:
-                    prediction = await self.cost_predictor.predict_future_costs(category, 30)
+                    prediction = (
+                        await self.cost_predictor.predict_future_costs(
+                            category, 30
+                        )
+                    )
                     predictions[category.value] = asdict(prediction)
                 except Exception as e:
                     logger.warning(f"無法預測 {category.value} 的成本: {e}")
@@ -723,7 +795,9 @@ class IntelligentCostOptimizer:
             budget_status = await self.budget_manager.check_budget_status()
 
             # 5. 計算總體節省潛力
-            total_potential_savings = sum(rec.potential_savings for rec in recommendations)
+            total_potential_savings = sum(
+                rec.potential_savings for rec in recommendations
+            )
 
             analysis_result = {
                 "timestamp": datetime.utcnow().isoformat(),
@@ -735,7 +809,11 @@ class IntelligentCostOptimizer:
                 "summary": {
                     "total_recommendations": len(recommendations),
                     "high_priority_recommendations": len(
-                        [r for r in recommendations if r.potential_savings > 100]
+                        [
+                            r
+                            for r in recommendations
+                            if r.potential_savings > 100
+                        ]
                     ),
                     "anomalies_detected": len(anomalies),
                     "budgets_exceeded": len(
@@ -744,7 +822,9 @@ class IntelligentCostOptimizer:
                 },
             }
 
-            logger.info(f"綜合分析完成 - 潛在節省: ${total_potential_savings:.2f}")
+            logger.info(
+                f"綜合分析完成 - 潛在節省: ${total_potential_savings:.2f}"
+            )
             return analysis_result
 
         except Exception as e:
diff --git a/auto_generate_video_fold6/monitoring/logging/performance_logger.py b/auto_generate_video_fold6/monitoring/logging/performance_logger.py
index 7ae82c1..66638f4 100644
--- a/auto_generate_video_fold6/monitoring/logging/performance_logger.py
+++ b/auto_generate_video_fold6/monitoring/logging/performance_logger.py
@@ -18,72 +18,83 @@ from collections import deque
 import uuid
 
 # 上下文變數
-correlation_id_context: ContextVar[Optional[str]] = ContextVar("correlation_id", default=None)
-request_id_context: ContextVar[Optional[str]] = ContextVar("request_id", default=None)
+correlation_id_context: ContextVar[Optional[str]] = ContextVar(
+    "correlation_id", default=None
+)
+request_id_context: ContextVar[Optional[str]] = ContextVar(
+    "request_id", default=None
+)
+
 
 class PerformanceLogger:
     """高效能結構化日誌記錄器"""
-    
-    def __init__(self, 
-                 service_name: str,
-                 buffer_size: int = 1000,
-                 flush_interval: float = 1.0,
-                 enable_async: bool = True):
+
+    def __init__(
+        self,
+        service_name: str,
+        buffer_size: int = 1000,
+        flush_interval: float = 1.0,
+        enable_async: bool = True,
+    ):
         self.service_name = service_name
         self.buffer_size = buffer_size
         self.flush_interval = flush_interval
         self.enable_async = enable_async
-        
+
         # 高效能緩衝區
         self.log_buffer = deque(maxlen=buffer_size)
         self.buffer_lock = threading.Lock()
-        
+
         # 異步處理
         if enable_async:
             self.log_queue = queue.Queue(maxsize=buffer_size * 2)
-            self.worker_thread = threading.Thread(target=self._worker_loop, daemon=True)
+            self.worker_thread = threading.Thread(
+                target=self._worker_loop, daemon=True
+            )
             self.worker_thread.start()
-        
+
         # 標準日誌記錄器作為後備
         self.stdlib_logger = logging.getLogger(service_name)
         if not self.stdlib_logger.handlers:
             handler = logging.StreamHandler()
             formatter = logging.Formatter(
-                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
+                "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
             )
             handler.setFormatter(formatter)
             self.stdlib_logger.addHandler(handler)
             self.stdlib_logger.setLevel(logging.INFO)
-        
+
         # 效能指標
         self.stats = {
             "logs_processed": 0,
             "total_processing_time": 0.0,
             "avg_processing_time": 0.0,
             "buffer_utilization": 0.0,
-            "last_flush_time": time.time()
+            "last_flush_time": time.time(),
         }
-    
-    def _create_log_entry(self, level: str, message: str, **kwargs) -> Dict[str, Any]:
+
+    def _create_log_entry(
+        self, level: str, message: str, **kwargs
+    ) -> Dict[str, Any]:
         """創建高效能日誌條目"""
         timestamp = datetime.now(timezone.utc).isoformat()
-        
+
         entry = {
             "timestamp": timestamp,
             "level": level,
             "service": self.service_name,
             "message": message,
             "correlation_id": correlation_id_context.get(),
-            "request_id": request_id_context.get()
+            "request_id": request_id_context.get(),
         }
-        
+
         # 只添加有值的欄位以減少記憶體使用
         for key, value in kwargs.items():
             if value is not None:
                 entry[key] = value
-        
+
         return entry
-    
+
     def _worker_loop(self):
         """異步工作線程"""
         while True:
@@ -97,24 +108,26 @@ class PerformanceLogger:
                         entries.append(entry)
                 except queue.Empty:
                     pass
-                
+
                 if entries:
                     self._flush_entries(entries)
-                    
+
             except Exception as e:
                 # 錯誤處理，避免工作線程崩潰
                 self.stdlib_logger.error(f"Log worker error: {e}")
                 time.sleep(0.1)
-    
+
     def _flush_entries(self, entries: list):
         """批量刷新日誌條目"""
         start_time = time.perf_counter()
-        
+
         for entry in entries:
             # 輸出為 JSON 格式
-            json_line = json.dumps(entry, separators=(',', ':'), ensure_ascii=False)
+            json_line = json.dumps(
+                entry, separators=(",", ":"), ensure_ascii=False
+            )
             print(json_line, flush=True)
-        
+
         # 更新統計信息
         processing_time = time.perf_counter() - start_time
         self.stats["logs_processed"] += len(entries)
@@ -123,11 +136,11 @@ class PerformanceLogger:
             self.stats["total_processing_time"] / self.stats["logs_processed"]
         )
         self.stats["last_flush_time"] = time.time()
-    
+
     def log(self, level: str, message: str, **kwargs):
         """高效能日誌記錄"""
         entry = self._create_log_entry(level, message, **kwargs)
-        
+
         if self.enable_async:
             try:
                 self.log_queue.put(entry, block=False)
@@ -138,27 +151,27 @@ class PerformanceLogger:
             # 同步模式：使用緩衝區
             with self.buffer_lock:
                 self.log_buffer.append(entry)
-                
+
                 if len(self.log_buffer) >= self.buffer_size:
                     self._flush_entries(list(self.log_buffer))
                     self.log_buffer.clear()
-    
+
     def info(self, message: str, **kwargs):
         """INFO 級別日誌"""
         self.log("INFO", message, **kwargs)
-    
+
     def error(self, message: str, **kwargs):
         """ERROR 級別日誌"""
         self.log("ERROR", message, **kwargs)
-    
+
     def warning(self, message: str, **kwargs):
         """WARNING 級別日誌"""
         self.log("WARNING", message, **kwargs)
-    
+
     def debug(self, message: str, **kwargs):
         """DEBUG 級別日誌"""
         self.log("DEBUG", message, **kwargs)
-    
+
     def flush(self):
         """強制刷新緩衝區"""
         if not self.enable_async:
@@ -166,197 +179,216 @@ class PerformanceLogger:
                 if self.log_buffer:
                     self._flush_entries(list(self.log_buffer))
                     self.log_buffer.clear()
-    
+
     def get_stats(self) -> Dict[str, Any]:
         """獲取效能統計"""
         with self.buffer_lock:
-            self.stats["buffer_utilization"] = len(self.log_buffer) / self.buffer_size
-        
+            self.stats["buffer_utilization"] = (
+                len(self.log_buffer) / self.buffer_size
+            )
+
         return self.stats.copy()
 
+
 class LogContext:
     """高效能日誌上下文管理器"""
-    
+
     def __init__(self, correlation_id: str = None, request_id: str = None):
         self.correlation_id = correlation_id or str(uuid.uuid4())
         self.request_id = request_id or str(uuid.uuid4())
         self.tokens = []
-    
+
     def __enter__(self):
         self.tokens.append(correlation_id_context.set(self.correlation_id))
         self.tokens.append(request_id_context.set(self.request_id))
         return self
-    
+
     def __exit__(self, exc_type, exc_val, exc_tb):
         for token in reversed(self.tokens):
             token.var.reset(token)
 
+
 # 裝飾器用於函數效能測量
-def measure_performance(logger: PerformanceLogger = None, operation_name: str = None):
+def measure_performance(
+    logger: PerformanceLogger = None, operation_name: str = None
+):
     """函數效能測量裝飾器"""
+
     def decorator(func):
         from functools import wraps
-        
+
         @wraps(func)
         async def async_wrapper(*args, **kwargs):
             nonlocal logger
             if not logger:
                 logger = get_performance_logger(func.__module__)
-            
+
             name = operation_name or f"{func.__module__}.{func.__name__}"
             start_time = time.perf_counter()
-            
+
             try:
                 result = await func(*args, **kwargs)
                 duration = (time.perf_counter() - start_time) * 1000
-                
+
                 logger.info(
                     f"Operation completed: {name}",
                     operation=name,
                     duration_ms=duration,
-                    status="success"
+                    status="success",
                 )
-                
+
                 return result
-                
+
             except Exception as e:
                 duration = (time.perf_counter() - start_time) * 1000
-                
+
                 logger.error(
                     f"Operation failed: {name}",
                     operation=name,
                     duration_ms=duration,
                     status="error",
                     error_type=type(e).__name__,
-                    error_message=str(e)
+                    error_message=str(e),
                 )
                 raise
-        
+
         @wraps(func)
         def sync_wrapper(*args, **kwargs):
             nonlocal logger
             if not logger:
                 logger = get_performance_logger(func.__module__)
-            
+
             name = operation_name or f"{func.__module__}.{func.__name__}"
             start_time = time.perf_counter()
-            
+
             try:
                 result = func(*args, **kwargs)
                 duration = (time.perf_counter() - start_time) * 1000
-                
+
                 logger.info(
                     f"Operation completed: {name}",
                     operation=name,
                     duration_ms=duration,
-                    status="success"
+                    status="success",
                 )
-                
+
                 return result
-                
+
             except Exception as e:
                 duration = (time.perf_counter() - start_time) * 1000
-                
+
                 logger.error(
                     f"Operation failed: {name}",
                     operation=name,
                     duration_ms=duration,
                     status="error",
                     error_type=type(e).__name__,
-                    error_message=str(e)
+                    error_message=str(e),
                 )
                 raise
-        
+
         if asyncio.iscoroutinefunction(func):
             return async_wrapper
         else:
             return sync_wrapper
-    
+
     return decorator
 
+
 # 全域記錄器管理
 _performance_loggers: Dict[str, PerformanceLogger] = {}
 _loggers_lock = threading.Lock()
 
+
 def get_performance_logger(service_name: str, **kwargs) -> PerformanceLogger:
     """獲取或創建高效能日誌記錄器"""
     with _loggers_lock:
         if service_name not in _performance_loggers:
             _performance_loggers[service_name] = PerformanceLogger(
-                service_name=service_name,
-                **kwargs
+                service_name=service_name, **kwargs
             )
         return _performance_loggers[service_name]
 
+
 def set_correlation_id(correlation_id: str):
     """設定關聯ID"""
     correlation_id_context.set(correlation_id)
 
+
 def set_request_id(request_id: str):
     """設定請求ID"""
     request_id_context.set(request_id)
 
+
 def get_correlation_id() -> Optional[str]:
     """獲取關聯ID"""
     return correlation_id_context.get()
 
+
 def get_request_id() -> Optional[str]:
     """獲取請求ID"""
     return request_id_context.get()
 
+
 @contextmanager
 def performance_context(correlation_id: str = None, request_id: str = None):
     """效能監控上下文管理器"""
     with LogContext(correlation_id, request_id):
         yield
 
+
 # 批量日誌處理器
 class BatchLogProcessor:
     """批量日誌處理器，用於高吞吐量場景"""
-    
+
     def __init__(self, batch_size: int = 100, flush_interval: float = 5.0):
         self.batch_size = batch_size
         self.flush_interval = flush_interval
         self.batch = []
         self.last_flush = time.time()
         self.lock = threading.Lock()
-    
+
     def add_log(self, entry: Dict[str, Any]):
         """添加日誌條目到批次"""
         with self.lock:
             self.batch.append(entry)
-            
+
             # 檢查是否需要刷新
-            if (len(self.batch) >= self.batch_size or 
-                time.time() - self.last_flush >= self.flush_interval):
+            if (
+                len(self.batch) >= self.batch_size
+                or time.time() - self.last_flush >= self.flush_interval
+            ):
                 self._flush_batch()
-    
+
     def _flush_batch(self):
         """刷新批次"""
         if not self.batch:
             return
-        
+
         # 批量輸出
         for entry in self.batch:
-            json_line = json.dumps(entry, separators=(',', ':'), ensure_ascii=False)
+            json_line = json.dumps(
+                entry, separators=(",", ":"), ensure_ascii=False
+            )
             print(json_line, flush=True)
-        
+
         self.batch.clear()
         self.last_flush = time.time()
-    
+
     def flush(self):
         """強制刷新"""
         with self.lock:
             self._flush_batch()
 
+
 # 效能監控工具
 class PerformanceMonitor:
     """效能監控工具"""
-    
+
     def __init__(self):
         self.metrics = {}
         self.lock = threading.Lock()
-    
+
     def record_timing(self, operation: str, duration_ms: float):
         """記錄操作時間"""
         with self.lock:
@@ -364,35 +396,38 @@ class PerformanceMonitor:
                 self.metrics[operation] = {
                     "count": 0,
                     "total_time": 0.0,
-                    "min_time": float('inf'),
+                    "min_time": float("inf"),
                     "max_time": 0.0,
-                    "recent_times": deque(maxlen=100)
+                    "recent_times": deque(maxlen=100),
                 }
-            
+
             metric = self.metrics[operation]
             metric["count"] += 1
             metric["total_time"] += duration_ms
             metric["min_time"] = min(metric["min_time"], duration_ms)
             metric["max_time"] = max(metric["max_time"], duration_ms)
             metric["recent_times"].append(duration_ms)
-    
+
     def get_stats(self) -> Dict[str, Any]:
         """獲取效能統計"""
         with self.lock:
             stats = {}
             for operation, metric in self.metrics.items():
                 avg_time = metric["total_time"] / metric["count"]
-                recent_avg = sum(metric["recent_times"]) / len(metric["recent_times"])
-                
+                recent_avg = sum(metric["recent_times"]) / len(
+                    metric["recent_times"]
+                )
+
                 stats[operation] = {
                     "count": metric["count"],
                     "avg_time_ms": avg_time,
                     "min_time_ms": metric["min_time"],
                     "max_time_ms": metric["max_time"],
-                    "recent_avg_ms": recent_avg
+                    "recent_avg_ms": recent_avg,
                 }
-            
+
             return stats
 
+
 # 全域效能監控器
-performance_monitor = PerformanceMonitor()
\ No newline at end of file
+performance_monitor = PerformanceMonitor()
diff --git a/auto_generate_video_fold6/monitoring/logging/structured_logger.py b/auto_generate_video_fold6/monitoring/logging/structured_logger.py
index 4b7250d..393eba3 100644
--- a/auto_generate_video_fold6/monitoring/logging/structured_logger.py
+++ b/auto_generate_video_fold6/monitoring/logging/structured_logger.py
@@ -17,10 +17,18 @@ import structlog
 from pythonjsonlogger import jsonlogger
 
 # 上下文變數，用於追蹤請求
-request_id_context: ContextVar[Optional[str]] = ContextVar("request_id", default=None)
-user_id_context: ContextVar[Optional[str]] = ContextVar("user_id", default=None)
-trace_id_context: ContextVar[Optional[str]] = ContextVar("trace_id", default=None)
-correlation_id_context: ContextVar[Optional[str]] = ContextVar("correlation_id", default=None)
+request_id_context: ContextVar[Optional[str]] = ContextVar(
+    "request_id", default=None
+)
+user_id_context: ContextVar[Optional[str]] = ContextVar(
+    "user_id", default=None
+)
+trace_id_context: ContextVar[Optional[str]] = ContextVar(
+    "trace_id", default=None
+)
+correlation_id_context: ContextVar[Optional[str]] = ContextVar(
+    "correlation_id", default=None
+)
 
 
 class LogLevel(Enum):
@@ -49,7 +57,7 @@ class EventType(Enum):
 @dataclass
 class LogEvent:
     """日誌事件數據結構"""
-    
+
     timestamp: str
     level: str
     service: str
@@ -66,7 +74,7 @@ class LogEvent:
     exception: Optional[str] = None
     stack_trace: Optional[str] = None
     additional_fields: Optional[Dict[str, Any]] = None
-    
+
     def to_dict(self) -> Dict[str, Any]:
         """轉換為字典格式"""
         result = asdict(self)
@@ -81,19 +89,19 @@ def add_context_processor(logger, method_name, event_dict):
     # 添加關聯ID
     if correlation_id_context.get():
         event_dict["correlation_id"] = correlation_id_context.get()
-    
+
     # 添加請求ID
     if request_id_context.get():
         event_dict["request_id"] = request_id_context.get()
-    
+
     # 添加用戶ID
     if user_id_context.get():
         event_dict["user_id"] = user_id_context.get()
-    
+
     # 添加追踪ID
     if trace_id_context.get():
         event_dict["trace_id"] = trace_id_context.get()
-    
+
     return event_dict
 
 
@@ -126,7 +134,7 @@ structlog.configure(
         structlog.stdlib.PositionalArgumentsFormatter(),
         structlog.processors.StackInfoRenderer(),
         structlog.processors.format_exc_info,
-        structlog.processors.JSONRenderer()
+        structlog.processors.JSONRenderer(),
     ],
     context_class=dict,
     logger_factory=structlog.stdlib.LoggerFactory(),
@@ -198,7 +206,8 @@ class StructuredLogger:
             )
         else:
             formatter = logging.Formatter(
-                "%(asctime)s - %(name)s - %(levelname)s - %(message)s", datefmt="%Y-%m-%d %H:%M:%S"
+                "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
+                datefmt="%Y-%m-%d %H:%M:%S",
             )
 
         # 控制台處理器
@@ -271,29 +280,49 @@ class StructuredLogger:
             **kwargs,
         )
 
-    def debug(self, message: str, event_type: EventType = EventType.SYSTEM, **kwargs):
+    def debug(
+        self, message: str, event_type: EventType = EventType.SYSTEM, **kwargs
+    ):
         """記錄 DEBUG 級別日誌"""
-        event = self._create_log_event(LogLevel.DEBUG, event_type, message, **kwargs)
+        event = self._create_log_event(
+            LogLevel.DEBUG, event_type, message, **kwargs
+        )
         self.struct_logger.debug(message, **event.to_dict())
 
-    def info(self, message: str, event_type: EventType = EventType.SYSTEM, **kwargs):
+    def info(
+        self, message: str, event_type: EventType = EventType.SYSTEM, **kwargs
+    ):
         """記錄 INFO 級別日誌"""
-        event = self._create_log_event(LogLevel.INFO, event_type, message, **kwargs)
+        event = self._create_log_event(
+            LogLevel.INFO, event_type, message, **kwargs
+        )
         self.struct_logger.info(message, **event.to_dict())
 
-    def warning(self, message: str, event_type: EventType = EventType.SYSTEM, **kwargs):
+    def warning(
+        self, message: str, event_type: EventType = EventType.SYSTEM, **kwargs
+    ):
         """記錄 WARNING 級別日誌"""
-        event = self._create_log_event(LogLevel.WARNING, event_type, message, **kwargs)
+        event = self._create_log_event(
+            LogLevel.WARNING, event_type, message, **kwargs
+        )
         self.struct_logger.warning(message, **event.to_dict())
 
-    def error(self, message: str, event_type: EventType = EventType.ERROR, **kwargs):
+    def error(
+        self, message: str, event_type: EventType = EventType.ERROR, **kwargs
+    ):
         """記錄 ERROR 級別日誌"""
-        event = self._create_log_event(LogLevel.ERROR, event_type, message, **kwargs)
+        event = self._create_log_event(
+            LogLevel.ERROR, event_type, message, **kwargs
+        )
         self.struct_logger.error(message, **event.to_dict())
 
-    def critical(self, message: str, event_type: EventType = EventType.ERROR, **kwargs):
+    def critical(
+        self, message: str, event_type: EventType = EventType.ERROR, **kwargs
+    ):
         """記錄 CRITICAL 級別日誌"""
-        event = self._create_log_event(LogLevel.CRITICAL, event_type, message, **kwargs)
+        event = self._create_log_event(
+            LogLevel.CRITICAL, event_type, message, **kwargs
+        )
         self.struct_logger.critical(message, **event.to_dict())
 
     def log_request(
@@ -319,7 +348,9 @@ class StructuredLogger:
             **kwargs,
         )
 
-    def log_error(self, error: Exception, context: Dict[str, Any] = None, **kwargs):
+    def log_error(
+        self, error: Exception, context: Dict[str, Any] = None, **kwargs
+    ):
         """記錄錯誤"""
         error_details = {
             "type": type(error).__name__,
@@ -354,15 +385,25 @@ class StructuredLogger:
             "resource": resource,
         }
 
-        level = LogLevel.WARNING if severity in ["low", "medium"] else LogLevel.ERROR
+        level = (
+            LogLevel.WARNING
+            if severity in ["low", "medium"]
+            else LogLevel.ERROR
+        )
 
         if level == LogLevel.ERROR:
             self.error(
-                event_description, event_type=EventType.SECURITY, extra=security_data, **kwargs
+                event_description,
+                event_type=EventType.SECURITY,
+                extra=security_data,
+                **kwargs,
             )
         else:
             self.warning(
-                event_description, event_type=EventType.SECURITY, extra=security_data, **kwargs
+                event_description,
+                event_type=EventType.SECURITY,
+                extra=security_data,
+                **kwargs,
             )
 
     def log_performance(
@@ -385,11 +426,23 @@ class StructuredLogger:
         message = f"Performance: {operation} took {duration_ms:.2f}ms"
 
         if level == LogLevel.WARNING:
-            self.warning(message, event_type=EventType.PERFORMANCE, extra=perf_data, **kwargs)
+            self.warning(
+                message,
+                event_type=EventType.PERFORMANCE,
+                extra=perf_data,
+                **kwargs,
+            )
         else:
-            self.info(message, event_type=EventType.PERFORMANCE, extra=perf_data, **kwargs)
+            self.info(
+                message,
+                event_type=EventType.PERFORMANCE,
+                extra=perf_data,
+                **kwargs,
+            )
 
-    def log_business_event(self, event_name: str, metrics: Dict[str, Any], **kwargs):
+    def log_business_event(
+        self, event_name: str, metrics: Dict[str, Any], **kwargs
+    ):
         """記錄業務事件"""
         self.info(
             f"Business event: {event_name}",
@@ -407,10 +460,17 @@ class StructuredLogger:
         **kwargs,
     ):
         """記錄審計事件"""
-        audit_data = {"action": action, "resource": resource, "details": details or {}}
+        audit_data = {
+            "action": action,
+            "resource": resource,
+            "details": details or {},
+        }
 
         self.info(
-            f"Audit: {action} on {resource}", event_type=EventType.AUDIT, extra=audit_data, **kwargs
+            f"Audit: {action} on {resource}",
+            event_type=EventType.AUDIT,
+            extra=audit_data,
+            **kwargs,
         )
 
 
@@ -419,7 +479,10 @@ _global_loggers: Dict[str, StructuredLogger] = {}
 
 
 def get_logger(
-    service_name: str, version: str = "1.0.0", environment: str = None, **kwargs
+    service_name: str,
+    version: str = "1.0.0",
+    environment: str = None,
+    **kwargs,
 ) -> StructuredLogger:
     """獲取或創建日誌記錄器"""
     environment = environment or os.getenv("ENVIRONMENT", "production")
@@ -428,7 +491,10 @@ def get_logger(
 
     if logger_key not in _global_loggers:
         _global_loggers[logger_key] = StructuredLogger(
-            service_name=service_name, version=version, environment=environment, **kwargs
+            service_name=service_name,
+            version=version,
+            environment=environment,
+            **kwargs,
         )
 
     return _global_loggers[logger_key]
@@ -438,7 +504,13 @@ def get_logger(
 class LogContext:
     """日誌上下文管理器"""
 
-    def __init__(self, request_id: str = None, user_id: str = None, trace_id: str = None, correlation_id: str = None):
+    def __init__(
+        self,
+        request_id: str = None,
+        user_id: str = None,
+        trace_id: str = None,
+        correlation_id: str = None,
+    ):
         self.request_id = request_id
         self.user_id = user_id
         self.trace_id = trace_id
@@ -463,7 +535,9 @@ class LogContext:
 
 # 裝飾器
 def log_function_call(
-    logger: StructuredLogger = None, include_args: bool = False, include_result: bool = False
+    logger: StructuredLogger = None,
+    include_args: bool = False,
+    include_result: bool = False,
 ):
     """函數調用日誌裝飾器"""
 
@@ -494,7 +568,9 @@ def log_function_call(
                 if include_result:
                     log_data["result"] = str(result)
 
-                logger.debug(f"Function completed: {func_name}", extra=log_data)
+                logger.debug(
+                    f"Function completed: {func_name}", extra=log_data
+                )
                 return result
 
             except Exception as e:
@@ -530,7 +606,9 @@ def log_function_call(
                 if include_result:
                     log_data["result"] = str(result)
 
-                logger.debug(f"Function completed: {func_name}", extra=log_data)
+                logger.debug(
+                    f"Function completed: {func_name}", extra=log_data
+                )
                 return result
 
             except Exception as e:
diff --git a/auto_generate_video_fold6/monitoring/metrics/optimized_metrics_collector.py b/auto_generate_video_fold6/monitoring/metrics/optimized_metrics_collector.py
index 249ad08..5e6c9c7 100644
--- a/auto_generate_video_fold6/monitoring/metrics/optimized_metrics_collector.py
+++ b/auto_generate_video_fold6/monitoring/metrics/optimized_metrics_collector.py
@@ -16,60 +16,70 @@ import statistics
 import asyncio
 from concurrent.futures import ThreadPoolExecutor
 
+
 class MetricType(Enum):
     """指標類型"""
+
     COUNTER = "counter"
     GAUGE = "gauge"
     HISTOGRAM = "histogram"
     SUMMARY = "summary"
 
+
 @dataclass
 class MetricEntry:
     """高效能指標條目"""
+
     name: str
     value: Union[int, float]
     labels: Dict[str, str]
     timestamp: float
     metric_type: MetricType
 
+
 class OptimizedMetricsCollector:
     """優化的指標收集器"""
-    
-    def __init__(self, 
-                 buffer_size: int = 10000,
-                 flush_interval: float = 5.0,
-                 enable_sampling: bool = True,
-                 sampling_rate: float = 0.1):
+
+    def __init__(
+        self,
+        buffer_size: int = 10000,
+        flush_interval: float = 5.0,
+        enable_sampling: bool = True,
+        sampling_rate: float = 0.1,
+    ):
         self.buffer_size = buffer_size
         self.flush_interval = flush_interval
         self.enable_sampling = enable_sampling
         self.sampling_rate = sampling_rate
-        
+
         # 高效能緩衝區
         self.metrics_buffer = deque(maxlen=buffer_size)
         self.buffer_lock = threading.RLock()
-        
+
         # 聚合指標快取
         self.aggregated_metrics = defaultdict(list)
         self.last_aggregation = time.time()
-        
+
         # 效能統計
         self.performance_stats = {
             "metrics_processed": 0,
             "buffer_flushes": 0,
             "processing_time_ms": 0.0,
             "last_flush_time": time.time(),
-            "buffer_utilization": 0.0
+            "buffer_utilization": 0.0,
         }
-        
+
         # 異步處理器
-        self.executor = ThreadPoolExecutor(max_workers=2, thread_name_prefix="metrics")
-        
+        self.executor = ThreadPoolExecutor(
+            max_workers=2, thread_name_prefix="metrics"
+        )
+
         # 開始後台處理
         self._start_background_processing()
-    
+
     def _start_background_processing(self):
         """開始後台指標處理"""
+
         def background_worker():
             while True:
                 try:
@@ -78,139 +88,159 @@ class OptimizedMetricsCollector:
                     self._aggregate_metrics()
                 except Exception as e:
                     print(f"Background metrics processing error: {e}")
-        
+
         worker_thread = threading.Thread(target=background_worker, daemon=True)
         worker_thread.start()
-    
-    def record_metric(self, 
-                     name: str, 
-                     value: Union[int, float], 
-                     labels: Optional[Dict[str, str]] = None,
-                     metric_type: MetricType = MetricType.GAUGE) -> bool:
+
+    def record_metric(
+        self,
+        name: str,
+        value: Union[int, float],
+        labels: Optional[Dict[str, str]] = None,
+        metric_type: MetricType = MetricType.GAUGE,
+    ) -> bool:
         """高效能指標記錄"""
         start_time = time.perf_counter()
-        
+
         # 採樣優化
         if self.enable_sampling and metric_type != MetricType.COUNTER:
             import random
+
             if random.random() > self.sampling_rate:
                 return False
-        
+
         # 創建指標條目
         entry = MetricEntry(
             name=name,
             value=value,
             labels=labels or {},
             timestamp=time.time(),
-            metric_type=metric_type
+            metric_type=metric_type,
         )
-        
+
         # 線程安全地添加到緩衝區
         with self.buffer_lock:
             self.metrics_buffer.append(entry)
-            
+
             # 更新統計
             self.performance_stats["metrics_processed"] += 1
             processing_time = (time.perf_counter() - start_time) * 1000
             self.performance_stats["processing_time_ms"] += processing_time
-            
+
             # 檢查是否需要立即刷新
             if len(self.metrics_buffer) >= self.buffer_size * 0.9:
                 self.executor.submit(self._flush_metrics)
-        
+
         return True
-    
+
     def _flush_metrics(self):
         """刷新指標緩衝區"""
         with self.buffer_lock:
             if not self.metrics_buffer:
                 return
-            
+
             # 複製緩衝區內容
             metrics_to_flush = list(self.metrics_buffer)
             self.metrics_buffer.clear()
-        
+
         # 批量處理指標
         self._process_metrics_batch(metrics_to_flush)
-        
+
         # 更新統計
         self.performance_stats["buffer_flushes"] += 1
         self.performance_stats["last_flush_time"] = time.time()
-    
+
     def _process_metrics_batch(self, metrics: List[MetricEntry]):
         """批量處理指標"""
         start_time = time.perf_counter()
-        
+
         # 按指標名稱分組
         grouped_metrics = defaultdict(list)
         for metric in metrics:
             grouped_metrics[metric.name].append(metric)
-        
+
         # 處理每組指標
         for name, metric_group in grouped_metrics.items():
             self._process_metric_group(name, metric_group)
-        
+
         processing_time = (time.perf_counter() - start_time) * 1000
         print(f"Processed {len(metrics)} metrics in {processing_time:.2f}ms")
-    
+
     def _process_metric_group(self, name: str, metrics: List[MetricEntry]):
         """處理單個指標組"""
         if not metrics:
             return
-        
+
         first_metric = metrics[0]
-        
+
         if first_metric.metric_type == MetricType.COUNTER:
             # 計數器：累加值
             total_value = sum(m.value for m in metrics)
-            self._emit_metric(name, total_value, first_metric.labels, "counter")
-            
+            self._emit_metric(
+                name, total_value, first_metric.labels, "counter"
+            )
+
         elif first_metric.metric_type == MetricType.GAUGE:
             # 測量器：使用最新值
             latest_metric = max(metrics, key=lambda m: m.timestamp)
-            self._emit_metric(name, latest_metric.value, latest_metric.labels, "gauge")
-            
+            self._emit_metric(
+                name, latest_metric.value, latest_metric.labels, "gauge"
+            )
+
         elif first_metric.metric_type == MetricType.HISTOGRAM:
             # 直方圖：統計分佈
-            values = [m.value for m in metrics] 
+            values = [m.value for m in metrics]
             histogram_data = self._calculate_histogram(values)
             self._emit_histogram(name, histogram_data, first_metric.labels)
-            
+
         elif first_metric.metric_type == MetricType.SUMMARY:
             # 摘要：計算分位數
             values = [m.value for m in metrics]
             summary_data = self._calculate_summary(values)
             self._emit_summary(name, summary_data, first_metric.labels)
-    
+
     def _calculate_histogram(self, values: List[float]) -> Dict[str, Any]:
         """計算直方圖統計"""
         if not values:
             return {}
-        
+
         # 定義桶邊界
-        buckets = [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0, float('inf')]
+        buckets = [
+            0.005,
+            0.01,
+            0.025,
+            0.05,
+            0.1,
+            0.25,
+            0.5,
+            1.0,
+            2.5,
+            5.0,
+            10.0,
+            float("inf"),
+        ]
         bucket_counts = [0] * len(buckets)
-        
+
         # 計算每個桶的計數
         for value in values:
             for i, bucket in enumerate(buckets):
                 if value <= bucket:
                     bucket_counts[i] += 1
-        
+
         return {
             "count": len(values),
             "sum": sum(values),
-            "buckets": dict(zip([str(b) for b in buckets], bucket_counts))
+            "buckets": dict(zip([str(b) for b in buckets], bucket_counts)),
         }
-    
+
     def _calculate_summary(self, values: List[float]) -> Dict[str, Any]:
         """計算摘要統計"""
         if not values:
             return {}
-        
+
         sorted_values = sorted(values)
         count = len(sorted_values)
-        
+
         return {
             "count": count,
             "sum": sum(values),
@@ -218,175 +248,237 @@ class OptimizedMetricsCollector:
                 "0.5": sorted_values[int(count * 0.5)],
                 "0.9": sorted_values[int(count * 0.9)],
                 "0.95": sorted_values[int(count * 0.95)],
-                "0.99": sorted_values[int(count * 0.99)] if count > 1 else sorted_values[0]
-            }
+                "0.99": sorted_values[int(count * 0.99)]
+                if count > 1
+                else sorted_values[0],
+            },
         }
-    
-    def _emit_metric(self, name: str, value: Union[int, float], labels: Dict[str, str], metric_type: str):
+
+    def _emit_metric(
+        self,
+        name: str,
+        value: Union[int, float],
+        labels: Dict[str, str],
+        metric_type: str,
+    ):
         """輸出 Prometheus 格式指標"""
-        labels_str = ",".join([f'{k}="{v}"' for k, v in labels.items()]) if labels else ""
+        labels_str = (
+            ",".join([f'{k}="{v}"' for k, v in labels.items()])
+            if labels
+            else ""
+        )
         labels_part = f"{{{labels_str}}}" if labels_str else ""
-        
+
         # 輸出 Prometheus 格式
         print(f"# TYPE {name} {metric_type}")
         print(f"{name}{labels_part} {value} {int(time.time() * 1000)}")
-    
-    def _emit_histogram(self, name: str, histogram_data: Dict[str, Any], labels: Dict[str, str]):
+
+    def _emit_histogram(
+        self, name: str, histogram_data: Dict[str, Any], labels: Dict[str, str]
+    ):
         """輸出直方圖指標"""
-        labels_str = ",".join([f'{k}="{v}"' for k, v in labels.items()]) if labels else ""
+        labels_str = (
+            ",".join([f'{k}="{v}"' for k, v in labels.items()])
+            if labels
+            else ""
+        )
         base_labels = f"{{{labels_str}}}" if labels_str else ""
-        
+
         print(f"# TYPE {name} histogram")
-        
+
         # 輸出桶計數
         for bucket, count in histogram_data["buckets"].items():
-            bucket_labels = f"{{{labels_str},le=\"{bucket}\"}}" if labels_str else f'{{le="{bucket}"}}'
+            bucket_labels = (
+                f'{{{labels_str},le="{bucket}"}}'
+                if labels_str
+                else f'{{le="{bucket}"}}'
+            )
             print(f"{name}_bucket{bucket_labels} {count}")
-        
+
         # 輸出總計數和總和
         print(f"{name}_count{base_labels} {histogram_data['count']}")
         print(f"{name}_sum{base_labels} {histogram_data['sum']}")
-    
-    def _emit_summary(self, name: str, summary_data: Dict[str, Any], labels: Dict[str, str]):
+
+    def _emit_summary(
+        self, name: str, summary_data: Dict[str, Any], labels: Dict[str, str]
+    ):
         """輸出摘要指標"""
-        labels_str = ",".join([f'{k}="{v}"' for k, v in labels.items()]) if labels else ""
+        labels_str = (
+            ",".join([f'{k}="{v}"' for k, v in labels.items()])
+            if labels
+            else ""
+        )
         base_labels = f"{{{labels_str}}}" if labels_str else ""
-        
+
         print(f"# TYPE {name} summary")
-        
+
         # 輸出分位數
         for quantile, value in summary_data["quantiles"].items():
-            quantile_labels = f"{{{labels_str},quantile=\"{quantile}\"}}" if labels_str else f'{{quantile="{quantile}"}}'
+            quantile_labels = (
+                f'{{{labels_str},quantile="{quantile}"}}'
+                if labels_str
+                else f'{{quantile="{quantile}"}}'
+            )
             print(f"{name}{quantile_labels} {value}")
-        
+
         # 輸出總計數和總和
         print(f"{name}_count{base_labels} {summary_data['count']}")
         print(f"{name}_sum{base_labels} {summary_data['sum']}")
-    
+
     def _aggregate_metrics(self):
         """聚合指標以提高查詢效能"""
         current_time = time.time()
-        
+
         # 每分鐘執行一次聚合
         if current_time - self.last_aggregation < 60:
             return
-        
+
         with self.buffer_lock:
             # 這裡可以實作更複雜的聚合邏輯
             # 例如：預計算常用查詢的結果
             self.last_aggregation = current_time
-    
+
     def get_performance_stats(self) -> Dict[str, Any]:
         """獲取效能統計"""
         with self.buffer_lock:
             current_utilization = len(self.metrics_buffer) / self.buffer_size
             self.performance_stats["buffer_utilization"] = current_utilization
-            
+
             stats = self.performance_stats.copy()
-            
+
             # 計算平均處理時間
             if stats["metrics_processed"] > 0:
                 stats["avg_processing_time_ms"] = (
                     stats["processing_time_ms"] / stats["metrics_processed"]
                 )
-            
+
             return stats
-    
+
     def collect_metrics(self) -> Dict[str, Any]:
         """收集所有指標統計"""
         return {
             "timestamp": datetime.utcnow().isoformat(),
             "performance": self.get_performance_stats(),
             "buffer_size": len(self.metrics_buffer),
-            "aggregated_metrics_count": len(self.aggregated_metrics)
+            "aggregated_metrics_count": len(self.aggregated_metrics),
         }
-    
+
     # 便捷方法
-    def increment_counter(self, name: str, value: Union[int, float] = 1, labels: Optional[Dict[str, str]] = None):
+    def increment_counter(
+        self,
+        name: str,
+        value: Union[int, float] = 1,
+        labels: Optional[Dict[str, str]] = None,
+    ):
         """增加計數器"""
         return self.record_metric(name, value, labels, MetricType.COUNTER)
-    
-    def set_gauge(self, name: str, value: Union[int, float], labels: Optional[Dict[str, str]] = None):
+
+    def set_gauge(
+        self,
+        name: str,
+        value: Union[int, float],
+        labels: Optional[Dict[str, str]] = None,
+    ):
         """設定測量器值"""
         return self.record_metric(name, value, labels, MetricType.GAUGE)
-    
-    def observe_histogram(self, name: str, value: Union[int, float], labels: Optional[Dict[str, str]] = None):
+
+    def observe_histogram(
+        self,
+        name: str,
+        value: Union[int, float],
+        labels: Optional[Dict[str, str]] = None,
+    ):
         """觀察直方圖值"""
         return self.record_metric(name, value, labels, MetricType.HISTOGRAM)
-    
-    def observe_summary(self, name: str, value: Union[int, float], labels: Optional[Dict[str, str]] = None):
+
+    def observe_summary(
+        self,
+        name: str,
+        value: Union[int, float],
+        labels: Optional[Dict[str, str]] = None,
+    ):
         """觀察摘要值"""
         return self.record_metric(name, value, labels, MetricType.SUMMARY)
 
+
 # 高效能業務指標管理器
 class BusinessMetricsManager:
     """業務指標管理器"""
-    
+
     def __init__(self):
         self.collector = OptimizedMetricsCollector(
             buffer_size=5000,
             flush_interval=10.0,
-            sampling_rate=0.2  # 業務指標採樣率較高
+            sampling_rate=0.2,  # 業務指標採樣率較高
         )
-        
+
         # 預定義業務指標
         self.business_metrics_definitions = {
             "video_generation_count": {
                 "type": MetricType.COUNTER,
                 "description": "Total video generations",
-                "labels": ["status", "platform", "user_tier"]
+                "labels": ["status", "platform", "user_tier"],
             },
             "user_engagement_rate": {
                 "type": MetricType.GAUGE,
                 "description": "User engagement rate",
-                "labels": ["platform", "content_type"]
+                "labels": ["platform", "content_type"],
             },
             "processing_duration": {
                 "type": MetricType.HISTOGRAM,
                 "description": "Processing time distribution",
-                "labels": ["operation", "service"]
+                "labels": ["operation", "service"],
             },
             "api_response_time": {
                 "type": MetricType.SUMMARY,
                 "description": "API response time summary",
-                "labels": ["endpoint", "method", "status_code"]
-            }
+                "labels": ["endpoint", "method", "status_code"],
+            },
         }
-    
-    def record_video_generation(self, status: str, platform: str, user_tier: str = "free"):
+
+    def record_video_generation(
+        self, status: str, platform: str, user_tier: str = "free"
+    ):
         """記錄影片生成指標"""
         return self.collector.increment_counter(
             "video_generation_count",
             labels={
                 "status": status,
                 "platform": platform,
-                "user_tier": user_tier
-            }
+                "user_tier": user_tier,
+            },
         )
-    
-    def record_user_engagement(self, platform: str, engagement_rate: float, content_type: str = "video"):
+
+    def record_user_engagement(
+        self,
+        platform: str,
+        engagement_rate: float,
+        content_type: str = "video",
+    ):
         """記錄用戶參與度"""
         return self.collector.set_gauge(
             "user_engagement_rate",
             engagement_rate,
-            labels={
-                "platform": platform,
-                "content_type": content_type
-            }
+            labels={"platform": platform, "content_type": content_type},
         )
-    
-    def record_processing_time(self, operation: str, service: str, duration_ms: float):
+
+    def record_processing_time(
+        self, operation: str, service: str, duration_ms: float
+    ):
         """記錄處理時間"""
         return self.collector.observe_histogram(
             "processing_duration",
             duration_ms / 1000,  # 轉換為秒
-            labels={
-                "operation": operation,
-                "service": service
-            }
+            labels={"operation": operation, "service": service},
         )
-    
-    def record_api_response_time(self, endpoint: str, method: str, status_code: int, response_time_ms: float):
+
+    def record_api_response_time(
+        self,
+        endpoint: str,
+        method: str,
+        status_code: int,
+        response_time_ms: float,
+    ):
         """記錄 API 回應時間"""
         return self.collector.observe_summary(
             "api_response_time",
@@ -394,81 +486,104 @@ class BusinessMetricsManager:
             labels={
                 "endpoint": endpoint,
                 "method": method,
-                "status_code": str(status_code)
-            }
+                "status_code": str(status_code),
+            },
         )
-    
+
     def get_business_metrics_summary(self) -> Dict[str, Any]:
         """獲取業務指標摘要"""
         return self.collector.collect_metrics()
 
+
 # 全域實例
 optimized_collector = OptimizedMetricsCollector()
 business_metrics_manager = BusinessMetricsManager()
 
+
 # 效能測量裝飾器
-def measure_execution_time(metric_name: str = None, labels: Dict[str, str] = None):
+def measure_execution_time(
+    metric_name: str = None, labels: Dict[str, str] = None
+):
     """測量函數執行時間的裝飾器"""
+
     def decorator(func):
         from functools import wraps
-        
+
         @wraps(func)
         async def async_wrapper(*args, **kwargs):
             name = metric_name or f"{func.__module__}.{func.__name__}"
             start_time = time.perf_counter()
-            
+
             try:
                 result = await func(*args, **kwargs)
                 duration_ms = (time.perf_counter() - start_time) * 1000
-                
+
                 optimized_collector.observe_histogram(
                     f"function_execution_time",
                     duration_ms / 1000,
-                    labels={**(labels or {}), "function": name, "status": "success"}
+                    labels={
+                        **(labels or {}),
+                        "function": name,
+                        "status": "success",
+                    },
                 )
-                
+
                 return result
-                
+
             except Exception as e:
                 duration_ms = (time.perf_counter() - start_time) * 1000
-                
+
                 optimized_collector.observe_histogram(
                     f"function_execution_time",
                     duration_ms / 1000,
-                    labels={**(labels or {}), "function": name, "status": "error", "error_type": type(e).__name__}
+                    labels={
+                        **(labels or {}),
+                        "function": name,
+                        "status": "error",
+                        "error_type": type(e).__name__,
+                    },
                 )
                 raise
-        
+
         @wraps(func)
         def sync_wrapper(*args, **kwargs):
             name = metric_name or f"{func.__module__}.{func.__name__}"
             start_time = time.perf_counter()
-            
+
             try:
                 result = func(*args, **kwargs)
                 duration_ms = (time.perf_counter() - start_time) * 1000
-                
+
                 optimized_collector.observe_histogram(
                     f"function_execution_time",
                     duration_ms / 1000,
-                    labels={**(labels or {}), "function": name, "status": "success"}
+                    labels={
+                        **(labels or {}),
+                        "function": name,
+                        "status": "success",
+                    },
                 )
-                
+
                 return result
-                
+
             except Exception as e:
                 duration_ms = (time.perf_counter() - start_time) * 1000
-                
+
                 optimized_collector.observe_histogram(
                     f"function_execution_time",
                     duration_ms / 1000,
-                    labels={**(labels or {}), "function": name, "status": "error", "error_type": type(e).__name__}
+                    labels={
+                        **(labels or {}),
+                        "function": name,
+                        "status": "error",
+                        "error_type": type(e).__name__,
+                    },
                 )
                 raise
-        
+
         if asyncio.iscoroutinefunction(func):
             return async_wrapper
         else:
             return sync_wrapper
-    
-    return decorator
\ No newline at end of file
+
+    return decorator
diff --git a/auto_generate_video_fold6/monitoring/middleware/correlation_middleware.py b/auto_generate_video_fold6/monitoring/middleware/correlation_middleware.py
index 49dc0aa..8088adc 100644
--- a/auto_generate_video_fold6/monitoring/middleware/correlation_middleware.py
+++ b/auto_generate_video_fold6/monitoring/middleware/correlation_middleware.py
@@ -14,55 +14,72 @@ from datetime import datetime
 # 使用相對導入的替代方案
 import os
 import sys
+
 sys.path.append(os.path.dirname(os.path.dirname(__file__)))
 
 try:
-    from logging.performance_logger import get_performance_logger, set_correlation_id, set_request_id
+    from logging.performance_logger import (
+        get_performance_logger,
+        set_correlation_id,
+        set_request_id,
+    )
+
     logger = get_performance_logger(__name__)
 except ImportError:
     import logging
+
     logger = logging.getLogger(__name__)
+
     # 定義替代函數
     def set_correlation_id(correlation_id: str):
         pass
+
     def set_request_id(request_id: str):
         pass
 
+
 # 全域上下文變數
-correlation_id_context: ContextVar[Optional[str]] = ContextVar("correlation_id", default=None)
-trace_id_context: ContextVar[Optional[str]] = ContextVar("trace_id", default=None)
-span_id_context: ContextVar[Optional[str]] = ContextVar("span_id", default=None)
+correlation_id_context: ContextVar[Optional[str]] = ContextVar(
+    "correlation_id", default=None
+)
+trace_id_context: ContextVar[Optional[str]] = ContextVar(
+    "trace_id", default=None
+)
+span_id_context: ContextVar[Optional[str]] = ContextVar(
+    "span_id", default=None
+)
+
 
 class CorrelationMiddleware:
     """關聯ID和分佈式追踪中間件"""
-    
+
     def __init__(self, app, service_name: str = "unknown"):
         self.app = app
         self.service_name = service_name
         self.logger = get_logger(f"{service_name}.correlation")
-    
+
     async def __call__(self, scope, receive, send):
         if scope["type"] != "http":
             await self.app(scope, receive, send)
             return
-        
+
         # 提取或生成關聯ID
         headers = dict(scope.get("headers", []))
         correlation_id = self._extract_correlation_id(headers)
         trace_id = self._extract_trace_id(headers)
         span_id = self._generate_span_id()
         request_id = self._extract_request_id(headers)
-        
+
         # 設定上下文
         correlation_id_context.set(correlation_id)
         trace_id_context.set(trace_id)
         span_id_context.set(span_id)
-        
+
         # 設定結構化日誌上下文
         set_correlation_id(correlation_id)
         if request_id:
             set_request_id(request_id)
-        
+
         # 記錄請求開始
         start_time = time.time()
         self.logger.info(
@@ -75,27 +92,31 @@ class CorrelationMiddleware:
             method=scope["method"],
             path=scope["path"],
             user_agent=headers.get(b"user-agent", b"").decode(),
-            client_ip=self._get_client_ip(scope, headers)
+            client_ip=self._get_client_ip(scope, headers),
         )
-        
+
         # 包裝 send 以添加關聯頭部
         async def send_wrapper(message):
             if message["type"] == "http.response.start":
                 # 添加關聯頭部到回應
                 response_headers = list(message.get("headers", []))
-                response_headers.extend([
-                    [b"x-correlation-id", correlation_id.encode()],
-                    [b"x-trace-id", trace_id.encode()],
-                    [b"x-span-id", span_id.encode()],
-                ])
-                
+                response_headers.extend(
+                    [
+                        [b"x-correlation-id", correlation_id.encode()],
+                        [b"x-trace-id", trace_id.encode()],
+                        [b"x-span-id", span_id.encode()],
+                    ]
+                )
+
                 if request_id:
-                    response_headers.append([b"x-request-id", request_id.encode()])
-                
+                    response_headers.append(
+                        [b"x-request-id", request_id.encode()]
+                    )
+
                 message["headers"] = response_headers
-            
+
             await send(message)
-        
+
         try:
             await self.app(scope, receive, send_wrapper)
         except Exception as e:
@@ -107,7 +128,7 @@ class CorrelationMiddleware:
                 span_id=span_id,
                 request_id=request_id,
                 exception=e,
-                duration_ms=(time.time() - start_time) * 1000
+                duration_ms=(time.time() - start_time) * 1000,
             )
             raise
         finally:
@@ -119,9 +140,9 @@ class CorrelationMiddleware:
                 trace_id=trace_id,
                 span_id=span_id,
                 request_id=request_id,
-                duration_ms=duration * 1000
+                duration_ms=duration * 1000,
             )
-    
+
     def _extract_correlation_id(self, headers: Dict[bytes, bytes]) -> str:
         """提取或生成關聯ID"""
         # 檢查多種可能的頭部名稱
@@ -130,18 +151,18 @@ class CorrelationMiddleware:
             b"x-correlation-id",
             b"correlation-id",
             b"x-request-id",
-            b"request-id"
+            b"request-id",
         ]
-        
+
         for header_name in correlation_headers:
             if header_name in headers:
                 correlation_id = headers[header_name].decode()
                 if correlation_id and len(correlation_id) > 0:
                     return correlation_id
-        
+
         # 生成新的關聯ID
         return str(uuid.uuid4())
-    
+
     def _extract_trace_id(self, headers: Dict[bytes, bytes]) -> str:
         """提取或生成追踪ID"""
         # 檢查分佈式追踪頭部
@@ -149,9 +170,9 @@ class CorrelationMiddleware:
             b"x-trace-id",
             b"trace-id",
             b"x-b3-traceid",  # Zipkin B3
-            b"traceparent",   # W3C Trace Context
+            b"traceparent",  # W3C Trace Context
         ]
-        
+
         for header_name in trace_headers:
             if header_name in headers:
                 trace_value = headers[header_name].decode()
@@ -162,39 +183,40 @@ class CorrelationMiddleware:
                         if len(parts) >= 2:
                             return parts[1]
                     return trace_value
-        
+
         # 生成新的追踪ID
         return str(uuid.uuid4()).replace("-", "")[:16]
-    
-    def _extract_request_id(self, headers: Dict[bytes, bytes]) -> Optional[str]:
+
+    def _extract_request_id(
+        self, headers: Dict[bytes, bytes]
+    ) -> Optional[str]:
         """提取請求ID"""
-        request_id_headers = [
-            b"x-request-id",
-            b"request-id"
-        ]
-        
+        request_id_headers = [b"x-request-id", b"request-id"]
+
         for header_name in request_id_headers:
             if header_name in headers:
                 request_id = headers[header_name].decode()
                 if request_id and len(request_id) > 0:
                     return request_id
-        
+
         return None
-    
+
     def _generate_span_id(self) -> str:
         """生成新的 Span ID"""
         return str(uuid.uuid4()).replace("-", "")[:8]
-    
-    def _get_client_ip(self, scope: Dict[str, Any], headers: Dict[bytes, bytes]) -> str:
+
+    def _get_client_ip(
+        self, scope: Dict[str, Any], headers: Dict[bytes, bytes]
+    ) -> str:
         """獲取客戶端IP地址"""
         # 檢查代理頭部
         proxy_headers = [
             b"x-forwarded-for",
             b"x-real-ip",
             b"x-client-ip",
-            b"cf-connecting-ip"  # Cloudflare
+            b"cf-connecting-ip",  # Cloudflare
         ]
-        
+
         for header_name in proxy_headers:
             if header_name in headers:
                 ip_value = headers[header_name].decode()
@@ -203,32 +225,33 @@ class CorrelationMiddleware:
                     if "," in ip_value:
                         ip_value = ip_value.split(",")[0].strip()
                     return ip_value
-        
+
         # 從 scope 獲取客戶端地址
         client = scope.get("client")
         if client:
             return client[0]
-        
+
         return "unknown"
 
+
 class DistributedTracingContext:
     """分佈式追踪上下文管理器"""
-    
+
     def __init__(self, operation_name: str, service_name: str = "unknown"):
         self.operation_name = operation_name
         self.service_name = service_name
         self.start_time = None
         self.span_id = None
         self.parent_span_id = None
-        
+
     def __enter__(self):
         self.start_time = time.time()
         self.parent_span_id = span_id_context.get()
         self.span_id = str(uuid.uuid4()).replace("-", "")[:8]
-        
+
         # 設定新的 span context
         span_id_context.set(self.span_id)
-        
+
         # 記錄 span 開始
         logger.info(
             f"Span started: {self.operation_name}",
@@ -237,14 +260,14 @@ class DistributedTracingContext:
             span_id=self.span_id,
             parent_span_id=self.parent_span_id,
             service=self.service_name,
-            operation=self.operation_name
+            operation=self.operation_name,
         )
-        
+
         return self
-    
+
     def __exit__(self, exc_type, exc_val, exc_tb):
         duration = time.time() - self.start_time
-        
+
         # 記錄 span 結束
         if exc_type is None:
             logger.info(
@@ -256,7 +279,7 @@ class DistributedTracingContext:
                 service=self.service_name,
                 operation=self.operation_name,
                 duration_ms=duration * 1000,
-                status="success"
+                status="success",
             )
         else:
             logger.error(
@@ -269,58 +292,69 @@ class DistributedTracingContext:
                 operation=self.operation_name,
                 duration_ms=duration * 1000,
                 status="error",
-                exception=exc_val
+                exception=exc_val,
             )
-        
+
         # 恢復父 span context
         span_id_context.set(self.parent_span_id)
 
+
 # 便捷函數
 def get_correlation_id() -> Optional[str]:
     """獲取當前關聯ID"""
     return correlation_id_context.get()
 
+
 def get_trace_id() -> Optional[str]:
     """獲取當前追踪ID"""
     return trace_id_context.get()
 
+
 def get_span_id() -> Optional[str]:
     """獲取當前 Span ID"""
     return span_id_context.get()
 
+
 def create_child_span(operation_name: str, service_name: str = "unknown"):
     """創建子 Span 上下文管理器"""
     return DistributedTracingContext(operation_name, service_name)
 
-def trace_function(operation_name: Optional[str] = None, service_name: str = "unknown"):
+
+def trace_function(
+    operation_name: Optional[str] = None, service_name: str = "unknown"
+):
     """函數追踪裝飾器"""
+
     def decorator(func):
         from functools import wraps
         import asyncio
-        
-        actual_operation_name = operation_name or f"{func.__module__}.{func.__name__}"
-        
+
+        actual_operation_name = (
+            operation_name or f"{func.__module__}.{func.__name__}"
+        )
+
         @wraps(func)
         async def async_wrapper(*args, **kwargs):
             with create_child_span(actual_operation_name, service_name):
                 return await func(*args, **kwargs)
-        
+
         @wraps(func)
         def sync_wrapper(*args, **kwargs):
             with create_child_span(actual_operation_name, service_name):
                 return func(*args, **kwargs)
-        
+
         if asyncio.iscoroutinefunction(func):
             return async_wrapper
         else:
             return sync_wrapper
-    
+
     return decorator
 
+
 # 分佈式追踪輔助類別
 class TraceEvent:
     """追踪事件"""
-    
+
     def __init__(self, event_name: str, **attributes):
         self.event_name = event_name
         self.timestamp = datetime.utcnow()
@@ -328,7 +362,7 @@ class TraceEvent:
         self.correlation_id = get_correlation_id()
         self.trace_id = get_trace_id()
         self.span_id = get_span_id()
-    
+
     def log_event(self):
         """記錄追踪事件"""
         logger.info(
@@ -338,11 +372,12 @@ class TraceEvent:
             span_id=self.span_id,
             event_name=self.event_name,
             timestamp=self.timestamp.isoformat(),
-            **self.attributes
+            **self.attributes,
         )
 
+
 def log_trace_event(event_name: str, **attributes):
     """記錄追踪事件的便捷函數"""
     event = TraceEvent(event_name, **attributes)
     event.log_event()
-    return event
\ No newline at end of file
+    return event
diff --git a/auto_generate_video_fold6/monitoring/middleware/health_check_middleware.py b/auto_generate_video_fold6/monitoring/middleware/health_check_middleware.py
index 767ebce..fb1e588 100644
--- a/auto_generate_video_fold6/monitoring/middleware/health_check_middleware.py
+++ b/auto_generate_video_fold6/monitoring/middleware/health_check_middleware.py
@@ -16,12 +16,14 @@ from enum import Enum
 # Database connectivity checks
 try:
     import psycopg2
+
     POSTGRES_AVAILABLE = True
 except ImportError:
     POSTGRES_AVAILABLE = False
 
 try:
     import redis
+
     REDIS_AVAILABLE = True
 except ImportError:
     REDIS_AVAILABLE = False
@@ -30,35 +32,41 @@ from ..logging.structured_logger import get_logger
 
 logger = get_logger(__name__)
 
+
 class HealthStatus(Enum):
     """健康狀態枚舉"""
+
     HEALTHY = "healthy"
     DEGRADED = "degraded"
     UNHEALTHY = "unhealthy"
 
+
 @dataclass
 class HealthCheckResult:
     """健康檢查結果"""
+
     name: str
     status: HealthStatus
     timestamp: datetime
     duration_ms: float
     message: str = ""
     details: Dict[str, Any] = None
-    
+
     def __post_init__(self):
         if self.details is None:
             self.details = {}
 
+
 @dataclass
 class SystemHealth:
     """系統整體健康狀態"""
+
     status: HealthStatus
     timestamp: datetime
     checks: List[HealthCheckResult]
     uptime_seconds: float
     version: str = "1.0.0"
-    
+
     def to_dict(self) -> Dict[str, Any]:
         """轉換為字典格式"""
         return {
@@ -72,27 +80,27 @@ class SystemHealth:
                     "timestamp": check.timestamp.isoformat(),
                     "duration_ms": check.duration_ms,
                     "message": check.message,
-                    "details": check.details
+                    "details": check.details,
                 }
                 for check in self.checks
-            }
+            },
         }
 
+
 class HealthChecker:
     """健康檢查執行器"""
-    
+
     def __init__(self):
         self.start_time = time.time()
         self.checks: Dict[str, Callable] = {}
         self.last_results: Dict[str, HealthCheckResult] = {}
-        
-    def register_check(self, name: str, check_func: Callable, timeout: float = 5.0):
+
+    def register_check(
+        self, name: str, check_func: Callable, timeout: float = 5.0
+    ):
         """註冊健康檢查函數"""
-        self.checks[name] = {
-            'func': check_func,
-            'timeout': timeout
-        }
-        
+        self.checks[name] = {"func": check_func, "timeout": timeout}
+
     async def run_check(self, name: str) -> HealthCheckResult:
         """執行單個健康檢查"""
         if name not in self.checks:
@@ -101,31 +109,32 @@ class HealthChecker:
                 status=HealthStatus.UNHEALTHY,
                 timestamp=datetime.utcnow(),
                 duration_ms=0,
-                message=f"Check '{name}' not registered"
+                message=f"Check '{name}' not registered",
             )
-        
+
         check_config = self.checks[name]
         start_time = time.time()
-        
+
         try:
             # 執行健康檢查，帶超時控制
             result = await asyncio.wait_for(
-                check_config['func'](),
-                timeout=check_config['timeout']
+                check_config["func"](), timeout=check_config["timeout"]
             )
-            
+
             duration_ms = (time.time() - start_time) * 1000
-            
+
             if isinstance(result, HealthCheckResult):
                 result.duration_ms = duration_ms
                 return result
             elif isinstance(result, bool):
                 return HealthCheckResult(
                     name=name,
-                    status=HealthStatus.HEALTHY if result else HealthStatus.UNHEALTHY,
+                    status=HealthStatus.HEALTHY
+                    if result
+                    else HealthStatus.UNHEALTHY,
                     timestamp=datetime.utcnow(),
                     duration_ms=duration_ms,
-                    message="OK" if result else "Check failed"
+                    message="OK" if result else "Check failed",
                 )
             else:  # Assume dict or other data
                 return HealthCheckResult(
@@ -134,9 +143,11 @@ class HealthChecker:
                     timestamp=datetime.utcnow(),
                     duration_ms=duration_ms,
                     message="OK",
-                    details=result if isinstance(result, dict) else {"result": str(result)}
+                    details=result
+                    if isinstance(result, dict)
+                    else {"result": str(result)},
                 )
-                
+
         except asyncio.TimeoutError:
             duration_ms = (time.time() - start_time) * 1000
             return HealthCheckResult(
@@ -144,9 +155,9 @@ class HealthChecker:
                 status=HealthStatus.UNHEALTHY,
                 timestamp=datetime.utcnow(),
                 duration_ms=duration_ms,
-                message=f"Check timeout after {check_config['timeout']}s"
+                message=f"Check timeout after {check_config['timeout']}s",
             )
-            
+
         except Exception as e:
             duration_ms = (time.time() - start_time) * 1000
             return HealthCheckResult(
@@ -154,21 +165,21 @@ class HealthChecker:
                 status=HealthStatus.UNHEALTHY,
                 timestamp=datetime.utcnow(),
                 duration_ms=duration_ms,
-                message=f"Check failed: {str(e)}"
+                message=f"Check failed: {str(e)}",
             )
-    
+
     async def run_all_checks(self) -> SystemHealth:
         """執行所有健康檢查"""
         results = []
-        
+
         # 並行執行所有檢查
-        check_tasks = [
-            self.run_check(name) for name in self.checks.keys()
-        ]
-        
+        check_tasks = [self.run_check(name) for name in self.checks.keys()]
+
         if check_tasks:
-            results = await asyncio.gather(*check_tasks, return_exceptions=True)
-            
+            results = await asyncio.gather(
+                *check_tasks, return_exceptions=True
+            )
+
             # 處理異常結果
             processed_results = []
             for i, result in enumerate(results):
@@ -180,37 +191,43 @@ class HealthChecker:
                             status=HealthStatus.UNHEALTHY,
                             timestamp=datetime.utcnow(),
                             duration_ms=0,
-                            message=f"Exception: {str(result)}"
+                            message=f"Exception: {str(result)}",
                         )
                     )
                 else:
                     processed_results.append(result)
-            
+
             results = processed_results
-        
+
         # 儲存結果供後續使用
         for result in results:
             self.last_results[result.name] = result
-        
+
         # 計算整體健康狀態
         overall_status = self._calculate_overall_status(results)
         uptime = time.time() - self.start_time
-        
+
         return SystemHealth(
             status=overall_status,
             timestamp=datetime.utcnow(),
             checks=results,
-            uptime_seconds=uptime
+            uptime_seconds=uptime,
         )
-    
-    def _calculate_overall_status(self, results: List[HealthCheckResult]) -> HealthStatus:
+
+    def _calculate_overall_status(
+        self, results: List[HealthCheckResult]
+    ) -> HealthStatus:
         """計算整體健康狀態"""
         if not results:
             return HealthStatus.HEALTHY
-        
-        unhealthy_count = sum(1 for r in results if r.status == HealthStatus.UNHEALTHY)
-        degraded_count = sum(1 for r in results if r.status == HealthStatus.DEGRADED)
-        
+
+        unhealthy_count = sum(
+            1 for r in results if r.status == HealthStatus.UNHEALTHY
+        )
+        degraded_count = sum(
+            1 for r in results if r.status == HealthStatus.DEGRADED
+        )
+
         if unhealthy_count > 0:
             # 如果有超過一半的檢查失敗，系統不健康
             if unhealthy_count > len(results) // 2:
@@ -222,13 +239,14 @@ class HealthChecker:
         else:
             return HealthStatus.HEALTHY
 
+
 # 預定義健康檢查函數
 async def check_database_connectivity(
-    host: str = "localhost", 
-    port: int = 5432, 
+    host: str = "localhost",
+    port: int = 5432,
     database: str = "postgres",
-    user: str = "postgres", 
-    password: str = "password"
+    user: str = "postgres",
+    password: str = "password",
 ) -> HealthCheckResult:
     """檢查 PostgreSQL 資料庫連接"""
     if not POSTGRES_AVAILABLE:
@@ -237,9 +255,9 @@ async def check_database_connectivity(
             status=HealthStatus.UNHEALTHY,
             timestamp=datetime.utcnow(),
             duration_ms=0,
-            message="psycopg2 not available"
+            message="psycopg2 not available",
         )
-    
+
     try:
         start_time = time.time()
         conn = psycopg2.connect(
@@ -248,25 +266,25 @@ async def check_database_connectivity(
             database=database,
             user=user,
             password=password,
-            connect_timeout=3
+            connect_timeout=3,
         )
-        
+
         with conn.cursor() as cur:
             cur.execute("SELECT 1")
             result = cur.fetchone()
-        
+
         conn.close()
         duration_ms = (time.time() - start_time) * 1000
-        
+
         return HealthCheckResult(
             name="database",
             status=HealthStatus.HEALTHY,
             timestamp=datetime.utcnow(),
             duration_ms=duration_ms,
             message="Database connection successful",
-            details={"query_result": result[0] if result else None}
+            details={"query_result": result[0] if result else None},
         )
-        
+
     except Exception as e:
         duration_ms = (time.time() - start_time) * 1000
         return HealthCheckResult(
@@ -274,14 +292,15 @@ async def check_database_connectivity(
             status=HealthStatus.UNHEALTHY,
             timestamp=datetime.utcnow(),
             duration_ms=duration_ms,
-            message=f"Database connection failed: {str(e)}"
+            message=f"Database connection failed: {str(e)}",
         )
 
+
 async def check_redis_connectivity(
-    host: str = "localhost", 
-    port: int = 6379, 
+    host: str = "localhost",
+    port: int = 6379,
     db: int = 0,
-    password: str = None
+    password: str = None,
 ) -> HealthCheckResult:
     """檢查 Redis 連接"""
     if not REDIS_AVAILABLE:
@@ -290,9 +309,9 @@ async def check_redis_connectivity(
             status=HealthStatus.UNHEALTHY,
             timestamp=datetime.utcnow(),
             duration_ms=0,
-            message="redis library not available"
+            message="redis library not available",
         )
-    
+
     try:
         start_time = time.time()
         r = redis.Redis(
@@ -301,15 +320,15 @@ async def check_redis_connectivity(
             db=db,
             password=password,
             socket_timeout=3,
-            socket_connect_timeout=3
+            socket_connect_timeout=3,
         )
-        
+
         # 測試連接
         ping_result = r.ping()
-        info = r.info('memory')
-        
+        info = r.info("memory")
+
         duration_ms = (time.time() - start_time) * 1000
-        
+
         return HealthCheckResult(
             name="redis",
             status=HealthStatus.HEALTHY,
@@ -318,11 +337,11 @@ async def check_redis_connectivity(
             message="Redis connection successful",
             details={
                 "ping": ping_result,
-                "used_memory": info.get('used_memory', 0),
-                "max_memory": info.get('maxmemory', 0)
-            }
+                "used_memory": info.get("used_memory", 0),
+                "max_memory": info.get("maxmemory", 0),
+            },
         )
-        
+
     except Exception as e:
         duration_ms = (time.time() - start_time) * 1000
         return HealthCheckResult(
@@ -330,20 +349,23 @@ async def check_redis_connectivity(
             status=HealthStatus.UNHEALTHY,
             timestamp=datetime.utcnow(),
             duration_ms=duration_ms,
-            message=f"Redis connection failed: {str(e)}"
+            message=f"Redis connection failed: {str(e)}",
         )
 
-async def check_disk_space(threshold_percent: float = 90.0) -> HealthCheckResult:
+
+async def check_disk_space(
+    threshold_percent: float = 90.0,
+) -> HealthCheckResult:
     """檢查磁碟空間"""
     import shutil
-    
+
     try:
         start_time = time.time()
         total, used, free = shutil.disk_usage("/")
-        
+
         used_percent = (used / total) * 100
         duration_ms = (time.time() - start_time) * 1000
-        
+
         if used_percent > threshold_percent:
             status = HealthStatus.UNHEALTHY
             message = f"Disk usage critical: {used_percent:.1f}%"
@@ -353,7 +375,7 @@ async def check_disk_space(threshold_percent: float = 90.0) -> HealthCheckResult
         else:
             status = HealthStatus.HEALTHY
             message = f"Disk usage normal: {used_percent:.1f}%"
-        
+
         return HealthCheckResult(
             name="disk_space",
             status=status,
@@ -364,30 +386,33 @@ async def check_disk_space(threshold_percent: float = 90.0) -> HealthCheckResult
                 "total_bytes": total,
                 "used_bytes": used,
                 "free_bytes": free,
-                "used_percent": used_percent
-            }
+                "used_percent": used_percent,
+            },
         )
-        
+
     except Exception as e:
         return HealthCheckResult(
             name="disk_space",
             status=HealthStatus.UNHEALTHY,
             timestamp=datetime.utcnow(),
             duration_ms=0,
-            message=f"Disk space check failed: {str(e)}"
+            message=f"Disk space check failed: {str(e)}",
         )
 
-async def check_memory_usage(threshold_percent: float = 90.0) -> HealthCheckResult:
+
+async def check_memory_usage(
+    threshold_percent: float = 90.0,
+) -> HealthCheckResult:
     """檢查記憶體使用量"""
     import psutil
-    
+
     try:
         start_time = time.time()
         memory = psutil.virtual_memory()
-        
+
         used_percent = memory.percent
         duration_ms = (time.time() - start_time) * 1000
-        
+
         if used_percent > threshold_percent:
             status = HealthStatus.UNHEALTHY
             message = f"Memory usage critical: {used_percent:.1f}%"
@@ -397,7 +422,7 @@ async def check_memory_usage(threshold_percent: float = 90.0) -> HealthCheckResu
         else:
             status = HealthStatus.HEALTHY
             message = f"Memory usage normal: {used_percent:.1f}%"
-        
+
         return HealthCheckResult(
             name="memory_usage",
             status=status,
@@ -408,17 +433,17 @@ async def check_memory_usage(threshold_percent: float = 90.0) -> HealthCheckResu
                 "total_bytes": memory.total,
                 "available_bytes": memory.available,
                 "used_bytes": memory.used,
-                "used_percent": used_percent
-            }
+                "used_percent": used_percent,
+            },
         )
-        
+
     except ImportError:
         return HealthCheckResult(
             name="memory_usage",
             status=HealthStatus.UNHEALTHY,
             timestamp=datetime.utcnow(),
             duration_ms=0,
-            message="psutil library not available"
+            message="psutil library not available",
         )
     except Exception as e:
         return HealthCheckResult(
@@ -426,67 +451,78 @@ async def check_memory_usage(threshold_percent: float = 90.0) -> HealthCheckResu
             status=HealthStatus.UNHEALTHY,
             timestamp=datetime.utcnow(),
             duration_ms=0,
-            message=f"Memory check failed: {str(e)}"
+            message=f"Memory check failed: {str(e)}",
         )
 
+
 # 全域健康檢查器實例
 health_checker = HealthChecker()
 
+
 class HealthCheckMiddleware:
     """健康檢查中間件"""
-    
+
     def __init__(self, app, health_endpoint: str = "/health"):
         self.app = app
         self.health_endpoint = health_endpoint
         self.detailed_endpoint = f"{health_endpoint}/detailed"
         self.logger = get_logger("health_check")
-        
+
         # 註冊預設健康檢查
         self._register_default_checks()
-    
+
     def _register_default_checks(self):
         """註冊預設健康檢查"""
         # 磁碟空間檢查
         health_checker.register_check("disk_space", check_disk_space)
-        
+
         # 記憶體使用檢查 (如果 psutil 可用)
         try:
             import psutil
+
             health_checker.register_check("memory_usage", check_memory_usage)
         except ImportError:
             pass
-        
+
         # 資料庫檢查 (如果配置可用)
         if POSTGRES_AVAILABLE:
-            health_checker.register_check("database", check_database_connectivity)
-        
-        # Redis 檢查 (如果配置可用)  
+            health_checker.register_check(
+                "database", check_database_connectivity
+            )
+
+        # Redis 檢查 (如果配置可用)
         if REDIS_AVAILABLE:
             health_checker.register_check("redis", check_redis_connectivity)
-    
+
     async def __call__(self, scope, receive, send):
         if scope["type"] != "http":
             await self.app(scope, receive, send)
             return
-        
+
         path = scope["path"]
-        
+
         # 健康檢查端點
         if path == self.health_endpoint:
-            await self._handle_health_check(scope, receive, send, detailed=False)
+            await self._handle_health_check(
+                scope, receive, send, detailed=False
+            )
             return
         elif path == self.detailed_endpoint:
-            await self._handle_health_check(scope, receive, send, detailed=True)
+            await self._handle_health_check(
+                scope, receive, send, detailed=True
+            )
             return
-        
+
         # 正常請求處理
         await self.app(scope, receive, send)
-    
-    async def _handle_health_check(self, scope, receive, send, detailed: bool = False):
+
+    async def _handle_health_check(
+        self, scope, receive, send, detailed: bool = False
+    ):
         """處理健康檢查請求"""
         try:
             system_health = await health_checker.run_all_checks()
-            
+
             if detailed:
                 response_data = system_health.to_dict()
             else:
@@ -494,9 +530,9 @@ class HealthCheckMiddleware:
                 response_data = {
                     "status": system_health.status.value,
                     "timestamp": system_health.timestamp.isoformat(),
-                    "uptime_seconds": system_health.uptime_seconds
+                    "uptime_seconds": system_health.uptime_seconds,
                 }
-            
+
             # 根據健康狀態設定 HTTP 狀態碼
             if system_health.status == HealthStatus.HEALTHY:
                 status_code = 200
@@ -504,66 +540,75 @@ class HealthCheckMiddleware:
                 status_code = 200  # 仍可服務但有警告
             else:
                 status_code = 503  # 服務不可用
-            
+
             response_body = json.dumps(response_data, indent=2).encode()
-            
-            await send({
-                "type": "http.response.start",
-                "status": status_code,
-                "headers": [
-                    [b"content-type", b"application/json"],
-                    [b"content-length", str(len(response_body)).encode()],
-                ],
-            })
-            
-            await send({
-                "type": "http.response.body",
-                "body": response_body,
-            })
-            
+
+            await send(
+                {
+                    "type": "http.response.start",
+                    "status": status_code,
+                    "headers": [
+                        [b"content-type", b"application/json"],
+                        [b"content-length", str(len(response_body)).encode()],
+                    ],
+                }
+            )
+
+            await send(
+                {
+                    "type": "http.response.body",
+                    "body": response_body,
+                }
+            )
+
             # 記錄健康檢查
             self.logger.info(
                 f"Health check completed: {system_health.status.value}",
                 status=system_health.status.value,
                 checks_count=len(system_health.checks),
                 uptime_seconds=system_health.uptime_seconds,
-                detailed=detailed
+                detailed=detailed,
             )
-            
+
         except Exception as e:
             # 健康檢查本身失敗
             error_response = {
                 "status": "unhealthy",
                 "timestamp": datetime.utcnow().isoformat(),
-                "error": str(e)
+                "error": str(e),
             }
-            
+
             response_body = json.dumps(error_response).encode()
-            
-            await send({
-                "type": "http.response.start",
-                "status": 500,
-                "headers": [
-                    [b"content-type", b"application/json"],
-                    [b"content-length", str(len(response_body)).encode()],
-                ],
-            })
-            
-            await send({
-                "type": "http.response.body",
-                "body": response_body,
-            })
-            
-            self.logger.error(
-                "Health check middleware failed",
-                exception=e
+
+            await send(
+                {
+                    "type": "http.response.start",
+                    "status": 500,
+                    "headers": [
+                        [b"content-type", b"application/json"],
+                        [b"content-length", str(len(response_body)).encode()],
+                    ],
+                }
             )
 
+            await send(
+                {
+                    "type": "http.response.body",
+                    "body": response_body,
+                }
+            )
+
+            self.logger.error("Health check middleware failed", exception=e)
+
+
 # 便捷函數
-def register_health_check(name: str, check_func: Callable, timeout: float = 5.0):
+def register_health_check(
+    name: str, check_func: Callable, timeout: float = 5.0
+):
     """註冊健康檢查的便捷函數"""
     health_checker.register_check(name, check_func, timeout)
 
+
 async def get_system_health() -> SystemHealth:
     """獲取系統健康狀態的便捷函數"""
-    return await health_checker.run_all_checks()
\ No newline at end of file
+    return await health_checker.run_all_checks()
diff --git a/auto_generate_video_fold6/monitoring/middleware/performance_middleware.py b/auto_generate_video_fold6/monitoring/middleware/performance_middleware.py
index 74215f9..728a505 100644
--- a/auto_generate_video_fold6/monitoring/middleware/performance_middleware.py
+++ b/auto_generate_video_fold6/monitoring/middleware/performance_middleware.py
@@ -16,222 +16,319 @@ import json
 
 # Prometheus metrics (optional dependency)
 try:
-    from prometheus_client import Counter, Histogram, Gauge, Summary, start_http_server
+    from prometheus_client import (
+        Counter,
+        Histogram,
+        Gauge,
+        Summary,
+        start_http_server,
+    )
+
     PROMETHEUS_AVAILABLE = True
 except ImportError:
     PROMETHEUS_AVAILABLE = False
 
-from ..logging.structured_logger import get_logger, set_correlation_id, set_request_id
+from ..logging.structured_logger import (
+    get_logger,
+    set_correlation_id,
+    set_request_id,
+)
 
 logger = get_logger(__name__)
 
+
 class PerformanceMetrics:
     """效能指標收集器"""
-    
+
     def __init__(self):
         # Request metrics
-        self.request_count = Counter(
-            'http_requests_total',
-            'Total HTTP requests',
-            ['method', 'endpoint', 'status', 'service']
-        ) if PROMETHEUS_AVAILABLE else None
-        
-        self.request_duration = Histogram(
-            'http_request_duration_seconds',
-            'HTTP request duration in seconds',
-            ['method', 'endpoint', 'service']
-        ) if PROMETHEUS_AVAILABLE else None
-        
-        self.request_size = Summary(
-            'http_request_size_bytes',
-            'HTTP request size in bytes',
-            ['method', 'endpoint', 'service']
-        ) if PROMETHEUS_AVAILABLE else None
-        
-        self.response_size = Summary(
-            'http_response_size_bytes',
-            'HTTP response size in bytes',
-            ['method', 'endpoint', 'service']
-        ) if PROMETHEUS_AVAILABLE else None
-        
+        self.request_count = (
+            Counter(
+                "http_requests_total",
+                "Total HTTP requests",
+                ["method", "endpoint", "status", "service"],
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
+        self.request_duration = (
+            Histogram(
+                "http_request_duration_seconds",
+                "HTTP request duration in seconds",
+                ["method", "endpoint", "service"],
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
+        self.request_size = (
+            Summary(
+                "http_request_size_bytes",
+                "HTTP request size in bytes",
+                ["method", "endpoint", "service"],
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
+        self.response_size = (
+            Summary(
+                "http_response_size_bytes",
+                "HTTP response size in bytes",
+                ["method", "endpoint", "service"],
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
         # Business metrics
-        self.video_generation_duration = Histogram(
-            'video_generation_duration_seconds',
-            'Video generation duration in seconds',
-            ['status', 'video_type']
-        ) if PROMETHEUS_AVAILABLE else None
-        
-        self.video_generation_total = Counter(
-            'video_generation_total',
-            'Total video generations',
-            ['status', 'video_type', 'platform']
-        ) if PROMETHEUS_AVAILABLE else None
-        
-        self.trend_analysis_duration = Histogram(
-            'trend_analysis_duration_seconds',
-            'Trend analysis duration in seconds',
-            ['source', 'accuracy']
-        ) if PROMETHEUS_AVAILABLE else None
-        
-        self.trend_analysis_total = Counter(
-            'trend_analysis_total',
-            'Total trend analyses',
-            ['source', 'status', 'accuracy']
-        ) if PROMETHEUS_AVAILABLE else None
-        
-        self.social_publish_total = Counter(
-            'social_publish_total',
-            'Total social media publishes',
-            ['platform', 'status', 'content_type']
-        ) if PROMETHEUS_AVAILABLE else None
-        
+        self.video_generation_duration = (
+            Histogram(
+                "video_generation_duration_seconds",
+                "Video generation duration in seconds",
+                ["status", "video_type"],
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
+        self.video_generation_total = (
+            Counter(
+                "video_generation_total",
+                "Total video generations",
+                ["status", "video_type", "platform"],
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
+        self.trend_analysis_duration = (
+            Histogram(
+                "trend_analysis_duration_seconds",
+                "Trend analysis duration in seconds",
+                ["source", "accuracy"],
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
+        self.trend_analysis_total = (
+            Counter(
+                "trend_analysis_total",
+                "Total trend analyses",
+                ["source", "status", "accuracy"],
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
+        self.social_publish_total = (
+            Counter(
+                "social_publish_total",
+                "Total social media publishes",
+                ["platform", "status", "content_type"],
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
         # System metrics
-        self.active_connections = Gauge(
-            'active_connections',
-            'Number of active connections',
-            ['service']
-        ) if PROMETHEUS_AVAILABLE else None
-        
-        self.queue_size = Gauge(
-            'queue_size',
-            'Current queue size',
-            ['queue_name', 'service']
-        ) if PROMETHEUS_AVAILABLE else None
-        
-        self.cache_hits = Counter(
-            'cache_hits_total',
-            'Total cache hits',
-            ['cache_type', 'service']
-        ) if PROMETHEUS_AVAILABLE else None
-        
-        self.cache_misses = Counter(
-            'cache_misses_total',
-            'Total cache misses',
-            ['cache_type', 'service']
-        ) if PROMETHEUS_AVAILABLE else None
-        
+        self.active_connections = (
+            Gauge(
+                "active_connections",
+                "Number of active connections",
+                ["service"],
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
+        self.queue_size = (
+            Gauge(
+                "queue_size", "Current queue size", ["queue_name", "service"]
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
+        self.cache_hits = (
+            Counter(
+                "cache_hits_total",
+                "Total cache hits",
+                ["cache_type", "service"],
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
+        self.cache_misses = (
+            Counter(
+                "cache_misses_total",
+                "Total cache misses",
+                ["cache_type", "service"],
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
         # Application errors
-        self.application_errors = Counter(
-            'application_errors_total',
-            'Total application errors',
-            ['service', 'error_type', 'endpoint']
-        ) if PROMETHEUS_AVAILABLE else None
-        
+        self.application_errors = (
+            Counter(
+                "application_errors_total",
+                "Total application errors",
+                ["service", "error_type", "endpoint"],
+            )
+            if PROMETHEUS_AVAILABLE
+            else None
+        )
+
         # In-memory metrics for fallback
         self._fallback_metrics = defaultdict(list)
         self._metrics_lock = threading.Lock()
-        
+
         # Performance tracking
         self._request_history = deque(maxlen=1000)
         self._performance_stats = {
-            'avg_response_time': 0.0,
-            'request_rate': 0.0,
-            'error_rate': 0.0,
-            'last_updated': datetime.utcnow()
+            "avg_response_time": 0.0,
+            "request_rate": 0.0,
+            "error_rate": 0.0,
+            "last_updated": datetime.utcnow(),
         }
 
-    def record_request(self, method: str, endpoint: str, status_code: int, 
-                      duration: float, service: str, request_size: int = 0, 
-                      response_size: int = 0):
+    def record_request(
+        self,
+        method: str,
+        endpoint: str,
+        status_code: int,
+        duration: float,
+        service: str,
+        request_size: int = 0,
+        response_size: int = 0,
+    ):
         """記錄 HTTP 請求指標"""
         status = str(status_code)
-        
+
         if PROMETHEUS_AVAILABLE and self.request_count:
             self.request_count.labels(
-                method=method, endpoint=endpoint, status=status, service=service
+                method=method,
+                endpoint=endpoint,
+                status=status,
+                service=service,
             ).inc()
-            
+
             self.request_duration.labels(
                 method=method, endpoint=endpoint, service=service
             ).observe(duration)
-            
+
             if request_size > 0:
                 self.request_size.labels(
                     method=method, endpoint=endpoint, service=service
                 ).observe(request_size)
-            
+
             if response_size > 0:
                 self.response_size.labels(
                     method=method, endpoint=endpoint, service=service
                 ).observe(response_size)
-        
+
         # Fallback metrics
         with self._metrics_lock:
-            self._fallback_metrics['requests'].append({
-                'timestamp': datetime.utcnow().isoformat(),
-                'method': method,
-                'endpoint': endpoint,
-                'status': status,
-                'duration': duration,
-                'service': service
-            })
-            
+            self._fallback_metrics["requests"].append(
+                {
+                    "timestamp": datetime.utcnow().isoformat(),
+                    "method": method,
+                    "endpoint": endpoint,
+                    "status": status,
+                    "duration": duration,
+                    "service": service,
+                }
+            )
+
             # Update request history for performance stats
-            self._request_history.append({
-                'timestamp': time.time(),
-                'duration': duration,
-                'status_code': status_code
-            })
-            
+            self._request_history.append(
+                {
+                    "timestamp": time.time(),
+                    "duration": duration,
+                    "status_code": status_code,
+                }
+            )
+
             self._update_performance_stats()
 
-    def record_video_generation(self, duration: float, status: str, 
-                               video_type: str, platform: str = 'unknown'):
+    def record_video_generation(
+        self,
+        duration: float,
+        status: str,
+        video_type: str,
+        platform: str = "unknown",
+    ):
         """記錄影片生成指標"""
         if PROMETHEUS_AVAILABLE and self.video_generation_duration:
             self.video_generation_duration.labels(
                 status=status, video_type=video_type
             ).observe(duration)
-            
+
             self.video_generation_total.labels(
                 status=status, video_type=video_type, platform=platform
             ).inc()
-        
+
         with self._metrics_lock:
-            self._fallback_metrics['video_generation'].append({
-                'timestamp': datetime.utcnow().isoformat(),
-                'duration': duration,
-                'status': status,
-                'video_type': video_type,
-                'platform': platform
-            })
-
-    def record_trend_analysis(self, duration: float, source: str, 
-                             status: str, accuracy: str = 'unknown'):
+            self._fallback_metrics["video_generation"].append(
+                {
+                    "timestamp": datetime.utcnow().isoformat(),
+                    "duration": duration,
+                    "status": status,
+                    "video_type": video_type,
+                    "platform": platform,
+                }
+            )
+
+    def record_trend_analysis(
+        self,
+        duration: float,
+        source: str,
+        status: str,
+        accuracy: str = "unknown",
+    ):
         """記錄趨勢分析指標"""
         if PROMETHEUS_AVAILABLE and self.trend_analysis_duration:
             self.trend_analysis_duration.labels(
                 source=source, accuracy=accuracy
             ).observe(duration)
-            
+
             self.trend_analysis_total.labels(
                 source=source, status=status, accuracy=accuracy
             ).inc()
-        
+
         with self._metrics_lock:
-            self._fallback_metrics['trend_analysis'].append({
-                'timestamp': datetime.utcnow().isoformat(),
-                'duration': duration,
-                'source': source,
-                'status': status,
-                'accuracy': accuracy
-            })
-
-    def record_social_publish(self, platform: str, status: str, 
-                             content_type: str = 'video'):
+            self._fallback_metrics["trend_analysis"].append(
+                {
+                    "timestamp": datetime.utcnow().isoformat(),
+                    "duration": duration,
+                    "source": source,
+                    "status": status,
+                    "accuracy": accuracy,
+                }
+            )
+
+    def record_social_publish(
+        self, platform: str, status: str, content_type: str = "video"
+    ):
         """記錄社交媒體發布指標"""
         if PROMETHEUS_AVAILABLE and self.social_publish_total:
             self.social_publish_total.labels(
                 platform=platform, status=status, content_type=content_type
             ).inc()
-        
+
         with self._metrics_lock:
-            self._fallback_metrics['social_publish'].append({
-                'timestamp': datetime.utcnow().isoformat(),
-                'platform': platform,
-                'status': status,
-                'content_type': content_type
-            })
+            self._fallback_metrics["social_publish"].append(
+                {
+                    "timestamp": datetime.utcnow().isoformat(),
+                    "platform": platform,
+                    "status": status,
+                    "content_type": content_type,
+                }
+            )
 
     def record_error(self, service: str, error_type: str, endpoint: str):
         """記錄應用程式錯誤"""
@@ -239,27 +336,35 @@ class PerformanceMetrics:
             self.application_errors.labels(
                 service=service, error_type=error_type, endpoint=endpoint
             ).inc()
-        
+
         with self._metrics_lock:
-            self._fallback_metrics['errors'].append({
-                'timestamp': datetime.utcnow().isoformat(),
-                'service': service,
-                'error_type': error_type,
-                'endpoint': endpoint
-            })
+            self._fallback_metrics["errors"].append(
+                {
+                    "timestamp": datetime.utcnow().isoformat(),
+                    "service": service,
+                    "error_type": error_type,
+                    "endpoint": endpoint,
+                }
+            )
 
     def record_cache_event(self, cache_type: str, service: str, hit: bool):
         """記錄快取事件"""
         if PROMETHEUS_AVAILABLE:
             if hit and self.cache_hits:
-                self.cache_hits.labels(cache_type=cache_type, service=service).inc()
+                self.cache_hits.labels(
+                    cache_type=cache_type, service=service
+                ).inc()
             elif not hit and self.cache_misses:
-                self.cache_misses.labels(cache_type=cache_type, service=service).inc()
+                self.cache_misses.labels(
+                    cache_type=cache_type, service=service
+                ).inc()
 
     def update_queue_size(self, queue_name: str, service: str, size: int):
         """更新隊列大小"""
         if PROMETHEUS_AVAILABLE and self.queue_size:
-            self.queue_size.labels(queue_name=queue_name, service=service).set(size)
+            self.queue_size.labels(queue_name=queue_name, service=service).set(
+                size
+            )
 
     def update_active_connections(self, service: str, count: int):
         """更新活躍連接數"""
@@ -270,24 +375,34 @@ class PerformanceMetrics:
         """更新效能統計"""
         if not self._request_history:
             return
-        
+
         now = time.time()
-        recent_requests = [r for r in self._request_history if now - r['timestamp'] < 300]  # Last 5 minutes
-        
+        recent_requests = [
+            r for r in self._request_history if now - r["timestamp"] < 300
+        ]  # Last 5 minutes
+
         if recent_requests:
             # Average response time
-            avg_duration = sum(r['duration'] for r in recent_requests) / len(recent_requests)
-            self._performance_stats['avg_response_time'] = avg_duration
-            
+            avg_duration = sum(r["duration"] for r in recent_requests) / len(
+                recent_requests
+            )
+            self._performance_stats["avg_response_time"] = avg_duration
+
             # Request rate (requests per second)
-            time_span = max(now - recent_requests[0]['timestamp'], 1)
-            self._performance_stats['request_rate'] = len(recent_requests) / time_span
-            
+            time_span = max(now - recent_requests[0]["timestamp"], 1)
+            self._performance_stats["request_rate"] = (
+                len(recent_requests) / time_span
+            )
+
             # Error rate
-            error_count = sum(1 for r in recent_requests if r['status_code'] >= 400)
-            self._performance_stats['error_rate'] = error_count / len(recent_requests) * 100
-            
-            self._performance_stats['last_updated'] = datetime.utcnow()
+            error_count = sum(
+                1 for r in recent_requests if r["status_code"] >= 400
+            )
+            self._performance_stats["error_rate"] = (
+                error_count / len(recent_requests) * 100
+            )
+
+            self._performance_stats["last_updated"] = datetime.utcnow()
 
     def get_performance_stats(self) -> Dict[str, Any]:
         """獲取效能統計"""
@@ -299,104 +414,110 @@ class PerformanceMetrics:
         with self._metrics_lock:
             # Return recent metrics (last hour)
             cutoff_time = datetime.utcnow() - timedelta(hours=1)
-            
+
             filtered_metrics = {}
             for metric_type, metrics in self._fallback_metrics.items():
                 filtered_metrics[metric_type] = [
-                    m for m in metrics 
-                    if datetime.fromisoformat(m['timestamp']) > cutoff_time
+                    m
+                    for m in metrics
+                    if datetime.fromisoformat(m["timestamp"]) > cutoff_time
                 ]
-            
+
             return filtered_metrics
 
+
 # Global metrics instance
 metrics = PerformanceMetrics()
 
+
 class PerformanceMiddleware:
     """效能監控中間件"""
-    
+
     def __init__(self, app, service_name: str = "unknown"):
         self.app = app
         self.service_name = service_name
         self.logger = get_logger(f"{service_name}.performance")
-    
+
     async def __call__(self, scope, receive, send):
         if scope["type"] != "http":
             await self.app(scope, receive, send)
             return
-        
+
         # Extract request information
         method = scope["method"]
         path = scope["path"]
-        
+
         # Generate correlation ID for request tracking
         import uuid
+
         correlation_id = str(uuid.uuid4())
         set_correlation_id(correlation_id)
-        
+
         # Extract request ID from headers if present
         headers = dict(scope.get("headers", []))
         request_id = headers.get(b"x-request-id", b"").decode()
         if request_id:
             set_request_id(request_id)
-        
+
         start_time = time.time()
         request_size = 0
         response_size = 0
         status_code = 500  # Default to error
-        
+
         # Calculate request size
         if "content-length" in headers:
             try:
                 request_size = int(headers[b"content-length"].decode())
             except (ValueError, AttributeError):
                 pass
-        
+
         # Wrap send to capture response size and status
         async def send_wrapper(message):
             nonlocal response_size, status_code
-            
+
             if message["type"] == "http.response.start":
                 status_code = message["status"]
                 response_headers = dict(message.get("headers", []))
                 if b"content-length" in response_headers:
                     try:
-                        response_size = int(response_headers[b"content-length"].decode())
+                        response_size = int(
+                            response_headers[b"content-length"].decode()
+                        )
                     except (ValueError, AttributeError):
                         pass
-            
+
             elif message["type"] == "http.response.body":
                 if "body" in message:
                     response_size += len(message["body"])
-            
+
             await send(message)
-        
+
         try:
             # Process request
             await self.app(scope, receive, send_wrapper)
-            
+
         except Exception as e:
             # Record error
             metrics.record_error(
                 service=self.service_name,
                 error_type=type(e).__name__,
-                endpoint=path
+                endpoint=path,
             )
-            
+
             self.logger.error(
                 f"Request failed: {method} {path}",
                 exception=e,
                 correlation_id=correlation_id,
                 request_id=request_id,
-                duration_ms=(time.time() - start_time) * 1000
+                duration_ms=(time.time() - start_time) * 1000,
             )
-            
+
             raise
-        
+
         finally:
             # Record metrics
             duration = time.time() - start_time
-            
+
             metrics.record_request(
                 method=method,
                 endpoint=path,
@@ -404,9 +525,9 @@ class PerformanceMiddleware:
                 duration=duration,
                 service=self.service_name,
                 request_size=request_size,
-                response_size=response_size
+                response_size=response_size,
             )
-            
+
             # Log request completion
             log_level = "warning" if status_code >= 400 else "info"
             getattr(self.logger, log_level)(
@@ -418,105 +539,121 @@ class PerformanceMiddleware:
                 request_size=request_size,
                 response_size=response_size,
                 correlation_id=correlation_id,
-                request_id=request_id
+                request_id=request_id,
             )
 
+
 @asynccontextmanager
 async def performance_context(operation_name: str, **labels):
     """效能監控上下文管理器"""
     start_time = time.time()
     operation_logger = get_logger(f"performance.{operation_name}")
-    
+
     operation_logger.info(f"Operation started: {operation_name}", **labels)
-    
+
     try:
         yield
         duration = time.time() - start_time
         operation_logger.info(
             f"Operation completed: {operation_name}",
             duration_ms=duration * 1000,
-            **labels
+            **labels,
         )
-        
+
     except Exception as e:
         duration = time.time() - start_time
         operation_logger.error(
             f"Operation failed: {operation_name}",
             exception=e,
             duration_ms=duration * 1000,
-            **labels
+            **labels,
         )
         raise
 
+
 def performance_tracker(operation_type: str = "unknown"):
     """效能追蹤裝飾器"""
+
     def decorator(func):
         from functools import wraps
         import asyncio
-        
+
         @wraps(func)
         async def async_wrapper(*args, **kwargs):
             async with performance_context(
                 operation_name=func.__name__,
                 operation_type=operation_type,
-                function=f"{func.__module__}.{func.__name__}"
+                function=f"{func.__module__}.{func.__name__}",
             ):
                 return await func(*args, **kwargs)
-        
+
         @wraps(func)
         def sync_wrapper(*args, **kwargs):
             import time
+
             start_time = time.time()
-            
+
             try:
                 result = func(*args, **kwargs)
                 duration = time.time() - start_time
-                
+
                 logger.info(
                     f"Function completed: {func.__name__}",
                     operation_type=operation_type,
                     function=f"{func.__module__}.{func.__name__}",
-                    duration_ms=duration * 1000
+                    duration_ms=duration * 1000,
                 )
-                
+
                 return result
-                
+
             except Exception as e:
                 duration = time.time() - start_time
-                
+
                 logger.error(
                     f"Function failed: {func.__name__}",
                     exception=e,
                     operation_type=operation_type,
                     function=f"{func.__module__}.{func.__name__}",
-                    duration_ms=duration * 1000
+                    duration_ms=duration * 1000,
                 )
                 raise
-        
+
         if asyncio.iscoroutinefunction(func):
             return async_wrapper
         else:
             return sync_wrapper
-    
+
     return decorator
 
+
 # Utility functions for recording specific business metrics
-def record_video_generation(duration: float, status: str, video_type: str, platform: str = 'unknown'):
+def record_video_generation(
+    duration: float, status: str, video_type: str, platform: str = "unknown"
+):
     """記錄影片生成指標的便捷函數"""
-    return metrics.record_video_generation(duration, status, video_type, platform)
+    return metrics.record_video_generation(
+        duration, status, video_type, platform
+    )
 
-def record_trend_analysis(duration: float, source: str, status: str, accuracy: str = 'unknown'):
+
+def record_trend_analysis(
+    duration: float, source: str, status: str, accuracy: str = "unknown"
+):
     """記錄趨勢分析指標的便捷函數"""
     return metrics.record_trend_analysis(duration, source, status, accuracy)
 
-def record_social_publish(platform: str, status: str, content_type: str = 'video'):
+
+def record_social_publish(
+    platform: str, status: str, content_type: str = "video"
+):
     """記錄社交媒體發布指標的便捷函數"""
     return metrics.record_social_publish(platform, status, content_type)
 
+
 def start_metrics_server(port: int = 8000):
     """啟動 Prometheus 指標伺服器"""
     if PROMETHEUS_AVAILABLE:
         start_http_server(port)
         logger.info(f"Prometheus metrics server started on port {port}")
     else:
-        logger.warning("Prometheus not available, metrics server not started")
\ No newline at end of file
+        logger.warning("Prometheus not available, metrics server not started")
diff --git a/auto_generate_video_fold6/monitoring/middleware/prometheus_middleware.py b/auto_generate_video_fold6/monitoring/middleware/prometheus_middleware.py
index 808345e..bedbcdf 100644
--- a/auto_generate_video_fold6/monitoring/middleware/prometheus_middleware.py
+++ b/auto_generate_video_fold6/monitoring/middleware/prometheus_middleware.py
@@ -5,7 +5,13 @@ Prometheus 指標收集中介軟體
 
 import time
 from typing import Callable
-from prometheus_client import Counter, Histogram, Gauge, generate_latest, CONTENT_TYPE_LATEST
+from prometheus_client import (
+    Counter,
+    Histogram,
+    Gauge,
+    generate_latest,
+    CONTENT_TYPE_LATEST,
+)
 from fastapi import FastAPI, Request, Response
 from fastapi.responses import PlainTextResponse
 import psutil
@@ -49,7 +55,9 @@ class PrometheusMiddleware:
         )
 
         self.active_requests = Gauge(
-            "http_requests_active", "Number of active HTTP requests", ["service"]
+            "http_requests_active",
+            "Number of active HTTP requests",
+            ["service"],
         )
 
         # 業務指標
@@ -67,7 +75,9 @@ class PrometheusMiddleware:
         )
 
         self.ai_request_count = Counter(
-            "ai_requests_total", "Total AI service requests", ["request_type", "status", "service"]
+            "ai_requests_total",
+            "Total AI service requests",
+            ["request_type", "status", "service"],
         )
 
         self.ai_request_duration = Histogram(
@@ -78,30 +88,52 @@ class PrometheusMiddleware:
         )
 
         # 系統指標
-        self.memory_usage = Gauge("memory_usage_bytes", "Memory usage in bytes", ["service"])
+        self.memory_usage = Gauge(
+            "memory_usage_bytes", "Memory usage in bytes", ["service"]
+        )
 
-        self.cpu_usage = Gauge("cpu_usage_percent", "CPU usage percentage", ["service"])
+        self.cpu_usage = Gauge(
+            "cpu_usage_percent", "CPU usage percentage", ["service"]
+        )
 
         # 資料庫指標
         self.db_connections = Gauge(
-            "database_connections_active", "Number of active database connections", ["service"]
+            "database_connections_active",
+            "Number of active database connections",
+            ["service"],
         )
 
         self.db_query_duration = Histogram(
             "database_query_duration_seconds",
             "Database query duration in seconds",
             ["operation", "service"],
-            buckets=(0.001, 0.005, 0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, float("inf")),
+            buckets=(
+                0.001,
+                0.005,
+                0.01,
+                0.05,
+                0.1,
+                0.25,
+                0.5,
+                1.0,
+                2.5,
+                5.0,
+                float("inf"),
+            ),
         )
 
         # 快取指標
         self.cache_operations = Counter(
-            "cache_operations_total", "Total cache operations", ["operation", "result", "service"]
+            "cache_operations_total",
+            "Total cache operations",
+            ["operation", "result", "service"],
         )
 
         # 錯誤指標
         self.error_count = Counter(
-            "application_errors_total", "Total application errors", ["error_type", "service"]
+            "application_errors_total",
+            "Total application errors",
+            ["error_type", "service"],
         )
 
         # 啟動背景任務收集系統指標
@@ -113,7 +145,9 @@ class PrometheusMiddleware:
             try:
                 # 記憶體使用量
                 memory_info = psutil.virtual_memory()
-                self.memory_usage.labels(service=self.app_name).set(memory_info.used)
+                self.memory_usage.labels(service=self.app_name).set(
+                    memory_info.used
+                )
 
                 # CPU 使用率
                 cpu_percent = psutil.cpu_percent(interval=1)
@@ -124,7 +158,9 @@ class PrometheusMiddleware:
                 print(f"Error collecting system metrics: {e}")
                 await asyncio.sleep(60)
 
-    async def __call__(self, request: Request, call_next: Callable) -> Response:
+    async def __call__(
+        self, request: Request, call_next: Callable
+    ) -> Response:
         """中介軟體主要邏輯"""
         # 記錄請求開始時間
         start_time = time.time()
@@ -146,7 +182,9 @@ class PrometheusMiddleware:
 
         except Exception as e:
             # 記錄錯誤
-            self.error_count.labels(error_type=type(e).__name__, service=self.app_name).inc()
+            self.error_count.labels(
+                error_type=type(e).__name__, service=self.app_name
+            ).inc()
 
             status_code = 500
             raise
@@ -160,7 +198,10 @@ class PrometheusMiddleware:
 
             # 記錄指標
             self.request_count.labels(
-                method=method, endpoint=endpoint, status_code=status_code, service=self.app_name
+                method=method,
+                endpoint=endpoint,
+                status_code=status_code,
+                service=self.app_name,
             ).inc()
 
             self.request_duration.labels(
@@ -179,7 +220,9 @@ class PrometheusMiddleware:
 
         # UUID 模式
         path = re.sub(
-            r"/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}", "/{uuid}", path
+            r"/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}",
+            "/{uuid}",
+            path,
         )
 
         # 數字 ID 模式
@@ -198,30 +241,36 @@ class PrometheusMiddleware:
 
         return path
 
-    def record_video_generation(self, status: str, platform: str, duration: float = None):
+    def record_video_generation(
+        self, status: str, platform: str, duration: float = None
+    ):
         """記錄影片生成指標"""
         self.video_generation_count.labels(
             status=status, platform=platform, service=self.app_name
         ).inc()
 
         if duration is not None:
-            self.video_generation_duration.labels(platform=platform, service=self.app_name).observe(
-                duration
-            )
+            self.video_generation_duration.labels(
+                platform=platform, service=self.app_name
+            ).observe(duration)
 
-    def record_ai_request(self, request_type: str, status: str, duration: float):
+    def record_ai_request(
+        self, request_type: str, status: str, duration: float
+    ):
         """記錄 AI 請求指標"""
         self.ai_request_count.labels(
             request_type=request_type, status=status, service=self.app_name
         ).inc()
 
-        self.ai_request_duration.labels(request_type=request_type, service=self.app_name).observe(
-            duration
-        )
+        self.ai_request_duration.labels(
+            request_type=request_type, service=self.app_name
+        ).observe(duration)
 
     def record_db_query(self, operation: str, duration: float):
         """記錄資料庫查詢指標"""
-        self.db_query_duration.labels(operation=operation, service=self.app_name).observe(duration)
+        self.db_query_duration.labels(
+            operation=operation, service=self.app_name
+        ).observe(duration)
 
     def record_cache_operation(self, operation: str, result: str):
         """記錄快取操作指標"""
@@ -231,7 +280,9 @@ class PrometheusMiddleware:
 
     def record_error(self, error_type: str):
         """記錄錯誤指標"""
-        self.error_count.labels(error_type=error_type, service=self.app_name).inc()
+        self.error_count.labels(
+            error_type=error_type, service=self.app_name
+        ).inc()
 
 
 def setup_metrics_endpoint(app: FastAPI, middleware: PrometheusMiddleware):
@@ -245,7 +296,11 @@ def setup_metrics_endpoint(app: FastAPI, middleware: PrometheusMiddleware):
     @app.get("/health")
     async def health_check():
         """健康檢查端點"""
-        return {"status": "healthy", "service": middleware.app_name, "timestamp": time.time()}
+        return {
+            "status": "healthy",
+            "service": middleware.app_name,
+            "timestamp": time.time(),
+        }
 
 
 # 使用範例
diff --git a/auto_generate_video_fold6/monitoring/report_generator.py b/auto_generate_video_fold6/monitoring/report_generator.py
index 5ceb403..f02ba6e 100755
--- a/auto_generate_video_fold6/monitoring/report_generator.py
+++ b/auto_generate_video_fold6/monitoring/report_generator.py
@@ -66,8 +66,7 @@ class ReportGenerator:
         template_dir = Path(__file__).parent / "templates"
         template_dir.mkdir(exist_ok=True)
         self.jinja_env = Environment(
-            loader=FileSystemLoader(str(template_dir)),
-            autoescape=True
+            loader=FileSystemLoader(str(template_dir)), autoescape=True
         )
 
         # 確保模板文件存在
@@ -265,7 +264,9 @@ class ReportGenerator:
 
         return await self._generate_report(config)
 
-    async def generate_monthly_report(self, year: int = None, month: int = None) -> str:
+    async def generate_monthly_report(
+        self, year: int = None, month: int = None
+    ) -> str:
         """生成月報告"""
         if year is None or month is None:
             today = date.today()
@@ -311,7 +312,9 @@ class ReportGenerator:
         else:
             raise ValueError(f"不支援的輸出格式: {config.output_format}")
 
-    async def _collect_report_data(self, config: ReportConfig) -> Dict[str, Any]:
+    async def _collect_report_data(
+        self, config: ReportConfig
+    ) -> Dict[str, Any]:
         """收集報告數據"""
         data = {
             "period": {
@@ -327,7 +330,9 @@ class ReportGenerator:
 
         return data
 
-    async def _get_generation_metrics(self, config: ReportConfig) -> GenerationMetrics:
+    async def _get_generation_metrics(
+        self, config: ReportConfig
+    ) -> GenerationMetrics:
         """獲取生成指標"""
         # 模擬數據 - 在實際實作中應該從資料庫查詢
         total_videos = 45
@@ -340,7 +345,11 @@ class ReportGenerator:
             failed_generations=failed,
             total_cost=67.50,
             average_cost_per_video=1.50,
-            platforms_distribution={"tiktok": 20, "instagram": 15, "youtube": 10},
+            platforms_distribution={
+                "tiktok": 20,
+                "instagram": 15,
+                "youtube": 10,
+            },
             quality_distribution={"high": 15, "medium": 25, "low": 5},
             generation_time_stats={"avg": 180, "min": 120, "max": 300},
         )
@@ -352,7 +361,9 @@ class ReportGenerator:
 
         try:
             if config.report_type == "daily":
-                summary = await self.cost_tracker.get_daily_summary(config.start_date)
+                summary = await self.cost_tracker.get_daily_summary(
+                    config.start_date
+                )
                 return {
                     "total_cost": summary.total_cost,
                     "api_calls_count": summary.api_calls_count,
@@ -361,7 +372,10 @@ class ReportGenerator:
                     "budget_status": {
                         "limit": summary.budget_limit,
                         "remaining": summary.budget_remaining,
-                        "usage_percent": (summary.total_cost / summary.budget_limit) * 100,
+                        "usage_percent": (
+                            summary.total_cost / summary.budget_limit
+                        )
+                        * 100,
                     },
                 }
             else:
@@ -382,16 +396,26 @@ class ReportGenerator:
         return {
             "total_cost": 67.50,
             "api_calls_count": 450,
-            "providers_breakdown": {"openai": 35.20, "stability_ai": 22.80, "elevenlabs": 9.50},
+            "providers_breakdown": {
+                "openai": 35.20,
+                "stability_ai": 22.80,
+                "elevenlabs": 9.50,
+            },
             "operations_breakdown": {
                 "text_generation": 35.20,
                 "image_generation": 22.80,
                 "voice_synthesis": 9.50,
             },
-            "budget_status": {"limit": 100.0, "remaining": 32.50, "usage_percent": 67.5},
+            "budget_status": {
+                "limit": 100.0,
+                "remaining": 32.50,
+                "usage_percent": 67.5,
+            },
         }
 
-    async def _get_performance_metrics(self, config: ReportConfig) -> Dict[str, Any]:
+    async def _get_performance_metrics(
+        self, config: ReportConfig
+    ) -> Dict[str, Any]:
         """獲取效能指標"""
         # 模擬效能數據
         return {
@@ -399,10 +423,16 @@ class ReportGenerator:
             "success_rate": 93.3,  # 百分比
             "error_rate": 6.7,
             "throughput": 15,  # 影片/小時
-            "resource_usage": {"cpu_avg": 65, "memory_avg": 78, "disk_usage": 45},
+            "resource_usage": {
+                "cpu_avg": 65,
+                "memory_avg": 78,
+                "disk_usage": 45,
+            },
         }
 
-    async def _get_daily_breakdown(self, config: ReportConfig) -> List[Dict[str, Any]]:
+    async def _get_daily_breakdown(
+        self, config: ReportConfig
+    ) -> List[Dict[str, Any]]:
         """獲取每日明細"""
         breakdown = []
         current_date = config.start_date
@@ -416,7 +446,9 @@ class ReportGenerator:
                     "success_rate": 95.0,
                     "total_cost": 22.50,
                     "avg_cost": 1.50,
-                    "success_rate_class": "status-success" if 95.0 >= 90 else "status-warning",
+                    "success_rate_class": "status-success"
+                    if 95.0 >= 90
+                    else "status-warning",
                 }
             )
             current_date += timedelta(days=1)
@@ -477,7 +509,12 @@ class ReportGenerator:
             return {"title": "成本分布", "path": "", "error": "無數據"}
 
         plt.figure(figsize=(10, 6))
-        plt.pie(providers.values(), labels=providers.keys(), autopct="%1.1f%%", startangle=90)
+        plt.pie(
+            providers.values(),
+            labels=providers.keys(),
+            autopct="%1.1f%%",
+            startangle=90,
+        )
         plt.title("API 供應商成本分布")
 
         chart_path = output_dir / "cost_distribution.png"
@@ -511,7 +548,10 @@ class ReportGenerator:
         plt.savefig(chart_path, dpi=300, bbox_inches="tight")
         plt.close()
 
-        return {"title": "每日成本趨勢", "path": str(chart_path.relative_to(self.reports_dir))}
+        return {
+            "title": "每日成本趨勢",
+            "path": str(chart_path.relative_to(self.reports_dir)),
+        }
 
     async def _create_generation_stats_chart(
         self, metrics: GenerationMetrics, output_dir: Path
@@ -522,14 +562,23 @@ class ReportGenerator:
         colors = ["#28a745", "#dc3545"]
 
         plt.figure(figsize=(8, 6))
-        plt.pie(sizes, labels=labels, colors=colors, autopct="%1.1f%%", startangle=90)
+        plt.pie(
+            sizes,
+            labels=labels,
+            colors=colors,
+            autopct="%1.1f%%",
+            startangle=90,
+        )
         plt.title("影片生成成功率")
 
         chart_path = output_dir / "generation_success_rate.png"
         plt.savefig(chart_path, dpi=300, bbox_inches="tight")
         plt.close()
 
-        return {"title": "影片生成成功率", "path": str(chart_path.relative_to(self.reports_dir))}
+        return {
+            "title": "影片生成成功率",
+            "path": str(chart_path.relative_to(self.reports_dir)),
+        }
 
     async def _create_platform_distribution_chart(
         self, platforms: Dict[str, int], output_dir: Path
@@ -539,7 +588,11 @@ class ReportGenerator:
             return {"title": "平台分布", "path": "", "error": "無數據"}
 
         plt.figure(figsize=(10, 6))
-        plt.bar(platforms.keys(), platforms.values(), color=["#1f77b4", "#ff7f0e", "#2ca02c"])
+        plt.bar(
+            platforms.keys(),
+            platforms.values(),
+            color=["#1f77b4", "#ff7f0e", "#2ca02c"],
+        )
         plt.title("各平台影片數量分布")
         plt.xlabel("平台")
         plt.ylabel("影片數量")
@@ -557,7 +610,10 @@ class ReportGenerator:
         }
 
     async def _prepare_template_data(
-        self, data: Dict[str, Any], charts: List[Dict[str, str]], config: ReportConfig
+        self,
+        data: Dict[str, Any],
+        charts: List[Dict[str, str]],
+        config: ReportConfig,
     ) -> Dict[str, Any]:
         """準備模板數據"""
         metrics = data["generation_metrics"]
@@ -571,11 +627,12 @@ class ReportGenerator:
                 "status_class": "status-success",
             },
             {
-                "value": f"{(metrics.successful_generations/metrics.total_videos)*100:.1f}%",
+                "value": f"{(metrics.successful_generations / metrics.total_videos) * 100:.1f}%",
                 "label": "成功率",
                 "status_class": (
                     "status-success"
-                    if metrics.successful_generations / metrics.total_videos > 0.9
+                    if metrics.successful_generations / metrics.total_videos
+                    > 0.9
                     else "status-warning"
                 ),
             },
@@ -600,7 +657,9 @@ class ReportGenerator:
                     {
                         "category": provider,
                         "amount": amount,
-                        "percentage": (amount / total_cost) * 100 if total_cost > 0 else 0,
+                        "percentage": (amount / total_cost) * 100
+                        if total_cost > 0
+                        else 0,
                         "trend": "↗️",
                         "trend_class": "status-success",
                     }
@@ -612,7 +671,11 @@ class ReportGenerator:
             "generation_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
             "key_metrics": key_metrics,
             "cost_analysis": config.include_cost_analysis,
-            "cost_charts": [chart for chart in charts if "cost" in chart.get("title", "").lower()],
+            "cost_charts": [
+                chart
+                for chart in charts
+                if "cost" in chart.get("title", "").lower()
+            ],
             "generation_charts": [
                 chart
                 for chart in charts
@@ -623,15 +686,15 @@ class ReportGenerator:
             "detailed_data": data["daily_breakdown"],
         }
 
-    async def _render_html_report(self, template_data: Dict[str, Any], config: ReportConfig) -> str:
+    async def _render_html_report(
+        self, template_data: Dict[str, Any], config: ReportConfig
+    ) -> str:
         """渲染 HTML 報告"""
         template = self.jinja_env.get_template("report.html")
         html_content = template.render(**template_data)
 
         # 保存報告
-        report_filename = (
-            f"{config.report_type}_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
-        )
+        report_filename = f"{config.report_type}_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
         report_path = self.reports_dir / report_filename
 
         with open(report_path, "w", encoding="utf-8") as f:
@@ -640,16 +703,18 @@ class ReportGenerator:
         logger.info(f"HTML 報告已生成: {report_path}")
         return str(report_path)
 
-    async def _render_json_report(self, template_data: Dict[str, Any], config: ReportConfig) -> str:
+    async def _render_json_report(
+        self, template_data: Dict[str, Any], config: ReportConfig
+    ) -> str:
         """渲染 JSON 報告"""
         # 保存報告
-        report_filename = (
-            f"{config.report_type}_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
-        )
+        report_filename = f"{config.report_type}_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
         report_path = self.reports_dir / report_filename
 
         with open(report_path, "w", encoding="utf-8") as f:
-            json.dump(template_data, f, indent=2, ensure_ascii=False, default=str)
+            json.dump(
+                template_data, f, indent=2, ensure_ascii=False, default=str
+            )
 
         logger.info(f"JSON 報告已生成: {report_path}")
         return str(report_path)
diff --git a/auto_generate_video_fold6/monitoring/tracing/opentelemetry_middleware.py b/auto_generate_video_fold6/monitoring/tracing/opentelemetry_middleware.py
index caad384..970969a 100644
--- a/auto_generate_video_fold6/monitoring/tracing/opentelemetry_middleware.py
+++ b/auto_generate_video_fold6/monitoring/tracing/opentelemetry_middleware.py
@@ -9,7 +9,9 @@ from typing import Callable, Dict, Any
 from fastapi import FastAPI, Request, Response
 from opentelemetry import trace, baggage
 from opentelemetry.exporter.jaeger.thrift import JaegerExporter
-from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
+from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import (
+    OTLPSpanExporter,
+)
 from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor
 from opentelemetry.instrumentation.httpx import HTTPXClientInstrumentor
 from opentelemetry.instrumentation.psycopg2 import Psycopg2Instrumentor
@@ -47,7 +49,9 @@ class OpenTelemetryMiddleware:
                 ResourceAttributes.SERVICE_NAME: service_name,
                 ResourceAttributes.SERVICE_VERSION: service_version,
                 ResourceAttributes.DEPLOYMENT_ENVIRONMENT: environment,
-                ResourceAttributes.SERVICE_INSTANCE_ID: os.getenv("HOSTNAME", "unknown"),
+                ResourceAttributes.SERVICE_INSTANCE_ID: os.getenv(
+                    "HOSTNAME", "unknown"
+                ),
             }
         )
 
@@ -71,7 +75,9 @@ class OpenTelemetryMiddleware:
                 agent_host_name=jaeger_endpoint.split("://")[1].split(":")[0],
                 agent_port=int(jaeger_endpoint.split(":")[-1]),
             )
-            tracer_provider.add_span_processor(BatchSpanProcessor(jaeger_exporter))
+            tracer_provider.add_span_processor(
+                BatchSpanProcessor(jaeger_exporter)
+            )
 
         # OTLP 導出器 (優先使用)
         otlp_endpoint = otlp_endpoint or os.getenv(
@@ -79,8 +85,12 @@ class OpenTelemetryMiddleware:
         )
         if otlp_endpoint:
             try:
-                otlp_exporter = OTLPSpanExporter(endpoint=otlp_endpoint, insecure=True)
-                tracer_provider.add_span_processor(BatchSpanProcessor(otlp_exporter))
+                otlp_exporter = OTLPSpanExporter(
+                    endpoint=otlp_endpoint, insecure=True
+                )
+                tracer_provider.add_span_processor(
+                    BatchSpanProcessor(otlp_exporter)
+                )
                 logger.info(f"OTLP exporter configured: {otlp_endpoint}")
             except Exception as e:
                 logger.warning(f"Failed to setup OTLP exporter: {e}")
@@ -115,7 +125,9 @@ class OpenTelemetryMiddleware:
         # 添加自訂中介軟體
         app.middleware("http")(self._custom_middleware)
 
-    async def _custom_middleware(self, request: Request, call_next: Callable) -> Response:
+    async def _custom_middleware(
+        self, request: Request, call_next: Callable
+    ) -> Response:
         """自訂追蹤中介軟體"""
         # 提取上游追蹤上下文
         headers = dict(request.headers)
@@ -123,7 +135,9 @@ class OpenTelemetryMiddleware:
 
         # 創建新的 span
         with self.tracer.start_as_current_span(
-            f"{request.method} {request.url.path}", context=context, kind=trace.SpanKind.SERVER
+            f"{request.method} {request.url.path}",
+            context=context,
+            kind=trace.SpanKind.SERVER,
         ) as span:
             # 設定基本屬性
             span.set_attributes(
@@ -133,7 +147,9 @@ class OpenTelemetryMiddleware:
                     SpanAttributes.HTTP_SCHEME: request.url.scheme,
                     SpanAttributes.HTTP_HOST: request.url.hostname,
                     SpanAttributes.HTTP_TARGET: request.url.path,
-                    SpanAttributes.USER_AGENT_ORIGINAL: request.headers.get("user-agent", ""),
+                    SpanAttributes.USER_AGENT_ORIGINAL: request.headers.get(
+                        "user-agent", ""
+                    ),
                 }
             )
 
@@ -144,9 +160,15 @@ class OpenTelemetryMiddleware:
                 baggage.set_baggage("user.id", user_id)
 
             # 添加請求 ID 和關聯 ID
-            request_id = request.headers.get("x-request-id") or self._generate_request_id()
-            correlation_id = request.headers.get("x-correlation-id") or self._generate_correlation_id()
-            
+            request_id = (
+                request.headers.get("x-request-id")
+                or self._generate_request_id()
+            )
+            correlation_id = (
+                request.headers.get("x-correlation-id")
+                or self._generate_correlation_id()
+            )
+
             span.set_attribute("request.id", request_id)
             span.set_attribute("correlation.id", correlation_id)
             baggage.set_baggage("request.id", request_id)
@@ -166,7 +188,8 @@ class OpenTelemetryMiddleware:
                 span.set_attributes(
                     {
                         SpanAttributes.HTTP_STATUS_CODE: response.status_code,
-                        "http.response.duration_ms": (time.time() - start_time) * 1000,
+                        "http.response.duration_ms": (time.time() - start_time)
+                        * 1000,
                     }
                 )
 
@@ -174,8 +197,12 @@ class OpenTelemetryMiddleware:
                 for key, value in headers_to_inject.items():
                     response.headers[key] = value
 
-                response.headers["x-trace-id"] = format(span.get_span_context().trace_id, "032x")
-                response.headers["x-span-id"] = format(span.get_span_context().span_id, "016x")
+                response.headers["x-trace-id"] = format(
+                    span.get_span_context().trace_id, "032x"
+                )
+                response.headers["x-span-id"] = format(
+                    span.get_span_context().span_id, "016x"
+                )
                 response.headers["x-request-id"] = request_id
                 response.headers["x-correlation-id"] = correlation_id
 
@@ -202,7 +229,9 @@ class OpenTelemetryMiddleware:
                 import jwt
 
                 token = auth_header[7:]
-                payload = jwt.decode(token, options={"verify_signature": False})
+                payload = jwt.decode(
+                    token, options={"verify_signature": False}
+                )
                 return payload.get("sub") or payload.get("user_id")
             except Exception:
                 pass
@@ -213,21 +242,27 @@ class OpenTelemetryMiddleware:
     def _generate_request_id(self) -> str:
         """生成請求 ID"""
         import uuid
+
         return str(uuid.uuid4())
-    
+
     def _generate_correlation_id(self) -> str:
         """生成關聯 ID"""
         import uuid
+
         return str(uuid.uuid4())
 
-    def create_span(self, name: str, attributes: Dict[str, Any] = None) -> trace.Span:
+    def create_span(
+        self, name: str, attributes: Dict[str, Any] = None
+    ) -> trace.Span:
         """創建新的 span"""
         span = self.tracer.start_span(name)
         if attributes:
             span.set_attributes(attributes)
         return span
 
-    def add_span_event(self, span: trace.Span, name: str, attributes: Dict[str, Any] = None):
+    def add_span_event(
+        self, span: trace.Span, name: str, attributes: Dict[str, Any] = None
+    ):
         """添加 span 事件"""
         span.add_event(name, attributes or {})
 
@@ -286,7 +321,9 @@ def trace_function(operation_name: str = None):
                     return result
                 except Exception as e:
                     span.record_exception(e)
-                    span.set_status(trace.Status(trace.StatusCode.ERROR, str(e)))
+                    span.set_status(
+                        trace.Status(trace.StatusCode.ERROR, str(e))
+                    )
                     raise
 
         @wraps(func)
@@ -308,7 +345,9 @@ def trace_function(operation_name: str = None):
                     return result
                 except Exception as e:
                     span.record_exception(e)
-                    span.set_status(trace.Status(trace.StatusCode.ERROR, str(e)))
+                    span.set_status(
+                        trace.Status(trace.StatusCode.ERROR, str(e))
+                    )
                     raise
 
         import asyncio
@@ -352,12 +391,16 @@ class DatabaseTracing:
 
                         # 記錄結果統計
                         if hasattr(result, "rowcount"):
-                            span.set_attribute("db.rows_affected", result.rowcount)
+                            span.set_attribute(
+                                "db.rows_affected", result.rowcount
+                            )
 
                         return result
                     except Exception as e:
                         span.record_exception(e)
-                        span.set_status(trace.Status(trace.StatusCode.ERROR, str(e)))
+                        span.set_status(
+                            trace.Status(trace.StatusCode.ERROR, str(e))
+                        )
                         raise
 
             return wrapper
@@ -398,13 +441,16 @@ class HTTPClientTracing:
 
                         if hasattr(response, "status_code"):
                             span.set_attribute(
-                                SpanAttributes.HTTP_STATUS_CODE, response.status_code
+                                SpanAttributes.HTTP_STATUS_CODE,
+                                response.status_code,
                             )
 
                         return response
                     except Exception as e:
                         span.record_exception(e)
-                        span.set_status(trace.Status(trace.StatusCode.ERROR, str(e)))
+                        span.set_status(
+                            trace.Status(trace.StatusCode.ERROR, str(e))
+                        )
                         raise
 
             return wrapper
diff --git a/auto_generate_video_fold6/performance/api/response-optimization.py b/auto_generate_video_fold6/performance/api/response-optimization.py
index ce2cf95..3e1e913 100644
--- a/auto_generate_video_fold6/performance/api/response-optimization.py
+++ b/auto_generate_video_fold6/performance/api/response-optimization.py
@@ -39,7 +39,9 @@ class PerformanceMiddleware(BaseHTTPMiddleware):
 
         # 記錄請求開始
         if self.enable_detailed_logging:
-            logger.info(f"[{request_id}] {request.method} {request.url.path} started")
+            logger.info(
+                f"[{request_id}] {request.method} {request.url.path} started"
+            )
 
         try:
             response = await call_next(request)
@@ -71,7 +73,9 @@ class PerformanceMiddleware(BaseHTTPMiddleware):
             )
             raise
 
-    def _collect_metrics(self, request: Request, response: Response, process_time: float):
+    def _collect_metrics(
+        self, request: Request, response: Response, process_time: float
+    ):
         """收集效能指標"""
         metric = {
             "method": request.method,
@@ -90,7 +94,9 @@ class PerformanceMiddleware(BaseHTTPMiddleware):
 class CompressionMiddleware(BaseHTTPMiddleware):
     """智慧壓縮中介軟體"""
 
-    def __init__(self, app, minimum_size: int = 1024, compression_level: int = 6):
+    def __init__(
+        self, app, minimum_size: int = 1024, compression_level: int = 6
+    ):
         super().__init__(app)
         self.minimum_size = minimum_size
         self.compression_level = compression_level
@@ -137,7 +143,9 @@ class CompressionMiddleware(BaseHTTPMiddleware):
             return response
 
         # 執行 gzip 壓縮
-        compressed_body = gzip.compress(body, compresslevel=self.compression_level)
+        compressed_body = gzip.compress(
+            body, compresslevel=self.compression_level
+        )
 
         # 更新標頭
         response.headers["content-encoding"] = "gzip"
@@ -219,7 +227,12 @@ class CacheMiddleware(BaseHTTPMiddleware):
             return False
 
         # 可快取的路徑
-        cacheable_paths = ["/api/trends", "/api/user/profile", "/api/analytics", "/api/models/list"]
+        cacheable_paths = [
+            "/api/trends",
+            "/api/user/profile",
+            "/api/analytics",
+            "/api/models/list",
+        ]
 
         return any(path in request.url.path for path in cacheable_paths)
 
@@ -240,7 +253,9 @@ class CacheMiddleware(BaseHTTPMiddleware):
                 "headers": dict(response.headers),
             }
 
-            await self.cache_manager.set(cache_key, cache_data, self.default_ttl)
+            await self.cache_manager.set(
+                cache_key, cache_data, self.default_ttl
+            )
             logger.debug(f"Cached response for key {cache_key[:16]}")
 
         except Exception as e:
@@ -340,12 +355,15 @@ def create_optimized_app(
     # 效能監控中介軟體
     if enable_performance_logging:
         app.add_middleware(
-            PerformanceMiddleware, enable_detailed_logging=enable_performance_logging
+            PerformanceMiddleware,
+            enable_detailed_logging=enable_performance_logging,
         )
 
     # 快取中介軟體
     if cache_manager:
-        app.add_middleware(CacheMiddleware, cache_manager=cache_manager, default_ttl=300)
+        app.add_middleware(
+            CacheMiddleware, cache_manager=cache_manager, default_ttl=300
+        )
 
     # 速率限制中介軟體
     if rate_limiter:
@@ -353,7 +371,9 @@ def create_optimized_app(
 
     # 壓縮中介軟體
     if enable_compression:
-        app.add_middleware(CompressionMiddleware, minimum_size=1024, compression_level=6)
+        app.add_middleware(
+            CompressionMiddleware, minimum_size=1024, compression_level=6
+        )
 
     return app
 
@@ -388,7 +408,9 @@ def async_cache(ttl: int = 300):
 
             # 清理過期快取
             if len(cache) > 1000:  # 限制快取大小
-                expired_keys = [k for k, t in cache_times.items() if now - t > ttl]
+                expired_keys = [
+                    k for k, t in cache_times.items() if now - t > ttl
+                ]
                 for k in expired_keys:
                     cache.pop(k, None)
                     cache_times.pop(k, None)
@@ -420,7 +442,9 @@ def batch_processor(batch_size: int = 10, timeout: float = 1.0):
                 pending_requests.clear()
             else:
                 # 設置超時處理
-                asyncio.create_task(_timeout_handler(func, pending_requests, timeout))
+                asyncio.create_task(
+                    _timeout_handler(func, pending_requests, timeout)
+                )
 
             return await future
 
@@ -461,7 +485,9 @@ def batch_processor(batch_size: int = 10, timeout: float = 1.0):
 # 使用範例
 if __name__ == "__main__":
     # 創建優化的應用
-    app = create_optimized_app(enable_compression=True, enable_performance_logging=True)
+    app = create_optimized_app(
+        enable_compression=True, enable_performance_logging=True
+    )
 
     @app.get("/api/health")
     async def health_check():
@@ -472,6 +498,9 @@ if __name__ == "__main__":
     async def test_cache():
         # 模擬慢速操作
         await asyncio.sleep(1)
-        return {"data": "cached_result", "timestamp": datetime.now().isoformat()}
+        return {
+            "data": "cached_result",
+            "timestamp": datetime.now().isoformat(),
+        }
 
     logger.info("API optimization configured successfully")
diff --git a/auto_generate_video_fold6/performance/benchmarking/performance-tests.py b/auto_generate_video_fold6/performance/benchmarking/performance-tests.py
index 4bbf3cb..ad4d5eb 100644
--- a/auto_generate_video_fold6/performance/benchmarking/performance-tests.py
+++ b/auto_generate_video_fold6/performance/benchmarking/performance-tests.py
@@ -73,7 +73,9 @@ class PerformanceBenchmark:
 
             request_start = time.time()
             try:
-                async with session.get(f"{self.base_url}{endpoint}", headers=headers) as response:
+                async with session.get(
+                    f"{self.base_url}{endpoint}", headers=headers
+                ) as response:
                     await response.text()
                     request_time = time.time() - request_start
                     response_times.append(request_time)
@@ -122,13 +124,17 @@ class PerformanceBenchmark:
             successful_requests=successful_requests,
             failed_requests=failed_requests,
             duration_seconds=total_time,
-            requests_per_second=total_requests / total_time if total_time > 0 else 0,
+            requests_per_second=total_requests / total_time
+            if total_time > 0
+            else 0,
             average_response_time=avg_response_time,
             min_response_time=min_response_time,
             max_response_time=max_response_time,
             percentile_95=percentile_95,
             percentile_99=percentile_99,
-            error_rate=failed_requests / total_requests if total_requests > 0 else 0,
+            error_rate=failed_requests / total_requests
+            if total_requests > 0
+            else 0,
             timestamp=datetime.now(),
         )
 
@@ -182,12 +188,16 @@ class PerformanceBenchmark:
             failed_requests=failed_queries,
             duration_seconds=total_time,
             requests_per_second=total_queries / total_time,
-            average_response_time=statistics.mean(query_times) if query_times else 0,
+            average_response_time=statistics.mean(query_times)
+            if query_times
+            else 0,
             min_response_time=min(query_times) if query_times else 0,
             max_response_time=max(query_times) if query_times else 0,
             percentile_95=np.percentile(query_times, 95) if query_times else 0,
             percentile_99=np.percentile(query_times, 99) if query_times else 0,
-            error_rate=failed_queries / total_queries if total_queries > 0 else 0,
+            error_rate=failed_queries / total_queries
+            if total_queries > 0
+            else 0,
             timestamp=datetime.now(),
         )
 
@@ -252,12 +262,20 @@ class PerformanceBenchmark:
             failed_requests=failed_operations,
             duration_seconds=total_time,
             requests_per_second=total_operations / total_time,
-            average_response_time=statistics.mean(operation_times) if operation_times else 0,
+            average_response_time=statistics.mean(operation_times)
+            if operation_times
+            else 0,
             min_response_time=min(operation_times) if operation_times else 0,
             max_response_time=max(operation_times) if operation_times else 0,
-            percentile_95=np.percentile(operation_times, 95) if operation_times else 0,
-            percentile_99=np.percentile(operation_times, 99) if operation_times else 0,
-            error_rate=failed_operations / total_operations if total_operations > 0 else 0,
+            percentile_95=np.percentile(operation_times, 95)
+            if operation_times
+            else 0,
+            percentile_99=np.percentile(operation_times, 99)
+            if operation_times
+            else 0,
+            error_rate=failed_operations / total_operations
+            if total_operations > 0
+            else 0,
             timestamp=datetime.now(),
         )
 
@@ -315,7 +333,9 @@ class PerformanceBenchmark:
                 "min": min(cpu_usage) if cpu_usage else 0,
             },
             "memory": {
-                "average": statistics.mean(memory_usage) if memory_usage else 0,
+                "average": statistics.mean(memory_usage)
+                if memory_usage
+                else 0,
                 "max": max(memory_usage) if memory_usage else 0,
                 "min": min(memory_usage) if memory_usage else 0,
             },
@@ -340,7 +360,9 @@ class PerformanceBenchmark:
         print(f"   Failed: {result.failed_requests}")
         print(f"   Duration: {result.duration_seconds:.2f}s")
         print(f"   RPS: {result.requests_per_second:.2f}")
-        print(f"   Avg Response Time: {result.average_response_time * 1000:.2f}ms")
+        print(
+            f"   Avg Response Time: {result.average_response_time * 1000:.2f}ms"
+        )
         print(f"   95th Percentile: {result.percentile_95 * 1000:.2f}ms")
         print(f"   99th Percentile: {result.percentile_99 * 1000:.2f}ms")
         print(f"   Error Rate: {result.error_rate * 100:.2f}%")
@@ -351,7 +373,9 @@ class PerformanceBenchmark:
             "generated_at": datetime.now().isoformat(),
             "test_summary": {
                 "total_tests": len(self.results),
-                "tests_completed": len([r for r in self.results if r.error_rate < 0.05]),
+                "tests_completed": len(
+                    [r for r in self.results if r.error_rate < 0.05]
+                ),
             },
             "results": [],
         }
@@ -365,7 +389,8 @@ class PerformanceBenchmark:
                     "failed_requests": result.failed_requests,
                     "duration_seconds": result.duration_seconds,
                     "requests_per_second": result.requests_per_second,
-                    "average_response_time_ms": result.average_response_time * 1000,
+                    "average_response_time_ms": result.average_response_time
+                    * 1000,
                     "percentile_95_ms": result.percentile_95 * 1000,
                     "percentile_99_ms": result.percentile_99 * 1000,
                     "error_rate_percent": result.error_rate * 100,
diff --git a/auto_generate_video_fold6/performance/caching/cache-strategies.py b/auto_generate_video_fold6/performance/caching/cache-strategies.py
index 3301a39..a05de5a 100644
--- a/auto_generate_video_fold6/performance/caching/cache-strategies.py
+++ b/auto_generate_video_fold6/performance/caching/cache-strategies.py
@@ -39,7 +39,9 @@ class CacheManager:
         """獲取快取值"""
         try:
             if self._is_circuit_breaker_open():
-                logger.warning(f"Circuit breaker open, skipping cache get for {key}")
+                logger.warning(
+                    f"Circuit breaker open, skipping cache get for {key}"
+                )
                 return default
 
             value = await self.redis.get(key)
@@ -151,14 +153,19 @@ class CacheManager:
 
     def _is_circuit_breaker_open(self) -> bool:
         """檢查斷路器狀態"""
-        if self.circuit_breaker_failures < self.config.circuit_breaker_threshold:
+        if (
+            self.circuit_breaker_failures
+            < self.config.circuit_breaker_threshold
+        ):
             return False
 
         if self.circuit_breaker_last_failure is None:
             return False
 
         # 30秒後重試
-        return (datetime.now() - self.circuit_breaker_last_failure).seconds < 30
+        return (
+            datetime.now() - self.circuit_breaker_last_failure
+        ).seconds < 30
 
     def _handle_failure(self):
         """處理失敗"""
@@ -254,16 +261,22 @@ def cache_result(ttl: int = 3600, key_prefix: str = None):
     return decorator
 
 
-def _generate_cache_key(func: Callable, prefix: str, args: tuple, kwargs: dict) -> str:
+def _generate_cache_key(
+    func: Callable, prefix: str, args: tuple, kwargs: dict
+) -> str:
     """生成快取鍵"""
     func_name = f"{func.__module__}.{func.__name__}"
 
     # 排除特殊參數
-    filtered_kwargs = {k: v for k, v in kwargs.items() if k not in ["cache_manager", "db"]}
+    filtered_kwargs = {
+        k: v for k, v in kwargs.items() if k not in ["cache_manager", "db"]
+    }
 
     # 生成參數雜湊
     args_str = ":".join(str(arg) for arg in args)
-    kwargs_str = ":".join(f"{k}={v}" for k, v in sorted(filtered_kwargs.items()))
+    kwargs_str = ":".join(
+        f"{k}={v}" for k, v in sorted(filtered_kwargs.items())
+    )
 
     content = f"{func_name}:{args_str}:{kwargs_str}"
     hash_key = hashlib.sha256(content.encode()).hexdigest()
@@ -282,7 +295,9 @@ class SessionCache:
 
     async def create_session(self, user_id: int, session_data: dict) -> str:
         """創建用戶會話"""
-        session_id = CacheKeyGenerator.generate_hash(user_id, datetime.now().isoformat())
+        session_id = CacheKeyGenerator.generate_hash(
+            user_id, datetime.now().isoformat()
+        )
         session_key = CacheKeyGenerator.user_session(user_id)
 
         session_info = {
@@ -355,7 +370,9 @@ class ModelCache:
         self.cache = cache_manager
         self.inference_ttl = 3600  # 1小時
 
-    async def cache_inference_result(self, model_id: int, input_data: dict, result: Any) -> bool:
+    async def cache_inference_result(
+        self, model_id: int, input_data: dict, result: Any
+    ) -> bool:
         """快取推論結果"""
         input_hash = CacheKeyGenerator.generate_hash(str(input_data))
         key = CacheKeyGenerator.inference_result(model_id, input_hash)
@@ -369,7 +386,9 @@ class ModelCache:
 
         return await self.cache.set(key, cache_data, self.inference_ttl)
 
-    async def get_cached_inference(self, model_id: int, input_data: dict) -> Optional[Any]:
+    async def get_cached_inference(
+        self, model_id: int, input_data: dict
+    ) -> Optional[Any]:
         """獲取快取的推論結果"""
         input_hash = CacheKeyGenerator.generate_hash(str(input_data))
         key = CacheKeyGenerator.inference_result(model_id, input_hash)
@@ -409,7 +428,9 @@ async def example_usage():
 
     # 使用速率限制
     rate_limit = RateLimitCache(cache_manager)
-    allowed, count = await rate_limit.check_rate_limit(123, "api/upload", 10, 60)
+    allowed, count = await rate_limit.check_rate_limit(
+        123, "api/upload", 10, 60
+    )
     print(f"允許請求: {allowed}, 當前計數: {count}")
 
 
diff --git a/auto_generate_video_fold6/pyproject.toml b/auto_generate_video_fold6/pyproject.toml
index db9f914..0fb2be7 100644
--- a/auto_generate_video_fold6/pyproject.toml
+++ b/auto_generate_video_fold6/pyproject.toml
@@ -182,20 +182,6 @@ skips = ["*_test.py", "test_*.py"]
 [tool.ruff]
 target-version = "py311"
 line-length = 79
-select = [
-    "E",  # pycodestyle errors
-    "W",  # pycodestyle warnings
-    "F",  # pyflakes
-    "I",  # isort
-    "B",  # flake8-bugbear
-    "C4", # flake8-comprehensions
-    "UP", # pyupgrade
-]
-ignore = [
-    "E501",  # line too long, handled by black
-    "B008",  # do not perform function calls in argument defaults
-    "C901",  # too complex
-]
 exclude = [
     ".bzr",
     ".direnv",
@@ -219,11 +205,27 @@ exclude = [
     "frontend",
 ]
 
-[tool.ruff.per-file-ignores]
+[tool.ruff.lint]
+select = [
+    "E",  # pycodestyle errors
+    "W",  # pycodestyle warnings
+    "F",  # pyflakes
+    "I",  # isort
+    "B",  # flake8-bugbear
+    "C4", # flake8-comprehensions
+    "UP", # pyupgrade
+]
+ignore = [
+    "E501",  # line too long, handled by black
+    "B008",  # do not perform function calls in argument defaults
+    "C901",  # too complex
+]
+
+[tool.ruff.lint.per-file-ignores]
 "__init__.py" = ["F401"]
 "services/*/tests/*" = ["B011", "B018"]
 
-[tool.ruff.mccabe]
+[tool.ruff.lint.mccabe]
 max-complexity = 10
 
 # Flake8 配置
diff --git a/auto_generate_video_fold6/scripts/auto_trends_video.py b/auto_generate_video_fold6/scripts/auto_trends_video.py
index 0f30a25..f89e96c 100644
--- a/auto_generate_video_fold6/scripts/auto_trends_video.py
+++ b/auto_generate_video_fold6/scripts/auto_trends_video.py
@@ -38,7 +38,8 @@ except ImportError:
 
 # 設置日誌
 logging.basicConfig(
-    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
+    level=logging.INFO,
+    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
 )
 logger = logging.getLogger(__name__)
 
@@ -52,7 +53,9 @@ class AutoTrendsVideoGenerator:
             if mode:
                 config_manager.set_mode(mode)
             self.config = self._load_unified_config()
-            logger.info(f"使用統一配置管理器，當前模式: {config_manager.current_mode}")
+            logger.info(
+                f"使用統一配置管理器，當前模式: {config_manager.current_mode}"
+            )
         else:
             self.config = self._load_legacy_config(config_file)
             logger.info("使用傳統配置方式")
@@ -61,7 +64,9 @@ class AutoTrendsVideoGenerator:
         self.services = self._setup_services()
 
         # 設置輸出目錄
-        self.output_dir = Path(self.config.get("output_dir", "./generated_videos"))
+        self.output_dir = Path(
+            self.config.get("output_dir", "./generated_videos")
+        )
         self.output_dir.mkdir(parents=True, exist_ok=True)
 
         # 影片生成設定
@@ -91,24 +96,38 @@ class AutoTrendsVideoGenerator:
             self.cost_tracker = None
             self.budget_controller = None
 
-        logger.info(f"影片生成器初始化完成，每日限制: {self.video_configs['max_videos_per_run']}")
+        logger.info(
+            f"影片生成器初始化完成，每日限制: {self.video_configs['max_videos_per_run']}"
+        )
 
     def _setup_services(self) -> dict:
         """設置服務配置"""
         if CONFIG_MANAGER_AVAILABLE:
             return {
-                "trend_service": get_config("services.trend_service.url", "http://localhost:8001"),
-                "video_service": get_config("services.video_service.url", "http://localhost:8002"),
-                "ai_service": get_config("services.ai_service.url", "http://localhost:8003"),
+                "trend_service": get_config(
+                    "services.trend_service.url", "http://localhost:8001"
+                ),
+                "video_service": get_config(
+                    "services.video_service.url", "http://localhost:8002"
+                ),
+                "ai_service": get_config(
+                    "services.ai_service.url", "http://localhost:8003"
+                ),
                 "social_service": get_config(
                     "services.social_service.url", "http://localhost:8004"
                 ),
             }
         else:
             return {
-                "trend_service": self.config.get("trend_service_url", "http://localhost:8001"),
-                "video_service": self.config.get("video_service_url", "http://localhost:8002"),
-                "ai_service": self.config.get("ai_service_url", "http://localhost:8003"),
+                "trend_service": self.config.get(
+                    "trend_service_url", "http://localhost:8001"
+                ),
+                "video_service": self.config.get(
+                    "video_service_url", "http://localhost:8002"
+                ),
+                "ai_service": self.config.get(
+                    "ai_service_url", "http://localhost:8003"
+                ),
             }
 
     def _setup_video_configs(self) -> dict:
@@ -116,16 +135,25 @@ class AutoTrendsVideoGenerator:
         if CONFIG_MANAGER_AVAILABLE:
             generation_config = get_config("generation", {})
             return {
-                "max_videos_per_run": generation_config.get("daily_video_limit", 5),
+                "max_videos_per_run": generation_config.get(
+                    "daily_video_limit", 5
+                ),
                 "batch_size": generation_config.get("batch_size", 1),
-                "max_concurrent_jobs": generation_config.get("max_concurrent_jobs", 2),
-                "video_duration": generation_config.get("duration_range", [30, 60])[0],  # 取最小值
+                "max_concurrent_jobs": generation_config.get(
+                    "max_concurrent_jobs", 2
+                ),
+                "video_duration": generation_config.get(
+                    "duration_range", [30, 60]
+                )[0],  # 取最小值
                 "platforms": generation_config.get("platforms", ["tiktok"]),
                 "categories": get_config(
-                    "content.content_categories", ["technology", "entertainment", "lifestyle"]
+                    "content.content_categories",
+                    ["technology", "entertainment", "lifestyle"],
                 ),
                 "languages": [get_config("content.language", "zh-TW")],
-                "quality_preset": generation_config.get("quality_preset", "medium"),
+                "quality_preset": generation_config.get(
+                    "quality_preset", "medium"
+                ),
             }
         else:
             return {
@@ -134,7 +162,9 @@ class AutoTrendsVideoGenerator:
                 "max_concurrent_jobs": 2,
                 "video_duration": self.config.get("video_duration", 30),
                 "platforms": self.config.get("target_platforms", ["tiktok"]),
-                "categories": self.config.get("categories", ["technology", "entertainment"]),
+                "categories": self.config.get(
+                    "categories", ["technology", "entertainment"]
+                ),
                 "languages": self.config.get("languages", ["zh-TW"]),
                 "quality_preset": "medium",
             }
@@ -148,11 +178,17 @@ class AutoTrendsVideoGenerator:
     def _load_unified_config(self) -> dict:
         """載入統一配置"""
         return {
-            "output_dir": get_config("storage.output_dir", "./generated_videos"),
-            "quality_threshold": get_config("generation.quality_threshold", 0.7),
+            "output_dir": get_config(
+                "storage.output_dir", "./generated_videos"
+            ),
+            "quality_threshold": get_config(
+                "generation.quality_threshold", 0.7
+            ),
             "schedule_interval": 1800,  # 默認30分鐘
             "daily_budget": get_config("cost_control.daily_budget_usd", 50.0),
-            "stop_on_budget_exceeded": get_config("cost_control.stop_on_budget_exceeded", True),
+            "stop_on_budget_exceeded": get_config(
+                "cost_control.stop_on_budget_exceeded", True
+            ),
         }
 
     def _load_legacy_config(self, config_file: str) -> dict:
@@ -200,12 +236,18 @@ class AutoTrendsVideoGenerator:
             logger.info(f"找到 {len(trending_keywords)} 個熱門關鍵字")
 
             # 2. 選擇最佳關鍵字
-            selected_keywords = await self._select_best_keywords(trending_keywords)
+            selected_keywords = await self._select_best_keywords(
+                trending_keywords
+            )
 
-            logger.info(f"選擇了 {len(selected_keywords)} 個關鍵字進行影片生成")
+            logger.info(
+                f"選擇了 {len(selected_keywords)} 個關鍵字進行影片生成"
+            )
 
             # 3. 批次生成影片
-            generation_results = await self._batch_generate_videos(selected_keywords)
+            generation_results = await self._batch_generate_videos(
+                selected_keywords
+            )
 
             # 4. 處理結果
             await self._process_results(generation_results)
@@ -228,7 +270,10 @@ class AutoTrendsVideoGenerator:
             # 2. 檢查預算狀態 (使用新的預算控制器)
             if COST_MONITORING_AVAILABLE and self.budget_controller:
                 estimated_cost = self._estimate_batch_cost()
-                can_proceed, message = await self.budget_controller.pre_operation_check(
+                (
+                    can_proceed,
+                    message,
+                ) = await self.budget_controller.pre_operation_check(
                     "batch_generation", estimated_cost
                 )
                 if not can_proceed:
@@ -238,9 +283,13 @@ class AutoTrendsVideoGenerator:
             else:
                 # 舊版預算檢查
                 if CONFIG_MANAGER_AVAILABLE:
-                    daily_budget = get_config("cost_control.daily_budget_usd", 50.0)
+                    daily_budget = get_config(
+                        "cost_control.daily_budget_usd", 50.0
+                    )
                     if self.cost_tracker["daily_cost"] >= daily_budget:
-                        logger.info(f"已達每日預算限制 (${daily_budget})，跳過生成")
+                        logger.info(
+                            f"已達每日預算限制 (${daily_budget})，跳過生成"
+                        )
                         return False
 
             # 3. 檢查每日限制
@@ -278,7 +327,8 @@ class AutoTrendsVideoGenerator:
 
                 estimated_per_video = 0.11  # 保守估計
                 planned_videos = min(
-                    batch_size, max_videos - self.cost_tracker["videos_generated_today"]
+                    batch_size,
+                    max_videos - self.cost_tracker["videos_generated_today"],
                 )
 
                 return max(0, planned_videos * estimated_per_video)
@@ -293,7 +343,11 @@ class AutoTrendsVideoGenerator:
         """檢查服務健康狀態"""
         try:
             healthy_services = 0
-            required_services = ["trend_service", "ai_service", "video_service"]
+            required_services = [
+                "trend_service",
+                "ai_service",
+                "video_service",
+            ]
 
             for service_name in required_services:
                 service_url = self.services.get(service_name)
@@ -310,17 +364,23 @@ class AutoTrendsVideoGenerator:
                                 healthy_services += 1
                                 logger.debug(f"{service_name} 健康狀態正常")
                             else:
-                                logger.warning(f"{service_name} 健康檢查失敗: {resp.status}")
+                                logger.warning(
+                                    f"{service_name} 健康檢查失敗: {resp.status}"
+                                )
 
                 except Exception as e:
                     logger.warning(f"{service_name} 連接失敗: {e}")
 
             # 至少需要2個服務正常運行
             if healthy_services >= 2:
-                logger.info(f"服務健康檢查通過 ({healthy_services}/{len(required_services)})")
+                logger.info(
+                    f"服務健康檢查通過 ({healthy_services}/{len(required_services)})"
+                )
                 return True
             else:
-                logger.error(f"服務健康檢查失敗 ({healthy_services}/{len(required_services)})")
+                logger.error(
+                    f"服務健康檢查失敗 ({healthy_services}/{len(required_services)})"
+                )
                 return False
 
         except Exception as e:
@@ -335,17 +395,23 @@ class AutoTrendsVideoGenerator:
             # 從多個類別獲取關鍵字
             for category in self.video_configs["categories"]:
                 async with aiohttp.ClientSession() as session:
-                    url = f"{self.services['trend_service']}/api/trends/keywords"
+                    url = (
+                        f"{self.services['trend_service']}/api/trends/keywords"
+                    )
                     params = {"category": category, "geo": "TW"}
 
                     async with session.get(url, params=params) as resp:
                         if resp.status == 200:
                             data = await resp.json()
                             keywords = data.get("keywords", [])
-                            logger.info(f"從 {category} 類別獲取到 {len(keywords)} 個關鍵字")
+                            logger.info(
+                                f"從 {category} 類別獲取到 {len(keywords)} 個關鍵字"
+                            )
                             all_keywords.extend(keywords)
                         else:
-                            logger.warning(f"獲取 {category} 類別關鍵字失敗: {resp.status}")
+                            logger.warning(
+                                f"獲取 {category} 類別關鍵字失敗: {resp.status}"
+                            )
 
             return all_keywords
 
@@ -405,7 +471,10 @@ class AutoTrendsVideoGenerator:
 
             # 綜合評分
             final_score = (
-                traffic_score * 0.4 + category_score * 0.3 + length_score * 0.2 + time_score * 0.1
+                traffic_score * 0.4
+                + category_score * 0.3
+                + length_score * 0.2
+                + time_score * 0.1
             )
 
             return final_score
@@ -428,21 +497,35 @@ class AutoTrendsVideoGenerator:
             # 分批處理
             for i in range(0, len(keywords), batch_size):
                 batch = keywords[i : i + batch_size]
-                logger.info(f"處理批次 {i//batch_size + 1}, 包含 {len(batch)} 個關鍵字")
+                logger.info(
+                    f"處理批次 {i // batch_size + 1}, 包含 {len(batch)} 個關鍵字"
+                )
 
                 # 檢查是否達到每日限制
                 if CONFIG_MANAGER_AVAILABLE:
                     daily_limit = get_config("generation.daily_video_limit", 5)
-                    if self.cost_tracker["videos_generated_today"] >= daily_limit:
+                    if (
+                        self.cost_tracker["videos_generated_today"]
+                        >= daily_limit
+                    ):
                         logger.info(f"已達每日限制 ({daily_limit})，停止生成")
                         break
 
                 # 檢查預算限制
                 if CONFIG_MANAGER_AVAILABLE:
-                    daily_budget = get_config("cost_control.daily_budget_usd", 50.0)
-                    stop_on_budget = get_config("cost_control.stop_on_budget_exceeded", True)
-                    if stop_on_budget and self.cost_tracker["daily_cost"] >= daily_budget:
-                        logger.info(f"已達預算限制 (${daily_budget})，停止生成")
+                    daily_budget = get_config(
+                        "cost_control.daily_budget_usd", 50.0
+                    )
+                    stop_on_budget = get_config(
+                        "cost_control.stop_on_budget_exceeded", True
+                    )
+                    if (
+                        stop_on_budget
+                        and self.cost_tracker["daily_cost"] >= daily_budget
+                    ):
+                        logger.info(
+                            f"已達預算限制 (${daily_budget})，停止生成"
+                        )
                         break
 
                 # 批次內並行處理
@@ -459,14 +542,17 @@ class AutoTrendsVideoGenerator:
                         return await task
 
                 batch_results = await asyncio.gather(
-                    *[bounded_task(task) for task in tasks], return_exceptions=True
+                    *[bounded_task(task) for task in tasks],
+                    return_exceptions=True,
                 )
 
                 results.extend(batch_results)
 
                 # 更新成本追蹤
                 successful_count = sum(
-                    1 for r in batch_results if isinstance(r, dict) and r.get("status") == "success"
+                    1
+                    for r in batch_results
+                    if isinstance(r, dict) and r.get("status") == "success"
                 )
                 self.cost_tracker["videos_generated_today"] += successful_count
 
@@ -524,7 +610,9 @@ class AutoTrendsVideoGenerator:
                                 success=True,
                                 metadata={
                                     "keyword": keyword,
-                                    "video_duration": self.video_configs["video_duration"],
+                                    "video_duration": self.video_configs[
+                                        "video_duration"
+                                    ],
                                 },
                             )
 
@@ -538,19 +626,33 @@ class AutoTrendsVideoGenerator:
                                 success=True,
                                 metadata={
                                     "keyword": keyword,
-                                    "language": self.video_configs["languages"][0],
+                                    "language": self.video_configs[
+                                        "languages"
+                                    ][0],
                                 },
                             )
 
-                        return {"keyword": keyword, "status": "success", "result": result}
+                        return {
+                            "keyword": keyword,
+                            "status": "success",
+                            "result": result,
+                        }
                     else:
                         error_msg = f"影片生成失敗: {resp.status}"
                         logger.error(error_msg)
-                        return {"keyword": keyword, "status": "error", "error": error_msg}
+                        return {
+                            "keyword": keyword,
+                            "status": "error",
+                            "error": error_msg,
+                        }
 
         except Exception as e:
             logger.error(f"生成影片 '{keyword_data.get('keyword')}' 失敗: {e}")
-            return {"keyword": keyword_data.get("keyword"), "status": "error", "error": str(e)}
+            return {
+                "keyword": keyword_data.get("keyword"),
+                "status": "error",
+                "error": str(e),
+            }
 
     async def _generate_script(self, keyword_data: dict) -> str:
         """生成影片腳本"""
@@ -583,11 +685,15 @@ class AutoTrendsVideoGenerator:
                                 tokens_used=500,  # 估算值
                                 request_id=f"script_{keyword}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                                 success=True,
-                                metadata={"keyword": keyword, "category": category},
+                                metadata={
+                                    "keyword": keyword,
+                                    "category": category,
+                                },
                             )
 
                         return result.get(
-                            "script", f"探索 {keyword} 的精彩世界！這個話題正在爆紅中..."
+                            "script",
+                            f"探索 {keyword} 的精彩世界！這個話題正在爆紅中...",
                         )
                     else:
                         # 追蹤失敗的 API 呼叫
@@ -598,11 +704,16 @@ class AutoTrendsVideoGenerator:
                                 operation_type="text_generation",
                                 tokens_used=0,
                                 success=False,
-                                metadata={"keyword": keyword, "error": f"HTTP {resp.status}"},
+                                metadata={
+                                    "keyword": keyword,
+                                    "error": f"HTTP {resp.status}",
+                                },
                             )
 
                         # 備用腳本
-                        return self._generate_fallback_script(keyword, category)
+                        return self._generate_fallback_script(
+                            keyword, category
+                        )
 
         except Exception as e:
             logger.error(f"生成腳本失敗: {e}")
@@ -625,7 +736,9 @@ class AutoTrendsVideoGenerator:
         """儲存影片結果"""
         try:
             timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
-            result_file = self.output_dir / f"{keyword}_{timestamp}_result.json"
+            result_file = (
+                self.output_dir / f"{keyword}_{timestamp}_result.json"
+            )
 
             with open(result_file, "w", encoding="utf-8") as f:
                 json.dump(result, f, ensure_ascii=False, indent=2)
@@ -639,9 +752,15 @@ class AutoTrendsVideoGenerator:
         """處理生成結果"""
         try:
             successful = [
-                r for r in results if isinstance(r, dict) and r.get("status") == "success"
+                r
+                for r in results
+                if isinstance(r, dict) and r.get("status") == "success"
+            ]
+            failed = [
+                r
+                for r in results
+                if isinstance(r, dict) and r.get("status") == "error"
             ]
-            failed = [r for r in results if isinstance(r, dict) and r.get("status") == "error"]
             exceptions = [r for r in results if isinstance(r, Exception)]
 
             logger.info(f"生成結果統計:")
@@ -656,9 +775,13 @@ class AutoTrendsVideoGenerator:
                 "successful": len(successful),
                 "failed": len(failed),
                 "exceptions": len(exceptions),
-                "success_rate": len(successful) / len(results) if results else 0,
+                "success_rate": len(successful) / len(results)
+                if results
+                else 0,
                 "successful_keywords": [r["keyword"] for r in successful],
-                "failed_keywords": [r["keyword"] for r in failed if "keyword" in r],
+                "failed_keywords": [
+                    r["keyword"] for r in failed if "keyword" in r
+                ],
             }
 
             summary_file = (
@@ -736,11 +859,15 @@ class AutoTrendsVideoGenerator:
         """獲取成本摘要"""
         return {
             "daily_cost": self.cost_tracker["daily_cost"],
-            "videos_generated_today": self.cost_tracker["videos_generated_today"],
+            "videos_generated_today": self.cost_tracker[
+                "videos_generated_today"
+            ],
             "api_calls_count": self.cost_tracker["api_calls_count"],
             "daily_budget": self.config.get("daily_budget", 50.0),
             "budget_remaining": max(
-                0, self.config.get("daily_budget", 50.0) - self.cost_tracker["daily_cost"]
+                0,
+                self.config.get("daily_budget", 50.0)
+                - self.cost_tracker["daily_cost"],
             ),
             "videos_remaining": max(
                 0,
@@ -752,16 +879,33 @@ class AutoTrendsVideoGenerator:
 
 async def main():
     """主函數"""
-    parser = argparse.ArgumentParser(description="自動 Google Trends 影片生成器")
+    parser = argparse.ArgumentParser(
+        description="自動 Google Trends 影片生成器"
+    )
     parser.add_argument("--config", "-c", help="配置檔案路徑")
     parser.add_argument("--mode", "-m", help="運行模式 (startup/enterprise)")
-    parser.add_argument("--schedule", "-s", action="store_true", help="啟動排程模式")
-    parser.add_argument("--once", "-o", action="store_true", help="執行一次生成")
+    parser.add_argument(
+        "--schedule", "-s", action="store_true", help="啟動排程模式"
+    )
+    parser.add_argument(
+        "--once", "-o", action="store_true", help="執行一次生成"
+    )
     parser.add_argument("--status", action="store_true", help="顯示當前狀態")
-    parser.add_argument("--cost-summary", action="store_true", help="顯示成本摘要")
-    parser.add_argument("--budget-status", action="store_true", help="顯示預算狀態")
-    parser.add_argument("--cost-report", action="store_true", help="生成成本報告")
-    parser.add_argument("--export-costs", type=int, metavar="DAYS", help="匯出指定天數的成本數據")
+    parser.add_argument(
+        "--cost-summary", action="store_true", help="顯示成本摘要"
+    )
+    parser.add_argument(
+        "--budget-status", action="store_true", help="顯示預算狀態"
+    )
+    parser.add_argument(
+        "--cost-report", action="store_true", help="生成成本報告"
+    )
+    parser.add_argument(
+        "--export-costs",
+        type=int,
+        metavar="DAYS",
+        help="匯出指定天數的成本數據",
+    )
 
     args = parser.parse_args()
 
@@ -786,14 +930,20 @@ async def main():
 
     if args.budget_status:
         if COST_MONITORING_AVAILABLE and generator.budget_controller:
-            budget_status = await generator.budget_controller.check_budget_status()
+            budget_status = (
+                await generator.budget_controller.check_budget_status()
+            )
             print("\n=== 預算狀態 ===")
             print(f"當前成本: ${budget_status['current_cost']:.4f}")
             print(f"預算限制: ${budget_status['budget_limit']:.2f}")
             print(f"剩餘預算: ${budget_status['budget_remaining']:.2f}")
             print(f"使用率: {budget_status['usage_percentage']:.1f}%")
-            print(f"超出預算: {'是' if budget_status['is_over_budget'] else '否'}")
-            print(f"可繼續操作: {'是' if budget_status['can_continue'] else '否'}")
+            print(
+                f"超出預算: {'是' if budget_status['is_over_budget'] else '否'}"
+            )
+            print(
+                f"可繼續操作: {'是' if budget_status['can_continue'] else '否'}"
+            )
         else:
             print("成本監控系統不可用")
         return
@@ -812,7 +962,9 @@ async def main():
             if weekly_report["daily_stats"]:
                 print("\n每日統計:")
                 for date_str, stats in weekly_report["daily_stats"].items():
-                    print(f"  {date_str}: ${stats['cost']:.4f} ({stats['calls']} 次呼叫)")
+                    print(
+                        f"  {date_str}: ${stats['cost']:.4f} ({stats['calls']} 次呼叫)"
+                    )
         else:
             print("成本監控系統不可用")
         return
@@ -820,7 +972,9 @@ async def main():
     if args.export_costs:
         if COST_MONITORING_AVAILABLE and generator.cost_tracker:
             print(f"\n=== 匯出 {args.export_costs} 天成本數據 ===")
-            export_file = await generator.cost_tracker.export_cost_data(args.export_costs)
+            export_file = await generator.cost_tracker.export_cost_data(
+                args.export_costs
+            )
             print(f"成本數據已匯出至: {export_file}")
         else:
             print("成本監控系統不可用")
diff --git a/auto_generate_video_fold6/scripts/backup/backup_system.py b/auto_generate_video_fold6/scripts/backup/backup_system.py
index 5e13e89..e7b7b15 100644
--- a/auto_generate_video_fold6/scripts/backup/backup_system.py
+++ b/auto_generate_video_fold6/scripts/backup/backup_system.py
@@ -94,7 +94,10 @@ class BackupSystem:
                 "retention_policy": {"daily": 7, "weekly": 4, "monthly": 12},
             },
             "storage": {
-                "local": {"enabled": True, "path": "/var/backups/auto-video/local"},
+                "local": {
+                    "enabled": True,
+                    "path": "/var/backups/auto-video/local",
+                },
                 "s3": {
                     "enabled": False,
                     "bucket": "auto-video-backups",
@@ -117,7 +120,10 @@ class BackupSystem:
         logging.basicConfig(
             level=logging.INFO,
             format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
-            handlers=[logging.FileHandler("./logs/backup_system.log"), logging.StreamHandler()],
+            handlers=[
+                logging.FileHandler("./logs/backup_system.log"),
+                logging.StreamHandler(),
+            ],
         )
         return logging.getLogger(__name__)
 
@@ -145,10 +151,14 @@ class BackupSystem:
                 "s3",
                 region_name=s3_config.get("region"),
                 aws_access_key_id=os.getenv(
-                    s3_config.get("access_key", "").replace("${", "").replace("}", "")
+                    s3_config.get("access_key", "")
+                    .replace("${", "")
+                    .replace("}", "")
                 ),
                 aws_secret_access_key=os.getenv(
-                    s3_config.get("secret_key", "").replace("${", "").replace("}", "")
+                    s3_config.get("secret_key", "")
+                    .replace("${", "")
+                    .replace("}", "")
                 ),
             )
         return None
@@ -248,7 +258,9 @@ class BackupSystem:
         except Exception:
             return False
 
-    async def _backup_database(self, job: BackupJob, start_time: datetime) -> BackupResult:
+    async def _backup_database(
+        self, job: BackupJob, start_time: datetime
+    ) -> BackupResult:
         """備份資料庫"""
         timestamp = start_time.strftime("%Y%m%d_%H%M%S")
         backup_filename = f"{job.name}_{timestamp}.sql"
@@ -279,7 +291,9 @@ class BackupSystem:
                 dump_cmd.extend(["--compress=9"])
 
             process = await asyncio.create_subprocess_exec(
-                *dump_cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
+                *dump_cmd,
+                stdout=asyncio.subprocess.PIPE,
+                stderr=asyncio.subprocess.PIPE,
             )
 
             stdout, stderr = await process.communicate()
@@ -317,7 +331,9 @@ class BackupSystem:
                 backup_path.unlink()
             raise e
 
-    async def _backup_files(self, job: BackupJob, start_time: datetime) -> BackupResult:
+    async def _backup_files(
+        self, job: BackupJob, start_time: datetime
+    ) -> BackupResult:
         """備份檔案系統"""
         timestamp = start_time.strftime("%Y%m%d_%H%M%S")
         backup_filename = f"{job.name}_{timestamp}.tar"
@@ -363,7 +379,9 @@ class BackupSystem:
                 backup_path.unlink()
             raise e
 
-    async def _backup_container(self, job: BackupJob, start_time: datetime) -> BackupResult:
+    async def _backup_container(
+        self, job: BackupJob, start_time: datetime
+    ) -> BackupResult:
         """備份 Docker 容器"""
         timestamp = start_time.strftime("%Y%m%d_%H%M%S")
         backup_filename = f"{job.name}_{timestamp}.tar"
@@ -385,14 +403,19 @@ class BackupSystem:
                 )
 
                 gzip_process = await asyncio.create_subprocess_exec(
-                    "gzip", "-c", stdin=process.stdout, stdout=open(backup_path, "wb")
+                    "gzip",
+                    "-c",
+                    stdin=process.stdout,
+                    stdout=open(backup_path, "wb"),
                 )
 
                 await process.wait()
                 await gzip_process.wait()
             else:
                 with open(backup_path, "wb") as f:
-                    process = await asyncio.create_subprocess_exec(*export_cmd, stdout=f)
+                    process = await asyncio.create_subprocess_exec(
+                        *export_cmd, stdout=f
+                    )
                     await process.wait()
 
             if job.encryption:
@@ -422,7 +445,9 @@ class BackupSystem:
                 backup_path.unlink()
             raise e
 
-    async def _backup_configuration(self, job: BackupJob, start_time: datetime) -> BackupResult:
+    async def _backup_configuration(
+        self, job: BackupJob, start_time: datetime
+    ) -> BackupResult:
         """備份配置檔案"""
         timestamp = start_time.strftime("%Y%m%d_%H%M%S")
         backup_filename = f"{job.name}_{timestamp}.tar.gz"
@@ -513,7 +538,9 @@ class BackupSystem:
             raise Exception("Backup file not found")
 
         # 重新計算校驗和
-        current_checksum = await self._calculate_checksum(Path(result.backup_path))
+        current_checksum = await self._calculate_checksum(
+            Path(result.backup_path)
+        )
 
         if current_checksum != result.checksum:
             raise Exception("Backup verification failed: checksum mismatch")
@@ -570,9 +597,13 @@ class BackupSystem:
                 await process.wait()
 
                 if process.returncode == 0:
-                    self.logger.info(f"Backup synced to remote: {backup_file.name}")
+                    self.logger.info(
+                        f"Backup synced to remote: {backup_file.name}"
+                    )
                 else:
-                    raise Exception(f"rsync failed with code {process.returncode}")
+                    raise Exception(
+                        f"rsync failed with code {process.returncode}"
+                    )
 
             except Exception as e:
                 self.logger.error(f"Failed to sync to remote: {e}")
@@ -593,12 +624,15 @@ class BackupSystem:
 
                 async with aiohttp.ClientSession() as session:
                     async with session.post(
-                        "http://alertmanager:9093/api/v1/alerts", json=[alert_data]
+                        "http://alertmanager:9093/api/v1/alerts",
+                        json=[alert_data],
                     ) as response:
                         if response.status == 200:
                             self.logger.info("Backup alert sent successfully")
                         else:
-                            self.logger.error(f"Failed to send backup alert: {response.status}")
+                            self.logger.error(
+                                f"Failed to send backup alert: {response.status}"
+                            )
 
             except Exception as e:
                 self.logger.error(f"Failed to send backup alert: {e}")
@@ -608,7 +642,9 @@ class BackupSystem:
         self.logger.info(f"Starting disaster recovery: {recovery_plan}")
 
         # 載入恢復計劃
-        plan_path = Path(f"./scripts/backup/recovery_plans/{recovery_plan}.yaml")
+        plan_path = Path(
+            f"./scripts/backup/recovery_plans/{recovery_plan}.yaml"
+        )
 
         if not plan_path.exists():
             raise Exception(f"Recovery plan not found: {recovery_plan}")
diff --git a/auto_generate_video_fold6/scripts/backup_manager.py b/auto_generate_video_fold6/scripts/backup_manager.py
index 5dea99f..a5dfa8d 100755
--- a/auto_generate_video_fold6/scripts/backup_manager.py
+++ b/auto_generate_video_fold6/scripts/backup_manager.py
@@ -89,7 +89,10 @@ class PostgreSQLBackup:
                     pg_dump_cmd,
                     stdout=f,
                     stderr=subprocess.PIPE,
-                    env={**os.environ, "PGPASSWORD": self.db_config.get("password", "")},
+                    env={
+                        **os.environ,
+                        "PGPASSWORD": self.db_config.get("password", ""),
+                    },
                 )
 
                 _, stderr = process.communicate()
@@ -101,7 +104,9 @@ class PostgreSQLBackup:
             file_size = os.path.getsize(backup_file)
             checksum = await self._calculate_checksum(backup_file)
 
-            logger.info(f"PostgreSQL 備份完成: {backup_file} ({file_size} bytes)")
+            logger.info(
+                f"PostgreSQL 備份完成: {backup_file} ({file_size} bytes)"
+            )
 
             return {
                 "success": True,
@@ -137,7 +142,10 @@ class PostgreSQLBackup:
                     stdin=f,
                     stdout=subprocess.PIPE,
                     stderr=subprocess.PIPE,
-                    env={**os.environ, "PGPASSWORD": self.db_config.get("password", "")},
+                    env={
+                        **os.environ,
+                        "PGPASSWORD": self.db_config.get("password", ""),
+                    },
                 )
 
                 stdout, stderr = process.communicate()
@@ -189,14 +197,20 @@ class RedisBackup:
                 await asyncio.sleep(1)
 
             # 複製 RDB 檔案
-            redis_dump_path = self.redis_config.get("dump_dir", "/var/lib/redis/dump.rdb")
+            redis_dump_path = self.redis_config.get(
+                "dump_dir", "/var/lib/redis/dump.rdb"
+            )
             if os.path.exists(redis_dump_path):
-                subprocess.run(["cp", redis_dump_path, backup_file], check=True)
+                subprocess.run(
+                    ["cp", redis_dump_path, backup_file], check=True
+                )
 
                 file_size = os.path.getsize(backup_file)
                 checksum = await self._calculate_checksum(backup_file)
 
-                logger.info(f"Redis 備份完成: {backup_file} ({file_size} bytes)")
+                logger.info(
+                    f"Redis 備份完成: {backup_file} ({file_size} bytes)"
+                )
 
                 return {
                     "success": True,
@@ -228,7 +242,10 @@ class FileSystemBackup:
         self.config = config
 
     async def create_backup(
-        self, source_paths: List[str], backup_path: str, exclude_patterns: List[str] = None
+        self,
+        source_paths: List[str],
+        backup_path: str,
+        exclude_patterns: List[str] = None,
     ) -> Dict[str, Any]:
         """創建檔案系統備份"""
 
@@ -245,7 +262,9 @@ class FileSystemBackup:
                         tar.add(
                             source_path,
                             arcname=os.path.basename(source_path),
-                            exclude=self._create_exclude_filter(exclude_patterns or []),
+                            exclude=self._create_exclude_filter(
+                                exclude_patterns or []
+                            ),
                         )
 
             file_size = os.path.getsize(backup_file)
@@ -299,10 +318,14 @@ class S3BackupStorage:
         )
         self.bucket_name = self.s3_config.get("bucket_name")
 
-    async def upload_backup(self, local_file: str, s3_key: str) -> Dict[str, Any]:
+    async def upload_backup(
+        self, local_file: str, s3_key: str
+    ) -> Dict[str, Any]:
         """上傳備份到 S3"""
         try:
-            logger.info(f"上傳備份到 S3: {local_file} -> s3://{self.bucket_name}/{s3_key}")
+            logger.info(
+                f"上傳備份到 S3: {local_file} -> s3://{self.bucket_name}/{s3_key}"
+            )
 
             # 上傳檔案
             self.s3_client.upload_file(local_file, self.bucket_name, s3_key)
@@ -314,7 +337,10 @@ class S3BackupStorage:
                 Tagging={
                     "TagSet": [
                         {"Key": "BackupType", "Value": "AutoVideoSystem"},
-                        {"Key": "CreatedDate", "Value": datetime.utcnow().isoformat()},
+                        {
+                            "Key": "CreatedDate",
+                            "Value": datetime.utcnow().isoformat(),
+                        },
                     ]
                 },
             )
@@ -326,10 +352,14 @@ class S3BackupStorage:
             logger.error(f"S3 上傳失敗: {e}")
             return {"success": False, "error": str(e)}
 
-    async def download_backup(self, s3_key: str, local_file: str) -> Dict[str, Any]:
+    async def download_backup(
+        self, s3_key: str, local_file: str
+    ) -> Dict[str, Any]:
         """從 S3 下載備份"""
         try:
-            logger.info(f"從 S3 下載備份: s3://{self.bucket_name}/{s3_key} -> {local_file}")
+            logger.info(
+                f"從 S3 下載備份: s3://{self.bucket_name}/{s3_key} -> {local_file}"
+            )
 
             self.s3_client.download_file(self.bucket_name, s3_key, local_file)
 
@@ -380,7 +410,9 @@ class BackupManager:
             "s3": {
                 "access_key_id": os.getenv("AWS_ACCESS_KEY_ID", ""),
                 "secret_access_key": os.getenv("AWS_SECRET_ACCESS_KEY", ""),
-                "bucket_name": os.getenv("S3_BACKUP_BUCKET", "auto-video-backups"),
+                "bucket_name": os.getenv(
+                    "S3_BACKUP_BUCKET", "auto-video-backups"
+                ),
                 "region": "us-west-2",
             },
             "backup": {
@@ -424,7 +456,12 @@ class BackupManager:
 
             # 3. 檔案系統備份
             logger.info("執行檔案系統備份...")
-            filesystem_paths = ["./config", "./services", "./monitoring", "./scripts"]
+            filesystem_paths = [
+                "./config",
+                "./services",
+                "./monitoring",
+                "./scripts",
+            ]
             exclude_patterns = ["__pycache__", ".git", "node_modules", "*.log"]
             fs_result = await self.filesystem_backup.create_backup(
                 filesystem_paths, backup_path, exclude_patterns
@@ -439,10 +476,16 @@ class BackupManager:
                 for component, result in backup_results["components"].items():
                     if result.get("success") and "backup_file" in result:
                         backup_file = result["backup_file"]
-                        s3_key = f"backups/{job_id}/{os.path.basename(backup_file)}"
+                        s3_key = (
+                            f"backups/{job_id}/{os.path.basename(backup_file)}"
+                        )
 
-                        s3_result = await self.s3_storage.upload_backup(backup_file, s3_key)
-                        s3_results.append({"component": component, "s3_result": s3_result})
+                        s3_result = await self.s3_storage.upload_backup(
+                            backup_file, s3_key
+                        )
+                        s3_results.append(
+                            {"component": component, "s3_result": s3_result}
+                        )
 
                 backup_results["s3_uploads"] = s3_results
 
@@ -473,7 +516,9 @@ class BackupManager:
                 file_path = os.path.join(backup_path, filename)
                 if os.path.isfile(file_path):
                     # 檢查檔案修改時間
-                    file_time = datetime.fromtimestamp(os.path.getmtime(file_path))
+                    file_time = datetime.fromtimestamp(
+                        os.path.getmtime(file_path)
+                    )
                     if file_time < cutoff_date:
                         os.remove(file_path)
                         logger.info(f"刪除過期備份: {filename}")
@@ -481,7 +526,9 @@ class BackupManager:
         except Exception as e:
             logger.error(f"清理備份失敗: {e}")
 
-    async def verify_backup_integrity(self, backup_file: str, expected_checksum: str) -> bool:
+    async def verify_backup_integrity(
+        self, backup_file: str, expected_checksum: str
+    ) -> bool:
         """驗證備份完整性"""
 
         try:
@@ -520,9 +567,13 @@ async def main():
         # 顯示各組件備份結果
         for component, details in result["components"].items():
             if details.get("success"):
-                print(f"  ✅ {component}: {details.get('size_bytes', 0)} bytes")
+                print(
+                    f"  ✅ {component}: {details.get('size_bytes', 0)} bytes"
+                )
             else:
-                print(f"  ❌ {component}: {details.get('error', 'Unknown error')}")
+                print(
+                    f"  ❌ {component}: {details.get('error', 'Unknown error')}"
+                )
     else:
         print(f"❌ 備份失敗: {result.get('error', 'Unknown error')}")
 
diff --git a/auto_generate_video_fold6/scripts/config-validator.py b/auto_generate_video_fold6/scripts/config-validator.py
index 16c2566..f4afd13 100644
--- a/auto_generate_video_fold6/scripts/config-validator.py
+++ b/auto_generate_video_fold6/scripts/config-validator.py
@@ -16,70 +16,107 @@ from jsonschema import validate, ValidationError
 
 class ConfigValidator:
     """配置驗證器"""
-    
+
     def __init__(self, config_dir: str = None):
         self.config_dir = Path(config_dir or "config")
         self.schemas = {}
         self.validation_results = {}
         self.load_schemas()
-    
+
     def load_schemas(self):
         """載入配置模式定義"""
         self.schemas = {
             "base": {
                 "type": "object",
-                "required": ["generation", "ai_services", "cost_control", "resources"],
+                "required": [
+                    "generation",
+                    "ai_services",
+                    "cost_control",
+                    "resources",
+                ],
                 "properties": {
                     "generation": {
                         "type": "object",
                         "required": ["daily_video_limit", "platforms"],
                         "properties": {
-                            "daily_video_limit": {"type": "integer", "minimum": 1},
-                            "platforms": {"type": "array", "items": {"type": "string"}},
-                            "max_duration_seconds": {"type": "integer", "minimum": 10}
-                        }
+                            "daily_video_limit": {
+                                "type": "integer",
+                                "minimum": 1,
+                            },
+                            "platforms": {
+                                "type": "array",
+                                "items": {"type": "string"},
+                            },
+                            "max_duration_seconds": {
+                                "type": "integer",
+                                "minimum": 10,
+                            },
+                        },
                     },
                     "ai_services": {
                         "type": "object",
                         "required": ["text_generation", "image_generation"],
                         "properties": {
                             "text_generation": {
-                                "type": "object", 
+                                "type": "object",
                                 "required": ["provider"],
                                 "properties": {
-                                    "provider": {"type": "string", "enum": ["openai", "gemini", "claude"]},
+                                    "provider": {
+                                        "type": "string",
+                                        "enum": ["openai", "gemini", "claude"],
+                                    },
                                     "model": {"type": "string"},
-                                    "max_tokens": {"type": "integer", "minimum": 100}
-                                }
+                                    "max_tokens": {
+                                        "type": "integer",
+                                        "minimum": 100,
+                                    },
+                                },
                             },
                             "image_generation": {
                                 "type": "object",
                                 "required": ["provider"],
                                 "properties": {
-                                    "provider": {"type": "string", "enum": ["dalle", "midjourney", "stable-diffusion"]},
+                                    "provider": {
+                                        "type": "string",
+                                        "enum": [
+                                            "dalle",
+                                            "midjourney",
+                                            "stable-diffusion",
+                                        ],
+                                    },
                                     "resolution": {"type": "string"},
-                                    "quality": {"type": "string", "enum": ["standard", "high", "premium"]}
-                                }
-                            }
-                        }
+                                    "quality": {
+                                        "type": "string",
+                                        "enum": [
+                                            "standard",
+                                            "high",
+                                            "premium",
+                                        ],
+                                    },
+                                },
+                            },
+                        },
                     },
                     "cost_control": {
                         "type": "object",
                         "required": ["daily_budget_usd"],
                         "properties": {
-                            "daily_budget_usd": {"type": "number", "minimum": 0},
-                            "api_rate_limits": {"type": "object"}
-                        }
+                            "daily_budget_usd": {
+                                "type": "number",
+                                "minimum": 0,
+                            },
+                            "api_rate_limits": {"type": "object"},
+                        },
                     },
                     "resources": {
                         "type": "object",
                         "properties": {
                             "max_memory_usage": {"type": "string"},
                             "max_cpu_cores": {"type": "integer", "minimum": 1},
-                            "disk_space_limit": {"type": "string"}
-                        }
-                    }
-                }
+                            "disk_space_limit": {"type": "string"},
+                        },
+                    },
+                },
             },
             "auth": {
                 "type": "object",
@@ -87,52 +124,73 @@ class ConfigValidator:
                 "properties": {
                     "jwt": {
                         "type": "object",
-                        "required": ["secret_key", "algorithm", "expire_minutes"],
+                        "required": [
+                            "secret_key",
+                            "algorithm",
+                            "expire_minutes",
+                        ],
                         "properties": {
                             "secret_key": {"type": "string", "minLength": 32},
-                            "algorithm": {"type": "string", "enum": ["HS256", "RS256"]},
-                            "expire_minutes": {"type": "integer", "minimum": 15}
-                        }
+                            "algorithm": {
+                                "type": "string",
+                                "enum": ["HS256", "RS256"],
+                            },
+                            "expire_minutes": {
+                                "type": "integer",
+                                "minimum": 15,
+                            },
+                        },
                     },
                     "oauth": {
                         "type": "object",
                         "properties": {
                             "google": {"type": "object"},
                             "github": {"type": "object"},
-                            "discord": {"type": "object"}
-                        }
+                            "discord": {"type": "object"},
+                        },
                     },
                     "security": {
                         "type": "object",
                         "properties": {
-                            "password_min_length": {"type": "integer", "minimum": 8},
-                            "max_login_attempts": {"type": "integer", "minimum": 3},
-                            "lockout_duration_minutes": {"type": "integer", "minimum": 5}
-                        }
-                    }
-                }
-            }
+                            "password_min_length": {
+                                "type": "integer",
+                                "minimum": 8,
+                            },
+                            "max_login_attempts": {
+                                "type": "integer",
+                                "minimum": 3,
+                            },
+                            "lockout_duration_minutes": {
+                                "type": "integer",
+                                "minimum": 5,
+                            },
+                        },
+                    },
+                },
+            },
         }
-    
-    def validate_config_file(self, config_file: Path) -> Tuple[bool, List[str]]:
+
+    def validate_config_file(
+        self, config_file: Path
+    ) -> Tuple[bool, List[str]]:
         """驗證單個配置文件"""
         errors = []
-        
+
         if not config_file.exists():
             return False, [f"配置文件不存在: {config_file}"]
-        
+
         try:
-            with open(config_file, 'r', encoding='utf-8') as f:
+            with open(config_file, "r", encoding="utf-8") as f:
                 config_data = json.load(f)
         except json.JSONDecodeError as e:
             return False, [f"JSON 格式錯誤: {e}"]
         except Exception as e:
             return False, [f"讀取文件失敗: {e}"]
-        
+
         # 根據文件名選擇模式
-        config_type = config_file.stem.replace('-config', '')
+        config_type = config_file.stem.replace("-config", "")
         schema = self.schemas.get(config_type)
-        
+
         if schema:
             try:
                 validate(instance=config_data, schema=schema)
@@ -140,48 +198,59 @@ class ConfigValidator:
                 errors.append(f"模式驗證失敗: {e.message}")
             except Exception as e:
                 errors.append(f"驗證過程錯誤: {e}")
-        
+
         # 自定義驗證規則
         custom_errors = self._custom_validation(config_data, config_type)
         errors.extend(custom_errors)
-        
+
         return len(errors) == 0, errors
-    
-    def _custom_validation(self, config_data: Dict, config_type: str) -> List[str]:
+
+    def _custom_validation(
+        self, config_data: Dict, config_type: str
+    ) -> List[str]:
         """自定義驗證規則"""
         errors = []
-        
+
         if config_type == "base":
             # 檢查平台配置
             platforms = config_data.get("generation", {}).get("platforms", [])
             valid_platforms = ["tiktok", "youtube", "instagram", "twitter"]
-            
+
             for platform in platforms:
                 if platform not in valid_platforms:
                     errors.append(f"不支援的平台: {platform}")
-            
+
             # 檢查預算和限制的合理性
-            daily_limit = config_data.get("generation", {}).get("daily_video_limit", 0)
-            daily_budget = config_data.get("cost_control", {}).get("daily_budget_usd", 0)
-            
+            daily_limit = config_data.get("generation", {}).get(
+                "daily_video_limit", 0
+            )
+            daily_budget = config_data.get("cost_control", {}).get(
+                "daily_budget_usd", 0
+            )
+
             estimated_cost_per_video = 0.50  # 假設每個影片成本
-            if daily_budget > 0 and daily_limit * estimated_cost_per_video > daily_budget:
-                errors.append(f"每日影片限制({daily_limit})可能超出預算({daily_budget} USD)")
-        
+            if (
+                daily_budget > 0
+                and daily_limit * estimated_cost_per_video > daily_budget
+            ):
+                errors.append(
+                    f"每日影片限制({daily_limit})可能超出預算({daily_budget} USD)"
+                )
+
         elif config_type == "auth":
             # 檢查 JWT 密鑰強度
             jwt_secret = config_data.get("jwt", {}).get("secret_key", "")
             if len(jwt_secret) < 32:
                 errors.append("JWT 密鑰長度應至少 32 字符")
-            
+
             # 檢查安全設置
             security = config_data.get("security", {})
             password_min_length = security.get("password_min_length", 0)
             if password_min_length < 8:
                 errors.append("密碼最小長度應至少 8 字符")
-        
+
         return errors
-    
+
     def validate_all_configs(self) -> Dict[str, Any]:
         """驗證所有配置文件"""
         results = {
@@ -189,86 +258,102 @@ class ConfigValidator:
             "total_files": 0,
             "valid_files": 0,
             "invalid_files": 0,
-            "files": {}
+            "files": {},
         }
-        
+
         config_files = list(self.config_dir.glob("*-config.json"))
         results["total_files"] = len(config_files)
-        
+
         for config_file in config_files:
             is_valid, errors = self.validate_config_file(config_file)
-            
+
             results["files"][config_file.name] = {
                 "valid": is_valid,
                 "errors": errors,
                 "size": config_file.stat().st_size,
-                "modified": datetime.fromtimestamp(config_file.stat().st_mtime).isoformat()
+                "modified": datetime.fromtimestamp(
+                    config_file.stat().st_mtime
+                ).isoformat(),
             }
-            
+
             if is_valid:
                 results["valid_files"] += 1
             else:
                 results["invalid_files"] += 1
-        
+
         self.validation_results = results
         return results
-    
+
     def check_config_consistency(self) -> Dict[str, Any]:
         """檢查配置間的一致性"""
         consistency_issues = []
-        
+
         # 載入主要配置文件
         base_config = self._load_config("base-config.json")
         auth_config = self._load_config("auth-config.json")
         enterprise_config = self._load_config("enterprise-config.json")
-        
+
         if not all([base_config, auth_config]):
             return {"issues": ["無法載入必要的配置文件"]}
-        
+
         # 檢查服務端口是否衝突
         ports_used = set()
         for config_name, config_data in [
-            ("base", base_config), 
-            ("auth", auth_config), 
-            ("enterprise", enterprise_config)
+            ("base", base_config),
+            ("auth", auth_config),
+            ("enterprise", enterprise_config),
         ]:
             if config_data and "services" in config_data:
                 for service, service_config in config_data["services"].items():
                     if "port" in service_config:
                         port = service_config["port"]
                         if port in ports_used:
-                            consistency_issues.append(f"端口衝突: {port} 在多個服務中使用")
+                            consistency_issues.append(
+                                f"端口衝突: {port} 在多個服務中使用"
+                            )
                         else:
                             ports_used.add(port)
-        
+
         # 檢查資源限制的一致性
         if base_config and enterprise_config:
-            base_memory = base_config.get("resources", {}).get("max_memory_usage")
-            enterprise_memory = enterprise_config.get("resources", {}).get("max_memory_usage")
-            
-            if base_memory and enterprise_memory and base_memory != enterprise_memory:
-                consistency_issues.append(f"記憶體限制不一致: base({base_memory}) vs enterprise({enterprise_memory})")
-        
+            base_memory = base_config.get("resources", {}).get(
+                "max_memory_usage"
+            )
+            enterprise_memory = enterprise_config.get("resources", {}).get(
+                "max_memory_usage"
+            )
+
+            if (
+                base_memory
+                and enterprise_memory
+                and base_memory != enterprise_memory
+            ):
+                consistency_issues.append(
+                    f"記憶體限制不一致: base({base_memory}) vs enterprise({enterprise_memory})"
+                )
+
         return {
             "timestamp": datetime.now().isoformat(),
             "issues_count": len(consistency_issues),
-            "issues": consistency_issues
+            "issues": consistency_issues,
         }
-    
+
     def _load_config(self, filename: str) -> Dict[str, Any]:
         """載入配置文件"""
         config_path = self.config_dir / filename
-        
+
         if not config_path.exists():
             return None
-        
+
         try:
-            with open(config_path, 'r', encoding='utf-8') as f:
+            with open(config_path, "r", encoding="utf-8") as f:
                 return json.load(f)
         except:
             return None
-    
-    def generate_config_template(self, config_type: str, output_file: str = None) -> str:
+
+    def generate_config_template(
+        self, config_type: str, output_file: str = None
+    ) -> str:
         """生成配置模板"""
         templates = {
             "base": {
@@ -276,86 +361,85 @@ class ConfigValidator:
                     "daily_video_limit": 50,
                     "platforms": ["tiktok", "youtube", "instagram"],
                     "max_duration_seconds": 300,
-                    "quality": "high"
+                    "quality": "high",
                 },
                 "ai_services": {
                     "text_generation": {
                         "provider": "gemini",
                         "model": "gemini-pro",
-                        "max_tokens": 2000
+                        "max_tokens": 2000,
                     },
                     "image_generation": {
                         "provider": "stable-diffusion",
                         "resolution": "1024x1024",
-                        "quality": "high"
+                        "quality": "high",
                     },
                     "voice_cloning": {
                         "provider": "elevenlabs",
                         "voice_stability": 0.8,
-                        "voice_similarity": 0.8
-                    }
+                        "voice_similarity": 0.8,
+                    },
                 },
                 "cost_control": {
                     "daily_budget_usd": 25.0,
                     "api_rate_limits": {
                         "gemini_requests_per_hour": 100,
                         "dalle_requests_per_hour": 50,
-                        "elevenlabs_requests_per_hour": 200
-                    }
+                        "elevenlabs_requests_per_hour": 200,
+                    },
                 },
                 "resources": {
                     "max_memory_usage": "4GB",
                     "max_cpu_cores": 4,
-                    "disk_space_limit": "100GB"
+                    "disk_space_limit": "100GB",
                 },
                 "scheduling": {
                     "enabled": True,
-                    "work_hours": {
-                        "start": "09:00",
-                        "end": "18:00"
-                    },
-                    "auto_publish": False
-                }
+                    "work_hours": {"start": "09:00", "end": "18:00"},
+                    "auto_publish": False,
+                },
             },
             "auth": {
                 "jwt": {
                     "secret_key": "your-super-secret-jwt-key-32chars-min",
                     "algorithm": "HS256",
-                    "expire_minutes": 60
+                    "expire_minutes": 60,
                 },
                 "oauth": {
                     "google": {
                         "client_id": "your-google-client-id",
-                        "client_secret": "your-google-client-secret"
+                        "client_secret": "your-google-client-secret",
                     },
                     "github": {
                         "client_id": "your-github-client-id",
-                        "client_secret": "your-github-client-secret"
-                    }
+                        "client_secret": "your-github-client-secret",
+                    },
                 },
                 "security": {
                     "password_min_length": 8,
                     "max_login_attempts": 5,
                     "lockout_duration_minutes": 15,
-                    "require_email_verification": True
-                }
-            }
+                    "require_email_verification": True,
+                },
+            },
         }
-        
+
         template = templates.get(config_type)
         if not template:
             raise ValueError(f"不支援的配置類型: {config_type}")
-        
+
         if output_file is None:
-            output_file = self.config_dir / f"{config_type}-config.template.json"
+            output_file = (
+                self.config_dir / f"{config_type}-config.template.json"
+            )
         else:
             output_file = Path(output_file)
-        
-        with open(output_file, 'w', encoding='utf-8') as f:
+
+        with open(output_file, "w", encoding="utf-8") as f:
             json.dump(template, f, indent=2, ensure_ascii=False)
-        
+
         return str(output_file)
-    
+
     def sync_configs_with_environment(self) -> Dict[str, Any]:
         """同步配置與環境變數"""
         env_mappings = {
@@ -363,61 +447,67 @@ class ConfigValidator:
             "DAILY_VIDEO_LIMIT": "base.generation.daily_video_limit",
             "DAILY_BUDGET": "base.cost_control.daily_budget_usd",
             "AI_TEXT_PROVIDER": "base.ai_services.text_generation.provider",
-            "AI_IMAGE_PROVIDER": "base.ai_services.image_generation.provider"
+            "AI_IMAGE_PROVIDER": "base.ai_services.image_generation.provider",
         }
-        
+
         sync_results = {
             "timestamp": datetime.now().isoformat(),
             "synced_vars": [],
             "missing_vars": [],
-            "conflicts": []
+            "conflicts": [],
         }
-        
+
         for env_var, config_path in env_mappings.items():
             env_value = os.getenv(env_var)
-            
+
             if env_value:
-                config_file, config_key = config_path.split('.', 1)
+                config_file, config_key = config_path.split(".", 1)
                 config_data = self._load_config(f"{config_file}-config.json")
-                
+
                 if config_data:
                     # 獲取配置中的當前值
-                    current_value = self._get_nested_value(config_data, config_key)
-                    
+                    current_value = self._get_nested_value(
+                        config_data, config_key
+                    )
+
                     if str(current_value) != env_value:
-                        sync_results["conflicts"].append({
-                            "env_var": env_var,
-                            "env_value": env_value,
-                            "config_value": current_value,
-                            "config_path": config_path
-                        })
+                        sync_results["conflicts"].append(
+                            {
+                                "env_var": env_var,
+                                "env_value": env_value,
+                                "config_value": current_value,
+                                "config_path": config_path,
+                            }
+                        )
                     else:
                         sync_results["synced_vars"].append(env_var)
                 else:
-                    sync_results["missing_vars"].append(f"配置文件 {config_file}-config.json 不存在")
+                    sync_results["missing_vars"].append(
+                        f"配置文件 {config_file}-config.json 不存在"
+                    )
             else:
                 sync_results["missing_vars"].append(env_var)
-        
+
         return sync_results
-    
+
     def _get_nested_value(self, data: Dict, key_path: str):
         """獲取嵌套字典值"""
-        keys = key_path.split('.')
+        keys = key_path.split(".")
         current = data
-        
+
         try:
             for key in keys:
                 current = current[key]
             return current
         except (KeyError, TypeError):
             return None
-    
+
     def generate_report(self, output_file: str = None) -> str:
         """生成完整的配置驗證報告"""
         validation_results = self.validate_all_configs()
         consistency_results = self.check_config_consistency()
         sync_results = self.sync_configs_with_environment()
-        
+
         report = {
             "timestamp": datetime.now().isoformat(),
             "summary": {
@@ -425,95 +515,103 @@ class ConfigValidator:
                 "valid_files": validation_results["valid_files"],
                 "invalid_files": validation_results["invalid_files"],
                 "consistency_issues": consistency_results["issues_count"],
-                "sync_conflicts": len(sync_results.get("conflicts", []))
+                "sync_conflicts": len(sync_results.get("conflicts", [])),
             },
             "validation": validation_results,
             "consistency": consistency_results,
             "environment_sync": sync_results,
             "recommendations": self._generate_recommendations(
                 validation_results, consistency_results, sync_results
-            )
+            ),
         }
-        
+
         if output_file is None:
             timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
             output_file = f"config_validation_report_{timestamp}.json"
-        
+
         output_path = Path(output_file)
-        with open(output_path, 'w', encoding='utf-8') as f:
+        with open(output_path, "w", encoding="utf-8") as f:
             json.dump(report, f, indent=2, ensure_ascii=False)
-        
+
         return str(output_path)
-    
-    def _generate_recommendations(self, validation_results: Dict, 
-                                consistency_results: Dict, sync_results: Dict) -> List[str]:
+
+    def _generate_recommendations(
+        self,
+        validation_results: Dict,
+        consistency_results: Dict,
+        sync_results: Dict,
+    ) -> List[str]:
         """生成改進建議"""
         recommendations = []
-        
+
         if validation_results["invalid_files"] > 0:
-            recommendations.append("修復配置文件驗證錯誤，確保所有配置文件格式正確")
-        
+            recommendations.append(
+                "修復配置文件驗證錯誤，確保所有配置文件格式正確"
+            )
+
         if consistency_results["issues_count"] > 0:
             recommendations.append("解決配置間的一致性問題，避免服務衝突")
-        
+
         if len(sync_results.get("conflicts", [])) > 0:
             recommendations.append("同步環境變數與配置文件，確保部署一致性")
-        
+
         if len(sync_results.get("missing_vars", [])) > 0:
             recommendations.append("設置缺失的環境變數，完善部署配置")
-        
+
         if not recommendations:
             recommendations.append("配置系統運行良好，建議定期執行驗證檢查")
-        
+
         return recommendations
-    
+
     def print_summary(self):
         """打印配置驗證摘要"""
         if not self.validation_results:
             self.validate_all_configs()
-        
+
         results = self.validation_results
-        
-        print("\n" + "="*60)
+
+        print("\n" + "=" * 60)
         print("⚙️  配置驗證摘要報告")
-        print("="*60)
+        print("=" * 60)
         print(f"📄 總配置文件: {results['total_files']}")
         print(f"✅ 有效文件: {results['valid_files']}")
         print(f"❌ 無效文件: {results['invalid_files']}")
-        
-        if results['invalid_files'] > 0:
+
+        if results["invalid_files"] > 0:
             print("\n🚨 配置錯誤:")
-            for filename, file_info in results['files'].items():
-                if not file_info['valid']:
+            for filename, file_info in results["files"].items():
+                if not file_info["valid"]:
                     print(f"  ❌ {filename}:")
-                    for error in file_info['errors']:
+                    for error in file_info["errors"]:
                         print(f"     - {error}")
-        
+
         consistency = self.check_config_consistency()
-        if consistency['issues_count'] > 0:
+        if consistency["issues_count"] > 0:
             print(f"\n⚠️  一致性問題 ({consistency['issues_count']} 個):")
-            for issue in consistency['issues']:
+            for issue in consistency["issues"]:
                 print(f"  - {issue}")
-        
+
         sync = self.sync_configs_with_environment()
-        if sync.get('conflicts'):
+        if sync.get("conflicts"):
             print(f"\n🔄 環境同步衝突 ({len(sync['conflicts'])} 個):")
-            for conflict in sync['conflicts']:
-                print(f"  - {conflict['env_var']}: 環境({conflict['env_value']}) ≠ 配置({conflict['config_value']})")
+            for conflict in sync["conflicts"]:
+                print(
+                    f"  - {conflict['env_var']}: 環境({conflict['env_value']}) ≠ 配置({conflict['config_value']})"
+                )
 
 
 if __name__ == "__main__":
     import argparse
-    
+
     parser = argparse.ArgumentParser(description="配置驗證和同步工具")
     parser.add_argument("--config-dir", default="config", help="配置文件目錄")
     parser.add_argument("--report", help="生成報告文件路徑")
     parser.add_argument("--template", help="生成配置模板 (base|auth)")
-    
+
     args = parser.parse_args()
-    
+
     validator = ConfigValidator(args.config_dir)
-    
+
     if args.template:
         try:
             template_file = validator.generate_config_template(args.template)
@@ -523,7 +621,7 @@ if __name__ == "__main__":
             sys.exit(1)
     else:
         validator.print_summary()
-        
+
         if args.report:
             report_file = validator.generate_report(args.report)
-            print(f"\n📊 詳細報告已保存: {report_file}")
\ No newline at end of file
+            print(f"\n📊 詳細報告已保存: {report_file}")
diff --git a/auto_generate_video_fold6/scripts/deploy_enterprise_system.py b/auto_generate_video_fold6/scripts/deploy_enterprise_system.py
index e4d8205..47f3fa3 100644
--- a/auto_generate_video_fold6/scripts/deploy_enterprise_system.py
+++ b/auto_generate_video_fold6/scripts/deploy_enterprise_system.py
@@ -54,8 +54,16 @@ class EnterpriseSystemDeployer:
                     "compliance-framework",
                     "security-scanner",
                 ],
-                "high_availability": {"enabled": True, "load_balancer": "haproxy", "replicas": 3},
-                "auto_scaling": {"enabled": True, "min_instances": 2, "max_instances": 10},
+                "high_availability": {
+                    "enabled": True,
+                    "load_balancer": "haproxy",
+                    "replicas": 3,
+                },
+                "auto_scaling": {
+                    "enabled": True,
+                    "min_instances": 2,
+                    "max_instances": 10,
+                },
             }
 
     async def deploy_enterprise_system(self) -> Dict[str, Any]:
@@ -154,15 +162,21 @@ class EnterpriseSystemDeployer:
 
             # 計算部署結果
             total_duration = time.time() - start_time
-            deployment_success = self._evaluate_deployment_success(deployment_results)
+            deployment_success = self._evaluate_deployment_success(
+                deployment_results
+            )
 
             deployment_results.update(
                 {
                     "end_time": datetime.utcnow().isoformat(),
                     "duration_seconds": total_duration,
                     "deployment_success": deployment_success,
-                    "system_status": "OPERATIONAL" if deployment_success else "FAILED",
-                    "next_steps": self._generate_next_steps(deployment_results),
+                    "system_status": "OPERATIONAL"
+                    if deployment_success
+                    else "FAILED",
+                    "next_steps": self._generate_next_steps(
+                        deployment_results
+                    ),
                     "maintenance_schedule": self._generate_maintenance_schedule(),
                 }
             )
@@ -171,7 +185,9 @@ class EnterpriseSystemDeployer:
             await self._generate_deployment_summary(deployment_results)
 
             if deployment_success:
-                logger.info("🎉 企業級系統部署完成！系統已準備好為用戶提供服務。")
+                logger.info(
+                    "🎉 企業級系統部署完成！系統已準備好為用戶提供服務。"
+                )
             else:
                 logger.error("❌ 系統部署過程中遇到問題，請查看詳細日誌。")
 
@@ -180,7 +196,11 @@ class EnterpriseSystemDeployer:
         except Exception as e:
             logger.error(f"系統部署失敗: {e}")
             deployment_results.update(
-                {"error": str(e), "deployment_success": False, "system_status": "FAILED"}
+                {
+                    "error": str(e),
+                    "deployment_success": False,
+                    "system_status": "FAILED",
+                }
             )
             return deployment_results
 
@@ -275,11 +295,15 @@ class EnterpriseSystemDeployer:
 
             for service_name in services:
                 logger.info(f"部署服務: {service_name}")
-                service_result = await self._deploy_single_service(service_name)
+                service_result = await self._deploy_single_service(
+                    service_name
+                )
                 deployment_results[service_name] = service_result
 
             # 配置服務間通信
-            inter_service_result = await self._configure_inter_service_communication()
+            inter_service_result = (
+                await self._configure_inter_service_communication()
+            )
 
             return {
                 "status": "SUCCESS",
@@ -400,7 +424,9 @@ class EnterpriseSystemDeployer:
             audit_logging_result = await self._configure_audit_logging()
 
             # 配置資料保留政策
-            retention_policies_result = await self._configure_retention_policies()
+            retention_policies_result = (
+                await self._configure_retention_policies()
+            )
 
             return {
                 "status": "SUCCESS",
@@ -416,8 +442,13 @@ class EnterpriseSystemDeployer:
     async def _configure_high_availability(self) -> Dict[str, Any]:
         """配置高可用性"""
         try:
-            if not self.config.get("high_availability", {}).get("enabled", False):
-                return {"status": "SKIPPED", "reason": "High availability disabled in config"}
+            if not self.config.get("high_availability", {}).get(
+                "enabled", False
+            ):
+                return {
+                    "status": "SKIPPED",
+                    "reason": "High availability disabled in config",
+                }
 
             # 部署負載平衡器
             load_balancer_result = await self._deploy_load_balancer()
@@ -426,7 +457,9 @@ class EnterpriseSystemDeployer:
             replicas_result = await self._configure_service_replicas()
 
             # 配置資料庫主從複製
-            db_replication_result = await self._configure_database_replication()
+            db_replication_result = (
+                await self._configure_database_replication()
+            )
 
             return {
                 "status": "SUCCESS",
@@ -442,13 +475,18 @@ class EnterpriseSystemDeployer:
         """配置自動擴展"""
         try:
             if not self.config.get("auto_scaling", {}).get("enabled", False):
-                return {"status": "SKIPPED", "reason": "Auto scaling disabled in config"}
+                return {
+                    "status": "SKIPPED",
+                    "reason": "Auto scaling disabled in config",
+                }
 
             # 配置 HPA (Horizontal Pod Autoscaler)
             hpa_result = await self._configure_horizontal_pod_autoscaler()
 
             # 配置資源監控
-            resource_monitoring_result = await self._configure_resource_monitoring()
+            resource_monitoring_result = (
+                await self._configure_resource_monitoring()
+            )
 
             # 配置擴展策略
             scaling_policies_result = await self._configure_scaling_policies()
@@ -514,14 +552,22 @@ class EnterpriseSystemDeployer:
         try:
             # 執行安全掃描腳本
             result = subprocess.run(
-                ["python", "scripts/security_scanner.py", "--severity", "medium", "--verbose"],
+                [
+                    "python",
+                    "scripts/security_scanner.py",
+                    "--severity",
+                    "medium",
+                    "--verbose",
+                ],
                 capture_output=True,
                 text=True,
                 timeout=1200,
             )
 
             return {
-                "status": "SUCCESS" if result.returncode <= 1 else "FAILED",  # 安全掃描允許輕微問題
+                "status": "SUCCESS"
+                if result.returncode <= 1
+                else "FAILED",  # 安全掃描允許輕微問題
                 "exit_code": result.returncode,
                 "stdout": result.stdout,
                 "stderr": result.stderr,
@@ -549,7 +595,9 @@ class EnterpriseSystemDeployer:
             return {
                 "status": "SUCCESS" if all_valid else "FAILED",
                 "validations": validations,
-                "failed_validations": [k for k, v in validations.items() if not v],
+                "failed_validations": [
+                    k for k, v in validations.items() if not v
+                ],
             }
 
         except Exception as e:
@@ -599,7 +647,9 @@ class EnterpriseSystemDeployer:
         dependencies = ["docker", "docker-compose", "python3", "pip"]
         for dep in dependencies:
             try:
-                subprocess.run([dep, "--version"], capture_output=True, check=True)
+                subprocess.run(
+                    [dep, "--version"], capture_output=True, check=True
+                )
             except (subprocess.CalledProcessError, FileNotFoundError):
                 return False
         return True
@@ -607,11 +657,17 @@ class EnterpriseSystemDeployer:
     # 其他部署方法的簡化實現
     async def _create_docker_networks(self) -> List[str]:
         """創建 Docker 網路"""
-        networks = ["auto-video-network", "monitoring-network", "backup-network"]
+        networks = [
+            "auto-video-network",
+            "monitoring-network",
+            "backup-network",
+        ]
         created = []
         for network_name in networks:
             try:
-                self.docker_client.networks.create(network_name, driver="bridge")
+                self.docker_client.networks.create(
+                    network_name, driver="bridge"
+                )
                 created.append(network_name)
             except Exception as e:
                 logger.warning(f"網路創建失敗 {network_name}: {e}")
@@ -654,7 +710,9 @@ class EnterpriseSystemDeployer:
         """配置快取策略"""
         return {"status": "SUCCESS", "policies_configured": 5}
 
-    async def _deploy_single_service(self, service_name: str) -> Dict[str, Any]:
+    async def _deploy_single_service(
+        self, service_name: str
+    ) -> Dict[str, Any]:
         """部署單個服務"""
         return {"status": "SUCCESS", "service": service_name, "replicas": 3}
 
@@ -666,7 +724,12 @@ class EnterpriseSystemDeployer:
 
     def _evaluate_deployment_success(self, results: Dict[str, Any]) -> bool:
         """評估部署成功狀態"""
-        critical_components = ["infrastructure", "databases", "core_services", "final_validation"]
+        critical_components = [
+            "infrastructure",
+            "databases",
+            "core_services",
+            "final_validation",
+        ]
 
         for component in critical_components:
             if component not in results:
@@ -742,21 +805,29 @@ async def main():
     import argparse
 
     parser = argparse.ArgumentParser(description="企業級系統部署")
-    parser.add_argument("--config", default="config/deployment-config.json", help="部署配置檔案")
+    parser.add_argument(
+        "--config",
+        default="config/deployment-config.json",
+        help="部署配置檔案",
+    )
     parser.add_argument(
         "--environment",
         choices=["development", "staging", "production"],
         default="production",
         help="部署環境",
     )
-    parser.add_argument("--dry-run", action="store_true", help="演練模式（不實際部署）")
+    parser.add_argument(
+        "--dry-run", action="store_true", help="演練模式（不實際部署）"
+    )
     parser.add_argument("--verbose", action="store_true", help="詳細輸出")
 
     args = parser.parse_args()
 
     # 設置日誌
     log_level = logging.DEBUG if args.verbose else logging.INFO
-    logging.basicConfig(level=log_level, format="%(asctime)s - %(levelname)s - %(message)s")
+    logging.basicConfig(
+        level=log_level, format="%(asctime)s - %(levelname)s - %(message)s"
+    )
 
     if args.dry_run:
         logger.info("🔍 演練模式：將模擬部署過程，不會實際修改系統")
@@ -766,13 +837,15 @@ async def main():
     results = await deployer.deploy_enterprise_system()
 
     # 輸出結果摘要
-    print(f"\n{'='*80}")
+    print(f"\n{'=' * 80}")
     print("🚀 企業級系統部署結果摘要")
-    print(f"{'='*80}")
+    print(f"{'=' * 80}")
     print(f"部署環境: {results.get('environment', 'Unknown')}")
     print(f"部署持續時間: {results.get('duration_seconds', 0):.2f} 秒")
     print(f"系統狀態: {results.get('system_status', 'Unknown')}")
-    print(f"部署成功: {'✅ 是' if results.get('deployment_success', False) else '❌ 否'}")
+    print(
+        f"部署成功: {'✅ 是' if results.get('deployment_success', False) else '❌ 否'}"
+    )
 
     if results.get("deployment_success", False):
         print(f"\n🎉 恭喜！企業級自動影片生成系統已成功部署！")
@@ -790,7 +863,9 @@ async def main():
         for i, step in enumerate(results.get("next_steps", []), 1):
             print(f"{i}. {step}")
 
-        print(f"\n系統已達到世界級企業標準，可與 Netflix、Spotify、Uber 等頂級技術公司媲美！")
+        print(
+            f"\n系統已達到世界級企業標準，可與 Netflix、Spotify、Uber 等頂級技術公司媲美！"
+        )
         exit(0)
     else:
         print(f"\n❌ 部署過程中遇到問題，請檢查日誌並修復後重新部署。")
diff --git a/auto_generate_video_fold6/scripts/disaster_recovery.py b/auto_generate_video_fold6/scripts/disaster_recovery.py
index 77b0104..0c8ad4e 100755
--- a/auto_generate_video_fold6/scripts/disaster_recovery.py
+++ b/auto_generate_video_fold6/scripts/disaster_recovery.py
@@ -86,14 +86,18 @@ class HealthChecker:
 
         # 檢查各個服務
         for service_name, service_config in self.services.items():
-            service_health = await self._check_service_health(service_name, service_config)
+            service_health = await self._check_service_health(
+                service_name, service_config
+            )
             health_results["services"][service_name] = service_health
 
             if service_health["status"] == "critical":
                 health_results["critical_issues"].append(
                     {
                         "service": service_name,
-                        "issue": service_health.get("error", "Unknown critical issue"),
+                        "issue": service_health.get(
+                            "error", "Unknown critical issue"
+                        ),
                     }
                 )
                 health_results["overall_status"] = "critical"
@@ -101,7 +105,9 @@ class HealthChecker:
                 health_results["warnings"].append(
                     {
                         "service": service_name,
-                        "issue": service_health.get("error", "Unknown warning"),
+                        "issue": service_health.get(
+                            "error", "Unknown warning"
+                        ),
                     }
                 )
                 if health_results["overall_status"] == "healthy":
@@ -120,11 +126,16 @@ class HealthChecker:
             if service_type == "http":
                 return await self._check_http_service(service_name, config)
             elif service_type == "postgresql":
-                return await self._check_postgresql_service(service_name, config)
+                return await self._check_postgresql_service(
+                    service_name, config
+                )
             elif service_type == "redis":
                 return await self._check_redis_service(service_name, config)
             else:
-                return {"status": "unknown", "error": f"Unknown service type: {service_type}"}
+                return {
+                    "status": "unknown",
+                    "error": f"Unknown service type: {service_type}",
+                }
 
         except Exception as e:
             logger.error(f"Health check failed for {service_name}: {e}")
@@ -135,7 +146,9 @@ class HealthChecker:
     ) -> Dict[str, Any]:
         """檢查 HTTP 服務"""
 
-        url = config.get("health_url", f"http://localhost:{config.get('port', 8080)}/health")
+        url = config.get(
+            "health_url", f"http://localhost:{config.get('port', 8080)}/health"
+        )
         timeout = config.get("timeout", 5)
 
         try:
@@ -148,10 +161,18 @@ class HealthChecker:
                     "url": url,
                 }
             else:
-                return {"status": "warning", "error": f"HTTP {response.status_code}", "url": url}
+                return {
+                    "status": "warning",
+                    "error": f"HTTP {response.status_code}",
+                    "url": url,
+                }
 
         except requests.RequestException as e:
-            return {"status": "critical", "error": f"Connection failed: {str(e)}", "url": url}
+            return {
+                "status": "critical",
+                "error": f"Connection failed: {str(e)}",
+                "url": url,
+            }
 
     async def _check_postgresql_service(
         self, service_name: str, config: Dict[str, Any]
@@ -194,7 +215,10 @@ class HealthChecker:
 
             redis_client.ping()
 
-            return {"status": "healthy", "redis_version": redis_client.info()["redis_version"]}
+            return {
+                "status": "healthy",
+                "redis_version": redis_client.info()["redis_version"],
+            }
 
         except Exception as e:
             return {"status": "critical", "error": str(e)}
@@ -240,21 +264,27 @@ class FailoverManager:
                 continue
 
             # 檢查服務是否有故障轉移配置
-            service_config = self.config.get("services", {}).get(service_name, {})
+            service_config = self.config.get("services", {}).get(
+                service_name, {}
+            )
             failover_config = service_config.get("failover", {})
 
             if failover_config.get("enabled", False):
                 logger.warning(f"啟動 {service_name} 的故障轉移")
                 await self._execute_failover(service_name, failover_config)
 
-    async def _execute_failover(self, service_name: str, failover_config: Dict[str, Any]):
+    async def _execute_failover(
+        self, service_name: str, failover_config: Dict[str, Any]
+    ):
         """執行故障轉移"""
 
         failover_id = f"failover_{service_name}_{int(time.time())}"
         self.active_failovers[service_name] = failover_id
 
         try:
-            logger.info(f"開始執行 {service_name} 故障轉移 (ID: {failover_id})")
+            logger.info(
+                f"開始執行 {service_name} 故障轉移 (ID: {failover_id})"
+            )
 
             # 1. 停止故障服務
             if failover_config.get("stop_primary", True):
@@ -267,18 +297,26 @@ class FailoverManager:
 
             # 3. 更新服務發現配置
             if failover_config.get("update_service_discovery", True):
-                await self._update_service_discovery(service_name, failover_config)
+                await self._update_service_discovery(
+                    service_name, failover_config
+                )
 
             # 4. 驗證故障轉移
-            validation_result = await self._validate_failover(service_name, failover_config)
+            validation_result = await self._validate_failover(
+                service_name, failover_config
+            )
 
             if validation_result["success"]:
                 logger.info(f"{service_name} 故障轉移成功完成")
 
                 # 發送通知
-                await self._send_failover_notification(service_name, "success", failover_id)
+                await self._send_failover_notification(
+                    service_name, "success", failover_id
+                )
             else:
-                logger.error(f"{service_name} 故障轉移失敗: {validation_result['error']}")
+                logger.error(
+                    f"{service_name} 故障轉移失敗: {validation_result['error']}"
+                )
                 await self._rollback_failover(service_name, failover_config)
 
         except Exception as e:
@@ -306,7 +344,9 @@ class FailoverManager:
         except subprocess.CalledProcessError as e:
             logger.error(f"啟動備用服務 {backup_service} 失敗: {e}")
 
-    async def _update_service_discovery(self, service_name: str, failover_config: Dict[str, Any]):
+    async def _update_service_discovery(
+        self, service_name: str, failover_config: Dict[str, Any]
+    ):
         """更新服務發現配置"""
         # 這裡實現服務發現更新邏輯（如 Consul, etcd 等）
         logger.info(f"更新 {service_name} 的服務發現配置")
@@ -330,12 +370,17 @@ class FailoverManager:
             if response.status_code == 200:
                 return {"success": True, "message": "故障轉移驗證成功"}
             else:
-                return {"success": False, "error": f"驗證失敗: HTTP {response.status_code}"}
+                return {
+                    "success": False,
+                    "error": f"驗證失敗: HTTP {response.status_code}",
+                }
 
         except Exception as e:
             return {"success": False, "error": f"驗證過程錯誤: {str(e)}"}
 
-    async def _rollback_failover(self, service_name: str, failover_config: Dict[str, Any]):
+    async def _rollback_failover(
+        self, service_name: str, failover_config: Dict[str, Any]
+    ):
         """回滾故障轉移"""
         logger.warning(f"回滾 {service_name} 的故障轉移")
 
@@ -343,7 +388,9 @@ class FailoverManager:
             # 停止備用服務
             backup_service = failover_config.get("backup_service")
             if backup_service:
-                subprocess.run(["systemctl", "stop", backup_service], check=True)
+                subprocess.run(
+                    ["systemctl", "stop", backup_service], check=True
+                )
 
             # 嘗試重新啟動原服務
             subprocess.run(["systemctl", "start", service_name], check=True)
@@ -353,7 +400,9 @@ class FailoverManager:
         except Exception as e:
             logger.error(f"{service_name} 故障轉移回滾失敗: {e}")
 
-    async def _send_failover_notification(self, service_name: str, status: str, failover_id: str):
+    async def _send_failover_notification(
+        self, service_name: str, status: str, failover_id: str
+    ):
         """發送故障轉移通知"""
 
         notification_config = self.config.get("notification", {})
@@ -362,18 +411,26 @@ class FailoverManager:
 
         # 電子郵件通知
         if notification_config.get("email", {}).get("enabled", False):
-            await self._send_email_notification(message, notification_config["email"])
+            await self._send_email_notification(
+                message, notification_config["email"]
+            )
 
         # Slack 通知
         if notification_config.get("slack", {}).get("enabled", False):
-            await self._send_slack_notification(message, notification_config["slack"])
+            await self._send_slack_notification(
+                message, notification_config["slack"]
+            )
 
-    async def _send_email_notification(self, message: str, email_config: Dict[str, Any]):
+    async def _send_email_notification(
+        self, message: str, email_config: Dict[str, Any]
+    ):
         """發送電子郵件通知"""
         # 實現電子郵件發送邏輯
         logger.info(f"發送電子郵件通知: {message}")
 
-    async def _send_slack_notification(self, message: str, slack_config: Dict[str, Any]):
+    async def _send_slack_notification(
+        self, message: str, slack_config: Dict[str, Any]
+    ):
         """發送 Slack 通知"""
         # 實現 Slack 通知邏輯
         logger.info(f"發送 Slack 通知: {message}")
@@ -382,7 +439,9 @@ class FailoverManager:
 class DisasterRecoveryManager:
     """災難恢復管理器"""
 
-    def __init__(self, config_file: str = "config/disaster-recovery-config.json"):
+    def __init__(
+        self, config_file: str = "config/disaster-recovery-config.json"
+    ):
         self.config = self._load_config(config_file)
         self.health_checker = HealthChecker(self.config)
         self.failover_manager = FailoverManager(self.config)
@@ -439,7 +498,10 @@ class DisasterRecoveryManager:
                 },
             },
             "notification": {
-                "email": {"enabled": False, "recipients": ["admin@example.com"]},
+                "email": {
+                    "enabled": False,
+                    "recipients": ["admin@example.com"],
+                },
                 "slack": {"enabled": False, "webhook_url": ""},
             },
         }
@@ -457,10 +519,26 @@ class DisasterRecoveryManager:
             priority=1,  # 最高優先級
             dependencies=[],
             procedures=[
-                {"step": 1, "action": "stop_application_services", "timeout": 300},
-                {"step": 2, "action": "restore_database_backup", "timeout": 1800},
-                {"step": 3, "action": "verify_database_integrity", "timeout": 600},
-                {"step": 4, "action": "start_application_services", "timeout": 300},
+                {
+                    "step": 1,
+                    "action": "stop_application_services",
+                    "timeout": 300,
+                },
+                {
+                    "step": 2,
+                    "action": "restore_database_backup",
+                    "timeout": 1800,
+                },
+                {
+                    "step": 3,
+                    "action": "verify_database_integrity",
+                    "timeout": 600,
+                },
+                {
+                    "step": 4,
+                    "action": "start_application_services",
+                    "timeout": 300,
+                },
             ],
             validation_steps=[
                 {"check": "database_connectivity", "timeout": 30},
@@ -477,7 +555,11 @@ class DisasterRecoveryManager:
             priority=2,  # 高優先級
             dependencies=["database_recovery"],
             procedures=[
-                {"step": 1, "action": "activate_backup_services", "timeout": 180},
+                {
+                    "step": 1,
+                    "action": "activate_backup_services",
+                    "timeout": 180,
+                },
                 {"step": 2, "action": "update_load_balancer", "timeout": 60},
                 {"step": 3, "action": "verify_service_health", "timeout": 120},
             ],
@@ -508,7 +590,8 @@ class DisasterRecoveryManager:
             initiated_at=datetime.utcnow(),
             status=RecoveryStatus.INITIATED,
             progress_percentage=0.0,
-            estimated_completion=datetime.utcnow() + timedelta(minutes=plan.target_rto),
+            estimated_completion=datetime.utcnow()
+            + timedelta(minutes=plan.target_rto),
             logs=[],
             metadata={"plan": asdict(plan)},
         )
@@ -524,7 +607,9 @@ class DisasterRecoveryManager:
             total_steps = len(plan.procedures)
             for i, procedure in enumerate(plan.procedures):
                 await self._execute_recovery_procedure(operation, procedure)
-                operation.progress_percentage = ((i + 1) / total_steps) * 80  # 80% for procedures
+                operation.progress_percentage = (
+                    (i + 1) / total_steps
+                ) * 80  # 80% for procedures
 
             # 執行驗證步驟
             total_validations = len(plan.validation_steps)
@@ -697,7 +782,9 @@ class DisasterRecoveryManager:
         logger.info("驗證核心功能...")
         await asyncio.sleep(2)
 
-    async def get_recovery_status(self, operation_id: str) -> Optional[RecoveryOperation]:
+    async def get_recovery_status(
+        self, operation_id: str
+    ) -> Optional[RecoveryOperation]:
         """獲取恢復操作狀態"""
         return self.recovery_operations.get(operation_id)
 
@@ -722,7 +809,9 @@ async def main():
         print("檢測到嚴重問題，執行恢復計劃...")
 
         # 執行資料庫恢復
-        recovery_op = await dr_manager.execute_recovery_plan("database_recovery", "admin")
+        recovery_op = await dr_manager.execute_recovery_plan(
+            "database_recovery", "admin"
+        )
         print(f"恢復操作狀態: {recovery_op.status}")
 
     # 開始監控（這會持續運行）
diff --git a/auto_generate_video_fold6/scripts/fix_flake8.py b/auto_generate_video_fold6/scripts/fix_flake8.py
index 3deda6f..9056dbe 100644
--- a/auto_generate_video_fold6/scripts/fix_flake8.py
+++ b/auto_generate_video_fold6/scripts/fix_flake8.py
@@ -9,40 +9,43 @@ import subprocess
 import sys
 from pathlib import Path
 
+
 def fix_line_length(content, max_length=79):
     """修復行長度過長的問題"""
-    lines = content.split('\n')
+    lines = content.split("\n")
     fixed_lines = []
-    
+
     for line in lines:
         if len(line) <= max_length:
             fixed_lines.append(line)
             continue
-            
+
         # 如果是導入語句，嘗試拆分
-        if line.strip().startswith('from ') and 'import' in line:
-            if '(' not in line and ',' in line:
+        if line.strip().startswith("from ") and "import" in line:
+            if "(" not in line and "," in line:
                 # 拆分多個導入
-                parts = line.split('import', 1)
+                parts = line.split("import", 1)
                 if len(parts) == 2:
-                    prefix = parts[0] + 'import ('
-                    imports = [imp.strip() for imp in parts[1].split(',')]
+                    prefix = parts[0] + "import ("
+                    imports = [imp.strip() for imp in parts[1].split(",")]
                     fixed_lines.append(prefix)
                     for imp in imports:
                         fixed_lines.append(f"    {imp.strip()},")
-                    fixed_lines.append(')')
+                    fixed_lines.append(")")
                     continue
-        
+
         # 如果是字符串，嘗試在適當位置換行
         if '"' in line or "'" in line:
             # 簡單的字符串拆分
             indent = len(line) - len(line.lstrip())
             if len(line) > max_length:
                 # 尋找適當的斷點
-                for i in range(max_length-10, 40, -1):
-                    if line[i] in [' ', ',', '.', '(', ')']:
-                        fixed_lines.append(line[:i] + ' \\')
-                        fixed_lines.append(' ' * (indent + 4) + line[i:].lstrip())
+                for i in range(max_length - 10, 40, -1):
+                    if line[i] in [" ", ",", ".", "(", ")"]:
+                        fixed_lines.append(line[:i] + " \\")
+                        fixed_lines.append(
+                            " " * (indent + 4) + line[i:].lstrip()
+                        )
                         break
                 else:
                     fixed_lines.append(line)  # 如果找不到好的斷點，保持原樣
@@ -50,159 +53,175 @@ def fix_line_length(content, max_length=79):
                 fixed_lines.append(line)
         else:
             # 對於其他行，簡單處理
-            if len(line) > max_length and '(' in line:
+            if len(line) > max_length and "(" in line:
                 # 尋找括號後的位置進行換行
-                paren_pos = line.find('(') + 1
+                paren_pos = line.find("(") + 1
                 if paren_pos > 0 and paren_pos < max_length - 10:
                     before_paren = line[:paren_pos]
                     after_paren = line[paren_pos:]
                     indent = len(before_paren) - len(before_paren.lstrip()) + 4
                     fixed_lines.append(before_paren)
-                    fixed_lines.append(' ' * indent + after_paren)
+                    fixed_lines.append(" " * indent + after_paren)
                 else:
                     fixed_lines.append(line)
             else:
                 fixed_lines.append(line)
-    
-    return '\n'.join(fixed_lines)
+
+    return "\n".join(fixed_lines)
+
 
 def remove_unused_imports(content):
     """移除明顯未使用的導入"""
-    lines = content.split('\n')
+    lines = content.split("\n")
     fixed_lines = []
-    
+
     # 常見的未使用導入模式
     unused_patterns = [
-        r'^from abc import ABC, abstractmethod\s*$',
-        r'^import asyncio\s*$',
-        r'^import torch\s*$', 
-        r'^import torchaudio\s*$',
-        r'^import os\s*$',
-        r'^import tempfile\s*$',
-        r'^from typing import.*Optional.*$',
-        r'^from typing import.*Tuple.*$',
-        r'^from typing import.*Union.*$',
-        r'^from datetime import datetime\s*$',
+        r"^from abc import ABC, abstractmethod\s*$",
+        r"^import asyncio\s*$",
+        r"^import torch\s*$",
+        r"^import torchaudio\s*$",
+        r"^import os\s*$",
+        r"^import tempfile\s*$",
+        r"^from typing import.*Optional.*$",
+        r"^from typing import.*Tuple.*$",
+        r"^from typing import.*Union.*$",
+        r"^from datetime import datetime\s*$",
     ]
-    
+
     for line in lines:
         should_remove = False
         for pattern in unused_patterns:
             if re.match(pattern, line.strip()):
                 # 簡單檢查：如果導入的內容在後續代碼中出現，則保留
                 import_parts = []
-                if 'import' in line:
-                    if 'from' in line:
+                if "import" in line:
+                    if "from" in line:
                         # from xxx import yyy
-                        parts = line.split('import', 1)
+                        parts = line.split("import", 1)
                         if len(parts) == 2:
-                            import_parts = [p.strip() for p in parts[1].split(',')]
+                            import_parts = [
+                                p.strip() for p in parts[1].split(",")
+                            ]
                     else:
                         # import xxx
-                        import_parts = [line.replace('import', '').strip()]
-                
+                        import_parts = [line.replace("import", "").strip()]
+
                 # 檢查是否在內容中使用
-                rest_content = '\n'.join(lines[lines.index(line)+1:])
+                rest_content = "\n".join(lines[lines.index(line) + 1 :])
                 used = False
                 for part in import_parts:
-                    clean_part = part.split(' as ')[0] if ' as ' in part else part
+                    clean_part = (
+                        part.split(" as ")[0] if " as " in part else part
+                    )
                     if clean_part and clean_part in rest_content:
                         used = True
                         break
-                
+
                 if not used:
                     should_remove = True
                 break
-        
+
         if not should_remove:
             fixed_lines.append(line)
-    
-    return '\n'.join(fixed_lines)
+
+    return "\n".join(fixed_lines)
+
 
 def fix_bare_except(content):
     """修復裸露的 except 語句"""
-    content = re.sub(r'except\s*:', 'except Exception:', content)
+    content = re.sub(r"except\s*:", "except Exception:", content)
     return content
 
+
 def fix_trailing_whitespace(content):
     """移除行尾空白"""
-    lines = content.split('\n')
+    lines = content.split("\n")
     fixed_lines = [line.rstrip() for line in lines]
-    return '\n'.join(fixed_lines)
+    return "\n".join(fixed_lines)
+
 
 def fix_whitespace_before_colon(content):
     """修復冒號前的空白"""
-    content = re.sub(r'\s+:', ':', content)
+    content = re.sub(r"\s+:", ":", content)
     return content
 
+
 def fix_python_file(file_path):
     """修復單個 Python 檔案"""
     try:
-        with open(file_path, 'r', encoding='utf-8') as f:
+        with open(file_path, "r", encoding="utf-8") as f:
             content = f.read()
-        
+
         original_content = content
-        
+
         # 應用修復
         content = remove_unused_imports(content)
         content = fix_line_length(content)
-        content = fix_bare_except(content) 
+        content = fix_bare_except(content)
         content = fix_trailing_whitespace(content)
         content = fix_whitespace_before_colon(content)
-        
+
         # 只有在內容有變化時才寫入
         if content != original_content:
-            with open(file_path, 'w', encoding='utf-8') as f:
+            with open(file_path, "w", encoding="utf-8") as f:
                 f.write(content)
             print(f"✓ 修復: {file_path}")
             return True
-        
+
         return False
-        
+
     except Exception as e:
         print(f"✗ 錯誤處理 {file_path}: {e}")
         return False
 
+
 def main():
     """主函數"""
-    services_dir = Path('services')
+    services_dir = Path("services")
     if not services_dir.exists():
         print("錯誤: 找不到 services 目錄")
         sys.exit(1)
-    
+
     fixed_count = 0
     total_count = 0
-    
+
     print("開始修復 Python 檔案...")
-    
+
     # 遞歸處理所有 Python 檔案
-    for py_file in services_dir.rglob('*.py'):
+    for py_file in services_dir.rglob("*.py"):
         total_count += 1
         if fix_python_file(py_file):
             fixed_count += 1
-    
+
     print(f"\n修復完成!")
     print(f"總檔案數: {total_count}")
     print(f"已修復: {fixed_count}")
-    
+
     # 運行 flake8 檢查結果
     print("\n運行 flake8 檢查...")
     try:
-        result = subprocess.run([
-            'flake8', 'services/', 
-            '--max-line-length=79',
-            '--count',
-            '--statistics'
-        ], capture_output=True, text=True)
-        
+        result = subprocess.run(
+            [
+                "flake8",
+                "services/",
+                "--max-line-length=79",
+                "--count",
+                "--statistics",
+            ],
+            capture_output=True,
+            text=True,
+        )
+
         if result.returncode == 0:
             print("✓ 所有 flake8 檢查通過!")
         else:
             print("還有一些問題需要手動修復:")
             print(result.stdout)
-            
+
     except FileNotFoundError:
         print("注意: 無法運行 flake8 檢查 (未安裝)")
 
-if __name__ == '__main__':
-    main()
\ No newline at end of file
+
+if __name__ == "__main__":
+    main()
diff --git a/auto_generate_video_fold6/scripts/generate-tdd-report.py b/auto_generate_video_fold6/scripts/generate-tdd-report.py
index 0d503f1..72dd9cd 100755
--- a/auto_generate_video_fold6/scripts/generate-tdd-report.py
+++ b/auto_generate_video_fold6/scripts/generate-tdd-report.py
@@ -13,27 +13,30 @@ from pathlib import Path
 from typing import Dict, List, Optional, Any
 import xml.etree.ElementTree as ET
 
+
 class TDDReportGenerator:
     """TDD 測試報告生成器"""
-    
+
     def __init__(self):
         self.project_root = Path.cwd()
-        self.report_dir = self.project_root / 'tdd-reports'
-        self.coverage_dir = self.project_root / 'coverage-reports'
+        self.report_dir = self.project_root / "tdd-reports"
+        self.coverage_dir = self.project_root / "coverage-reports"
         self.timestamp = datetime.now().isoformat()
-        
+
         # 確保報告目錄存在
         self.report_dir.mkdir(exist_ok=True)
-        
+
         # TDD 配置
         self.tdd_config = {
-            'coverage_threshold': 90,
-            'complexity_limit': 10,
-            'max_line_length': 88,
-            'required_test_patterns': ['test_*.py', '*_test.py', 'tests/']
+            "coverage_threshold": 90,
+            "complexity_limit": 10,
+            "max_line_length": 88,
+            "required_test_patterns": ["test_*.py", "*_test.py", "tests/"],
         }
-    
-    def run_command(self, cmd: str, cwd: Optional[Path] = None, timeout: int = 60) -> tuple:
+
+    def run_command(
+        self, cmd: str, cwd: Optional[Path] = None, timeout: int = 60
+    ) -> tuple:
         """安全執行命令並返回結果"""
         try:
             result = subprocess.run(
@@ -41,26 +44,26 @@ class TDDReportGenerator:
                 cwd=cwd or self.project_root,
                 capture_output=True,
                 text=True,
-                timeout=timeout
+                timeout=timeout,
             )
             return result.returncode == 0, result.stdout, result.stderr
         except subprocess.TimeoutExpired:
             return False, "", f"命令超時: {cmd}"
         except Exception as e:
             return False, "", str(e)
-    
+
     def collect_git_info(self) -> Optional[Dict[str, Any]]:
         """收集 Git 資訊"""
         print("📊 收集 Git 資訊...")
-        
+
         git_commands = {
-            'commit_hash': 'git rev-parse HEAD',
-            'commit_message': 'git log -1 --pretty=format:%s',
-            'branch': 'git rev-parse --abbrev-ref HEAD',
-            'author': 'git log -1 --pretty=format:%an',
-            'date': 'git log -1 --pretty=format:%ai'
+            "commit_hash": "git rev-parse HEAD",
+            "commit_message": "git log -1 --pretty=format:%s",
+            "branch": "git rev-parse --abbrev-ref HEAD",
+            "author": "git log -1 --pretty=format:%an",
+            "date": "git log -1 --pretty=format:%ai",
         }
-        
+
         git_info = {}
         for key, cmd in git_commands.items():
             success, stdout, stderr = self.run_command(cmd)
@@ -69,355 +72,393 @@ class TDDReportGenerator:
             else:
                 print(f"⚠️ 無法取得 {key}: {stderr}")
                 return None
-        
+
         # 檢測 TDD 階段
-        commit_msg = git_info.get('commit_message', '')
-        tdd_phase = 'unknown'
-        if commit_msg.startswith('red:'):
-            tdd_phase = 'red'
-        elif commit_msg.startswith('green:'):
-            tdd_phase = 'green'
-        elif commit_msg.startswith('refactor:'):
-            tdd_phase = 'refactor'
-        
-        git_info.update({
-            'short_hash': git_info['commit_hash'][:8],
-            'tdd_phase': tdd_phase
-        })
-        
+        commit_msg = git_info.get("commit_message", "")
+        tdd_phase = "unknown"
+        if commit_msg.startswith("red:"):
+            tdd_phase = "red"
+        elif commit_msg.startswith("green:"):
+            tdd_phase = "green"
+        elif commit_msg.startswith("refactor:"):
+            tdd_phase = "refactor"
+
+        git_info.update(
+            {"short_hash": git_info["commit_hash"][:8], "tdd_phase": tdd_phase}
+        )
+
         return git_info
-    
+
     def collect_frontend_data(self) -> Dict[str, Any]:
         """收集前端測試數據"""
         print("📱 收集前端測試數據...")
-        
-        frontend_dir = self.project_root / 'frontend'
+
+        frontend_dir = self.project_root / "frontend"
         frontend_data = {
-            'exists': frontend_dir.exists(),
-            'tests_run': False,
-            'coverage': None,
-            'test_results': None,
-            'lint_results': None
+            "exists": frontend_dir.exists(),
+            "tests_run": False,
+            "coverage": None,
+            "test_results": None,
+            "lint_results": None,
         }
-        
-        if not frontend_data['exists']:
+
+        if not frontend_data["exists"]:
             return frontend_data
-        
+
         # 檢查 package.json
-        package_json = frontend_dir / 'package.json'
+        package_json = frontend_dir / "package.json"
         if package_json.exists():
             try:
                 with open(package_json) as f:
                     package_data = json.load(f)
-                frontend_data['scripts'] = package_data.get('scripts', {})
+                frontend_data["scripts"] = package_data.get("scripts", {})
             except Exception as e:
                 print(f"⚠️ 無法讀取 package.json: {e}")
-        
+
         # 收集測試覆蓋率
-        coverage_file = frontend_dir / 'coverage' / 'coverage-summary.json'
+        coverage_file = frontend_dir / "coverage" / "coverage-summary.json"
         if coverage_file.exists():
             try:
                 with open(coverage_file) as f:
                     coverage_data = json.load(f)
-                
-                frontend_data['coverage'] = {
-                    'statements': coverage_data['total']['statements']['pct'],
-                    'branches': coverage_data['total']['branches']['pct'],
-                    'functions': coverage_data['total']['functions']['pct'],
-                    'lines': coverage_data['total']['lines']['pct']
+
+                frontend_data["coverage"] = {
+                    "statements": coverage_data["total"]["statements"]["pct"],
+                    "branches": coverage_data["total"]["branches"]["pct"],
+                    "functions": coverage_data["total"]["functions"]["pct"],
+                    "lines": coverage_data["total"]["lines"]["pct"],
                 }
             except Exception as e:
                 print(f"⚠️ 覆蓋率數據讀取失敗: {e}")
-        
+
         # 嘗試執行測試
         os.chdir(frontend_dir)
         try:
             # 檢查是否有 node_modules
-            if (frontend_dir / 'node_modules').exists():
+            if (frontend_dir / "node_modules").exists():
                 # 執行測試
-                success, stdout, stderr = self.run_command('npm test -- --run --reporter=json')
+                success, stdout, stderr = self.run_command(
+                    "npm test -- --run --reporter=json"
+                )
                 if success:
-                    frontend_data['tests_run'] = True
-                    frontend_data['test_results'] = self.parse_test_output(stdout)
+                    frontend_data["tests_run"] = True
+                    frontend_data["test_results"] = self.parse_test_output(
+                        stdout
+                    )
                 else:
                     print(f"⚠️ 前端測試執行失敗: {stderr}")
             else:
                 print("⚠️ 前端依賴未安裝，跳過測試執行")
-                
+
         except Exception as e:
             print(f"前端測試執行錯誤: {e}")
         finally:
             os.chdir(self.project_root)
-        
+
         return frontend_data
-    
+
     def collect_backend_data(self) -> Dict[str, Any]:
         """收集後端測試數據"""
         print("🔧 收集後端測試數據...")
-        
-        services_dir = self.project_root / 'services'
+
+        services_dir = self.project_root / "services"
         backend_data = {
-            'services': [],
-            'total_coverage': 0,
-            'total_tests': 0,
-            'total_services': 0
+            "services": [],
+            "total_coverage": 0,
+            "total_tests": 0,
+            "total_services": 0,
         }
-        
+
         if not services_dir.exists():
             return backend_data
-        
+
         # 收集所有服務
         for service_dir in services_dir.iterdir():
-            if service_dir.is_dir() and not service_dir.name.startswith('.'):
+            if service_dir.is_dir() and not service_dir.name.startswith("."):
                 service_data = self.collect_service_data(service_dir)
-                backend_data['services'].append(service_data)
-        
+                backend_data["services"].append(service_data)
+
         # 計算總體統計
-        valid_services = [s for s in backend_data['services'] if s['coverage']]
-        backend_data['total_services'] = len(backend_data['services'])
-        
+        valid_services = [s for s in backend_data["services"] if s["coverage"]]
+        backend_data["total_services"] = len(backend_data["services"])
+
         if valid_services:
-            backend_data['total_coverage'] = sum(
-                s['coverage']['statements'] for s in valid_services
+            backend_data["total_coverage"] = sum(
+                s["coverage"]["statements"] for s in valid_services
             ) / len(valid_services)
-        
-        backend_data['total_tests'] = sum(
-            s['test_results']['total'] for s in backend_data['services']
-            if s['test_results']
+
+        backend_data["total_tests"] = sum(
+            s["test_results"]["total"]
+            for s in backend_data["services"]
+            if s["test_results"]
         )
-        
+
         return backend_data
-    
+
     def collect_service_data(self, service_dir: Path) -> Dict[str, Any]:
         """收集單個服務的測試數據"""
         service_name = service_dir.name
         service_data = {
-            'name': service_name,
-            'path': str(service_dir),
-            'exists': service_dir.exists(),
-            'has_tests': False,
-            'coverage': None,
-            'test_results': None,
-            'code_quality': None,
-            'requirements': None
+            "name": service_name,
+            "path": str(service_dir),
+            "exists": service_dir.exists(),
+            "has_tests": False,
+            "coverage": None,
+            "test_results": None,
+            "code_quality": None,
+            "requirements": None,
         }
-        
-        if not service_data['exists']:
+
+        if not service_data["exists"]:
             return service_data
-        
+
         # 檢查測試目錄
-        tests_dir = service_dir / 'tests'
-        service_data['has_tests'] = tests_dir.exists()
-        
+        tests_dir = service_dir / "tests"
+        service_data["has_tests"] = tests_dir.exists()
+
         # 檢查 requirements
-        for req_file in ['requirements.txt', 'requirements-dev.txt']:
+        for req_file in ["requirements.txt", "requirements-dev.txt"]:
             req_path = service_dir / req_file
             if req_path.exists():
-                if not service_data['requirements']:
-                    service_data['requirements'] = {}
+                if not service_data["requirements"]:
+                    service_data["requirements"] = {}
                 try:
                     with open(req_path) as f:
-                        service_data['requirements'][req_file] = f.read().splitlines()
+                        service_data["requirements"][req_file] = (
+                            f.read().splitlines()
+                        )
                 except Exception as e:
                     print(f"⚠️ 無法讀取 {req_file}: {e}")
-        
-        if not service_data['has_tests']:
+
+        if not service_data["has_tests"]:
             return service_data
-        
+
         # 切換到服務目錄
         original_cwd = os.getcwd()
         os.chdir(service_dir)
-        
+
         try:
             # 收集測試覆蓋率
             success, stdout, stderr = self.run_command(
-                'python -m pytest --cov=app --cov-report=json --cov-report=term-missing -q'
+                "python -m pytest --cov=app --cov-report=json --cov-report=term-missing -q"
             )
-            
+
             if success:
-                coverage_file = service_dir / 'coverage.json'
+                coverage_file = service_dir / "coverage.json"
                 if coverage_file.exists():
                     try:
                         with open(coverage_file) as f:
                             coverage_data = json.load(f)
-                        
-                        service_data['coverage'] = {
-                            'statements': round(coverage_data['totals']['percent_covered'] or 0),
-                            'missing': coverage_data['totals']['missing_lines'] or 0,
-                            'total': coverage_data['totals']['num_statements'] or 0
+
+                        service_data["coverage"] = {
+                            "statements": round(
+                                coverage_data["totals"]["percent_covered"] or 0
+                            ),
+                            "missing": coverage_data["totals"]["missing_lines"]
+                            or 0,
+                            "total": coverage_data["totals"]["num_statements"]
+                            or 0,
                         }
                     except Exception as e:
                         print(f"⚠️ {service_name} 覆蓋率解析失敗: {e}")
-            
+
             # 收集測試結果
-            success, stdout, stderr = self.run_command('python -m pytest --tb=no --quiet')
+            success, stdout, stderr = self.run_command(
+                "python -m pytest --tb=no --quiet"
+            )
             if success or stderr:  # pytest 可能返回非零但有有效輸出
-                service_data['test_results'] = self.parse_pytest_output(stdout + stderr)
-            
+                service_data["test_results"] = self.parse_pytest_output(
+                    stdout + stderr
+                )
+
             # 收集程式碼品質
             success, stdout, stderr = self.run_command(
-                f'flake8 app/ --max-complexity={self.tdd_config["complexity_limit"]} --statistics'
+                f"flake8 app/ --max-complexity={self.tdd_config['complexity_limit']} --statistics"
+            )
+            service_data["code_quality"] = self.parse_flake8_output(
+                stdout + stderr
             )
-            service_data['code_quality'] = self.parse_flake8_output(stdout + stderr)
-            
+
         except Exception as e:
             print(f"⚠️ {service_name} 數據收集錯誤: {e}")
         finally:
             os.chdir(original_cwd)
-        
+
         return service_data
-    
+
     def parse_test_output(self, output: str) -> Dict[str, int]:
         """解析測試輸出"""
-        results = {'total': 0, 'passed': 0, 'failed': 0, 'skipped': 0}
-        
+        results = {"total": 0, "passed": 0, "failed": 0, "skipped": 0}
+
         # 簡化的解析邏輯
-        lines = output.split('\n')
+        lines = output.split("\n")
         for line in lines:
-            if 'passed' in line.lower():
+            if "passed" in line.lower():
                 import re
-                match = re.search(r'(\d+)\s+passed', line)
+
+                match = re.search(r"(\d+)\s+passed", line)
                 if match:
-                    results['passed'] = int(match.group(1))
-            
-            if 'failed' in line.lower():
+                    results["passed"] = int(match.group(1))
+
+            if "failed" in line.lower():
                 import re
-                match = re.search(r'(\d+)\s+failed', line)
+
+                match = re.search(r"(\d+)\s+failed", line)
                 if match:
-                    results['failed'] = int(match.group(1))
-            
-            if 'skipped' in line.lower():
+                    results["failed"] = int(match.group(1))
+
+            if "skipped" in line.lower():
                 import re
-                match = re.search(r'(\d+)\s+skipped', line)
+
+                match = re.search(r"(\d+)\s+skipped", line)
                 if match:
-                    results['skipped'] = int(match.group(1))
-        
-        results['total'] = results['passed'] + results['failed'] + results['skipped']
+                    results["skipped"] = int(match.group(1))
+
+        results["total"] = (
+            results["passed"] + results["failed"] + results["skipped"]
+        )
         return results
-    
+
     def parse_pytest_output(self, output: str) -> Dict[str, int]:
         """解析 pytest 輸出"""
-        results = {'total': 0, 'passed': 0, 'failed': 0, 'errors': 0}
-        
+        results = {"total": 0, "passed": 0, "failed": 0, "errors": 0}
+
         import re
-        
+
         # 尋找測試結果摘要
         summary_patterns = [
-            r'(\d+)\s+passed',
-            r'(\d+)\s+failed',
-            r'(\d+)\s+error',
-            r'(\d+)\s+skipped'
+            r"(\d+)\s+passed",
+            r"(\d+)\s+failed",
+            r"(\d+)\s+error",
+            r"(\d+)\s+skipped",
         ]
-        
+
         for pattern in summary_patterns:
             matches = re.findall(pattern, output, re.IGNORECASE)
             if matches:
                 count = int(matches[-1])  # 取最後一個匹配
-                if 'passed' in pattern:
-                    results['passed'] = count
-                elif 'failed' in pattern:
-                    results['failed'] = count
-                elif 'error' in pattern:
-                    results['errors'] = count
-        
-        results['total'] = results['passed'] + results['failed'] + results['errors']
+                if "passed" in pattern:
+                    results["passed"] = count
+                elif "failed" in pattern:
+                    results["failed"] = count
+                elif "error" in pattern:
+                    results["errors"] = count
+
+        results["total"] = (
+            results["passed"] + results["failed"] + results["errors"]
+        )
         return results
-    
+
     def parse_flake8_output(self, output: str) -> Dict[str, Any]:
         """解析 flake8 輸出"""
-        lines = output.strip().split('\n')
+        lines = output.strip().split("\n")
         issues = 0
         complexity_issues = 0
         error_types = {}
-        
+
         for line in lines:
-            if line.strip() and not line.startswith('Total'):
+            if line.strip() and not line.startswith("Total"):
                 issues += 1
-                
+
                 # 檢查複雜度問題
-                if 'C901' in line or 'too complex' in line:
+                if "C901" in line or "too complex" in line:
                     complexity_issues += 1
-                
+
                 # 統計錯誤類型
                 import re
-                match = re.search(r'([A-Z]\d{3})', line)
+
+                match = re.search(r"([A-Z]\d{3})", line)
                 if match:
                     error_code = match.group(1)
-                    error_types[error_code] = error_types.get(error_code, 0) + 1
-        
+                    error_types[error_code] = (
+                        error_types.get(error_code, 0) + 1
+                    )
+
         return {
-            'total_issues': issues,
-            'complexity_issues': complexity_issues,
-            'error_types': error_types
+            "total_issues": issues,
+            "complexity_issues": complexity_issues,
+            "error_types": error_types,
         }
-    
+
     def check_tdd_compliance(self, data: Dict[str, Any]) -> Dict[str, Any]:
         """檢查 TDD 合規性"""
-        frontend = data['frontend']
-        backend = data['backend']
-        
+        frontend = data["frontend"]
+        backend = data["backend"]
+
         compliance = {
-            'overall': False,
-            'coverage': False,
-            'test_existence': False,
-            'code_quality': False,
-            'tdd_workflow': False,
-            'score': 0,
-            'details': {}
+            "overall": False,
+            "coverage": False,
+            "test_existence": False,
+            "code_quality": False,
+            "tdd_workflow": False,
+            "score": 0,
+            "details": {},
         }
-        
+
         # 檢查覆蓋率 (40分)
-        avg_coverage = backend.get('total_coverage', 0)
-        frontend_coverage = frontend.get('coverage', {}).get('statements', 0) if frontend.get('coverage') else 0
-        
-        overall_coverage = (avg_coverage + frontend_coverage) / 2 if frontend_coverage else avg_coverage
-        compliance['coverage'] = overall_coverage >= self.tdd_config['coverage_threshold']
-        compliance['details']['coverage_score'] = overall_coverage
-        
+        avg_coverage = backend.get("total_coverage", 0)
+        frontend_coverage = (
+            frontend.get("coverage", {}).get("statements", 0)
+            if frontend.get("coverage")
+            else 0
+        )
+
+        overall_coverage = (
+            (avg_coverage + frontend_coverage) / 2
+            if frontend_coverage
+            else avg_coverage
+        )
+        compliance["coverage"] = (
+            overall_coverage >= self.tdd_config["coverage_threshold"]
+        )
+        compliance["details"]["coverage_score"] = overall_coverage
+
         # 檢查測試存在性 (30分)
-        has_backend_tests = any(s['has_tests'] for s in backend.get('services', []))
-        has_frontend_tests = frontend.get('tests_run', False)
-        compliance['test_existence'] = has_backend_tests or has_frontend_tests
-        
+        has_backend_tests = any(
+            s["has_tests"] for s in backend.get("services", [])
+        )
+        has_frontend_tests = frontend.get("tests_run", False)
+        compliance["test_existence"] = has_backend_tests or has_frontend_tests
+
         # 檢查程式碼品質 (20分)
         total_quality_issues = sum(
-            s.get('code_quality', {}).get('total_issues', 0) 
-            for s in backend.get('services', [])
+            s.get("code_quality", {}).get("total_issues", 0)
+            for s in backend.get("services", [])
         )
-        compliance['code_quality'] = total_quality_issues < 10
-        compliance['details']['quality_issues'] = total_quality_issues
-        
+        compliance["code_quality"] = total_quality_issues < 10
+        compliance["details"]["quality_issues"] = total_quality_issues
+
         # 檢查 TDD 工作流程 (10分)
-        git_info = data.get('git')
+        git_info = data.get("git")
         if git_info:
-            compliance['tdd_workflow'] = git_info.get('tdd_phase') != 'unknown'
-            compliance['details']['tdd_phase'] = git_info.get('tdd_phase')
-        
+            compliance["tdd_workflow"] = git_info.get("tdd_phase") != "unknown"
+            compliance["details"]["tdd_phase"] = git_info.get("tdd_phase")
+
         # 計算總分
         score = 0
-        if compliance['coverage']:
+        if compliance["coverage"]:
             score += 40
-        if compliance['test_existence']:
+        if compliance["test_existence"]:
             score += 30
-        if compliance['code_quality']:
+        if compliance["code_quality"]:
             score += 20
-        if compliance['tdd_workflow']:
+        if compliance["tdd_workflow"]:
             score += 10
-        
-        compliance['score'] = score
-        compliance['overall'] = score >= 80
-        
+
+        compliance["score"] = score
+        compliance["overall"] = score >= 80
+
         return compliance
-    
+
     def generate_html_report(self, data: Dict[str, Any]) -> Path:
         """生成 HTML 報告"""
         print("📝 生成 HTML 報告...")
-        
-        frontend = data['frontend']
-        backend = data['backend']
-        git = data['git']
+
+        frontend = data["frontend"]
+        backend = data["backend"]
+        git = data["git"]
         compliance = self.check_tdd_compliance(data)
-        
+
         # 讀取 HTML 模板（這裡簡化為內嵌）
         html_template = """
 <!DOCTYPE html>
@@ -544,158 +585,184 @@ class TDDReportGenerator:
     </div>
 </body>
 </html>"""
-        
+
         # 準備模板變數
         template_vars = {
-            'timestamp': self.timestamp,
-            'compliance_score': compliance['score'],
-            'compliance_color': '#27ae60' if compliance['overall'] else '#e74c3c',
-            'compliance_class': 'success' if compliance['overall'] else 'error',
-            'compliance_status': '✅ 通過' if compliance['overall'] else '❌ 需改進',
-            'coverage_class': 'success' if compliance['coverage'] else 'warning',
-            'coverage_status': '✅ 達標' if compliance['coverage'] else '⚠️ 不足',
-            'test_class': 'success' if compliance['test_existence'] else 'error',
-            'test_status': '✅ 存在' if compliance['test_existence'] else '❌ 缺失',
-            'quality_class': 'success' if compliance['code_quality'] else 'warning',
-            'quality_status': '✅ 良好' if compliance['code_quality'] else '⚠️ 有問題',
+            "timestamp": self.timestamp,
+            "compliance_score": compliance["score"],
+            "compliance_color": "#27ae60"
+            if compliance["overall"]
+            else "#e74c3c",
+            "compliance_class": "success"
+            if compliance["overall"]
+            else "error",
+            "compliance_status": "✅ 通過"
+            if compliance["overall"]
+            else "❌ 需改進",
+            "coverage_class": "success"
+            if compliance["coverage"]
+            else "warning",
+            "coverage_status": "✅ 達標"
+            if compliance["coverage"]
+            else "⚠️ 不足",
+            "test_class": "success"
+            if compliance["test_existence"]
+            else "error",
+            "test_status": "✅ 存在"
+            if compliance["test_existence"]
+            else "❌ 缺失",
+            "quality_class": "success"
+            if compliance["code_quality"]
+            else "warning",
+            "quality_status": "✅ 良好"
+            if compliance["code_quality"]
+            else "⚠️ 有問題",
         }
-        
+
         # Git 資訊
         if git:
-            template_vars['git_info'] = f"""
-                <p><strong>提交:</strong> {git['short_hash']} - {git['commit_message']}</p>
-                <p><strong>分支:</strong> {git['branch']} | <strong>作者:</strong> {git['author']}</p>
-                <p><strong>時間:</strong> {git['date']}</p>
-                <span class="tdd-phase phase-{git['tdd_phase']}">TDD {git['tdd_phase'].upper()} 階段</span>
+            template_vars["git_info"] = f"""
+                <p><strong>提交:</strong> {git["short_hash"]} - {git["commit_message"]}</p>
+                <p><strong>分支:</strong> {git["branch"]} | <strong>作者:</strong> {git["author"]}</p>
+                <p><strong>時間:</strong> {git["date"]}</p>
+                <span class="tdd-phase phase-{git["tdd_phase"]}">TDD {git["tdd_phase"].upper()} 階段</span>
             """
         else:
-            template_vars['git_info'] = '<p>⚠️ 無法取得 Git 資訊</p>'
-        
+            template_vars["git_info"] = "<p>⚠️ 無法取得 Git 資訊</p>"
+
         # 前端內容
-        if frontend['exists']:
+        if frontend["exists"]:
             frontend_html = []
-            if frontend.get('coverage'):
-                cov = frontend['coverage']
+            if frontend.get("coverage"):
+                cov = frontend["coverage"]
                 frontend_html.append(f"""
                     <div class="metric">
                         <span>語句覆蓋率</span>
-                        <span class="metric-value {'success' if cov['statements'] >= 90 else 'warning'}">
-                            {cov['statements']}%
+                        <span class="metric-value {"success" if cov["statements"] >= 90 else "warning"}">
+                            {cov["statements"]}%
                         </span>
                     </div>
                     <div class="coverage-bar">
-                        <div class="coverage-fill" style="width: {cov['statements']}%"></div>
+                        <div class="coverage-fill" style="width: {cov["statements"]}%"></div>
                     </div>
                 """)
-            
-            if frontend.get('test_results'):
-                test = frontend['test_results']
+
+            if frontend.get("test_results"):
+                test = frontend["test_results"]
                 frontend_html.append(f"""
                     <div class="metric">
                         <span>通過測試</span>
-                        <span class="metric-value success">{test['passed']}</span>
+                        <span class="metric-value success">{test["passed"]}</span>
                     </div>
                     <div class="metric">
                         <span>失敗測試</span>
-                        <span class="metric-value {'error' if test['failed'] > 0 else 'success'}">
-                            {test['failed']}
+                        <span class="metric-value {"error" if test["failed"] > 0 else "success"}">
+                            {test["failed"]}
                         </span>
                     </div>
                 """)
-            
-            template_vars['frontend_content'] = ''.join(frontend_html) or '<p>⚠️ 未找到測試數據</p>'
+
+            template_vars["frontend_content"] = (
+                "".join(frontend_html) or "<p>⚠️ 未找到測試數據</p>"
+            )
         else:
-            template_vars['frontend_content'] = '<p class="error">❌ 前端目錄不存在</p>'
-        
+            template_vars["frontend_content"] = (
+                '<p class="error">❌ 前端目錄不存在</p>'
+            )
+
         # 後端內容
-        if backend['services']:
+        if backend["services"]:
             backend_html = []
             backend_html.append(f"""
                 <div class="metric">
                     <span>服務總數</span>
-                    <span class="metric-value">{backend['total_services']}</span>
+                    <span class="metric-value">{backend["total_services"]}</span>
                 </div>
                 <div class="metric">
                     <span>平均覆蓋率</span>
-                    <span class="metric-value {'success' if backend['total_coverage'] >= 90 else 'warning'}">
-                        {backend['total_coverage']:.1f}%
+                    <span class="metric-value {"success" if backend["total_coverage"] >= 90 else "warning"}">
+                        {backend["total_coverage"]:.1f}%
                     </span>
                 </div>
                 <div class="metric">
                     <span>總測試數</span>
-                    <span class="metric-value">{backend['total_tests']}</span>
+                    <span class="metric-value">{backend["total_tests"]}</span>
                 </div>
             """)
-            
-            template_vars['backend_content'] = ''.join(backend_html)
+
+            template_vars["backend_content"] = "".join(backend_html)
         else:
-            template_vars['backend_content'] = '<p>⚠️ 未找到後端服務</p>'
-        
+            template_vars["backend_content"] = "<p>⚠️ 未找到後端服務</p>"
+
         # 生成 HTML
         html_content = html_template.format(**template_vars)
-        
-        report_path = self.report_dir / 'index.html'
-        with open(report_path, 'w', encoding='utf-8') as f:
+
+        report_path = self.report_dir / "index.html"
+        with open(report_path, "w", encoding="utf-8") as f:
             f.write(html_content)
-        
+
         return report_path
-    
+
     def generate_json_report(self, data: Dict[str, Any]) -> Path:
         """生成 JSON 報告"""
         print("📄 生成 JSON 報告...")
-        
+
         report_data = {
-            'timestamp': self.timestamp,
-            'version': '1.0.0',
-            'tdd_config': self.tdd_config,
-            'compliance': self.check_tdd_compliance(data),
-            **data
+            "timestamp": self.timestamp,
+            "version": "1.0.0",
+            "tdd_config": self.tdd_config,
+            "compliance": self.check_tdd_compliance(data),
+            **data,
         }
-        
-        report_path = self.report_dir / 'report.json'
-        with open(report_path, 'w', encoding='utf-8') as f:
+
+        report_path = self.report_dir / "report.json"
+        with open(report_path, "w", encoding="utf-8") as f:
             json.dump(report_data, f, indent=2, ensure_ascii=False)
-        
+
         return report_path
-    
+
     def generate(self):
         """主要執行函數"""
         print("🧬 開始生成 TDD 測試報告...")
         print("=" * 50)
-        
+
         try:
             # 收集所有數據
             data = {
-                'git': self.collect_git_info(),
-                'frontend': self.collect_frontend_data(),
-                'backend': self.collect_backend_data()
+                "git": self.collect_git_info(),
+                "frontend": self.collect_frontend_data(),
+                "backend": self.collect_backend_data(),
             }
-            
+
             # 生成報告
             html_path = self.generate_html_report(data)
             json_path = self.generate_json_report(data)
-            
+
             print("=" * 50)
             print("✅ TDD 測試報告生成完成！")
             print(f"📄 HTML 報告: {html_path}")
             print(f"🔧 JSON 報告: {json_path}")
-            
+
             # 顯示摘要
             compliance = self.check_tdd_compliance(data)
             print(f"📊 TDD 合規性評分: {compliance['score']}/100")
-            print(f"🎯 整體合規: {'✅ 通過' if compliance['overall'] else '❌ 需改進'}")
-            
+            print(
+                f"🎯 整體合規: {'✅ 通過' if compliance['overall'] else '❌ 需改進'}"
+            )
+
             return True
-            
+
         except Exception as e:
             print(f"❌ 報告生成失敗: {e}")
             import traceback
+
             traceback.print_exc()
             return False
 
+
 def main():
     """主函數"""
-    if len(sys.argv) > 1 and sys.argv[1] == '--help':
+    if len(sys.argv) > 1 and sys.argv[1] == "--help":
         print("""
 TDD 測試報告生成工具
 
@@ -713,10 +780,11 @@ TDD 測試報告生成工具
     - tdd-reports/report.json - JSON 格式數據
         """)
         return
-    
+
     generator = TDDReportGenerator()
     success = generator.generate()
     sys.exit(0 if success else 1)
 
+
 if __name__ == "__main__":
-    main()
\ No newline at end of file
+    main()
diff --git a/auto_generate_video_fold6/scripts/integration_test.py b/auto_generate_video_fold6/scripts/integration_test.py
index 4882ea4..3b04020 100644
--- a/auto_generate_video_fold6/scripts/integration_test.py
+++ b/auto_generate_video_fold6/scripts/integration_test.py
@@ -49,7 +49,9 @@ class ServiceHealth:
 class SystemIntegrationTester:
     """系統整合測試器"""
 
-    def __init__(self, config_file: str = "config/integration-test-config.json"):
+    def __init__(
+        self, config_file: str = "config/integration-test-config.json"
+    ):
         self.config = self._load_config(config_file)
         self.docker_client = docker.from_env()
         self.test_results: List[TestResult] = []
@@ -120,7 +122,9 @@ class SystemIntegrationTester:
             }
         )
 
-        logger.info(f"✅ 系統整合測試完成，狀態: {test_results['overall_status']}")
+        logger.info(
+            f"✅ 系統整合測試完成，狀態: {test_results['overall_status']}"
+        )
         return test_results
 
     async def _test_infrastructure(self) -> Dict[str, Any]:
@@ -131,7 +135,9 @@ class SystemIntegrationTester:
         try:
             # 檢查 Docker 容器狀態
             containers = self.docker_client.containers.list()
-            running_services = [c.name for c in containers if c.status == "running"]
+            running_services = [
+                c.name for c in containers if c.status == "running"
+            ]
 
             # 檢查資料庫連接
             db_status = await self._check_database_connections()
@@ -162,7 +168,11 @@ class SystemIntegrationTester:
             }
 
         except Exception as e:
-            return {"status": "FAIL", "duration_seconds": time.time() - start_time, "error": str(e)}
+            return {
+                "status": "FAIL",
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+            }
 
     async def _test_service_health(self) -> Dict[str, Any]:
         """測試服務健康狀態"""
@@ -174,9 +184,13 @@ class SystemIntegrationTester:
             health_results = {}
 
             # 並發檢查所有服務
-            with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
+            with concurrent.futures.ThreadPoolExecutor(
+                max_workers=10
+            ) as executor:
                 futures = {
-                    executor.submit(self._check_service_health, service): service
+                    executor.submit(
+                        self._check_service_health, service
+                    ): service
                     for service in services
                 }
 
@@ -185,7 +199,10 @@ class SystemIntegrationTester:
                     try:
                         health_results[service] = future.result()
                     except Exception as e:
-                        health_results[service] = {"status": "unhealthy", "error": str(e)}
+                        health_results[service] = {
+                            "status": "unhealthy",
+                            "error": str(e),
+                        }
 
             # 檢查是否所有核心服務都健康
             healthy_services = [
@@ -204,7 +221,11 @@ class SystemIntegrationTester:
             }
 
         except Exception as e:
-            return {"status": "FAIL", "duration_seconds": time.time() - start_time, "error": str(e)}
+            return {
+                "status": "FAIL",
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+            }
 
     async def _test_api_integration(self) -> Dict[str, Any]:
         """測試 API 整合"""
@@ -213,16 +234,32 @@ class SystemIntegrationTester:
 
         try:
             test_cases = [
-                {"method": "GET", "endpoint": "/health", "expected_status": 200},
-                {"method": "GET", "endpoint": "/api/v1/status", "expected_status": 200},
+                {
+                    "method": "GET",
+                    "endpoint": "/health",
+                    "expected_status": 200,
+                },
+                {
+                    "method": "GET",
+                    "endpoint": "/api/v1/status",
+                    "expected_status": 200,
+                },
                 {
                     "method": "POST",
                     "endpoint": "/api/v1/auth/login",
                     "data": {"username": "test", "password": "test"},
                     "expected_status": [200, 401],
                 },
-                {"method": "GET", "endpoint": "/api/v1/videos", "expected_status": [200, 401]},
-                {"method": "GET", "endpoint": "/api/v1/ai/models", "expected_status": [200, 401]},
+                {
+                    "method": "GET",
+                    "endpoint": "/api/v1/videos",
+                    "expected_status": [200, 401],
+                },
+                {
+                    "method": "GET",
+                    "endpoint": "/api/v1/ai/models",
+                    "expected_status": [200, 401],
+                },
             ]
 
             results = []
@@ -231,7 +268,9 @@ class SystemIntegrationTester:
                 results.append(result)
 
             passed_tests = [r for r in results if r["status"] == "PASS"]
-            overall_pass = len(passed_tests) >= len(test_cases) * 0.8  # 80% 通過率
+            overall_pass = (
+                len(passed_tests) >= len(test_cases) * 0.8
+            )  # 80% 通過率
 
             return {
                 "status": "PASS" if overall_pass else "FAIL",
@@ -243,7 +282,11 @@ class SystemIntegrationTester:
             }
 
         except Exception as e:
-            return {"status": "FAIL", "duration_seconds": time.time() - start_time, "error": str(e)}
+            return {
+                "status": "FAIL",
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+            }
 
     async def _test_authentication_flow(self) -> Dict[str, Any]:
         """測試認證流程"""
@@ -281,7 +324,11 @@ class SystemIntegrationTester:
             }
 
         except Exception as e:
-            return {"status": "FAIL", "duration_seconds": time.time() - start_time, "error": str(e)}
+            return {
+                "status": "FAIL",
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+            }
 
     async def _test_cache_system(self) -> Dict[str, Any]:
         """測試快取系統"""
@@ -319,7 +366,11 @@ class SystemIntegrationTester:
             }
 
         except Exception as e:
-            return {"status": "FAIL", "duration_seconds": time.time() - start_time, "error": str(e)}
+            return {
+                "status": "FAIL",
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+            }
 
     async def _test_backup_recovery(self) -> Dict[str, Any]:
         """測試備份恢復系統"""
@@ -352,7 +403,11 @@ class SystemIntegrationTester:
             }
 
         except Exception as e:
-            return {"status": "FAIL", "duration_seconds": time.time() - start_time, "error": str(e)}
+            return {
+                "status": "FAIL",
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+            }
 
     async def _test_compliance_framework(self) -> Dict[str, Any]:
         """測試合規性框架"""
@@ -370,7 +425,10 @@ class SystemIntegrationTester:
             retention_policy_result = await self._test_retention_policies()
 
             all_compliance_tests_passed = all(
-                [gdpr_result.get("status") == "PASS", audit_logging_result.get("status") == "PASS"]
+                [
+                    gdpr_result.get("status") == "PASS",
+                    audit_logging_result.get("status") == "PASS",
+                ]
             )
 
             return {
@@ -382,7 +440,11 @@ class SystemIntegrationTester:
             }
 
         except Exception as e:
-            return {"status": "FAIL", "duration_seconds": time.time() - start_time, "error": str(e)}
+            return {
+                "status": "FAIL",
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+            }
 
     async def _test_load_performance(self) -> Dict[str, Any]:
         """測試負載性能"""
@@ -395,13 +457,17 @@ class SystemIntegrationTester:
             duration = load_config.get("duration_seconds", 30)
 
             # 執行負載測試
-            performance_metrics = await self._execute_load_test(concurrent_users, duration)
+            performance_metrics = await self._execute_load_test(
+                concurrent_users, duration
+            )
 
             # 評估性能指標
             performance_acceptable = (
                 performance_metrics.get("avg_response_time_ms", 9999) < 500
-                and performance_metrics.get("error_rate", 1.0) < 0.05  # <5% 錯誤率
-                and performance_metrics.get("throughput_rps", 0) > 100  # >100 RPS
+                and performance_metrics.get("error_rate", 1.0)
+                < 0.05  # <5% 錯誤率
+                and performance_metrics.get("throughput_rps", 0)
+                > 100  # >100 RPS
             )
 
             return {
@@ -412,7 +478,11 @@ class SystemIntegrationTester:
             }
 
         except Exception as e:
-            return {"status": "FAIL", "duration_seconds": time.time() - start_time, "error": str(e)}
+            return {
+                "status": "FAIL",
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+            }
 
     async def _test_disaster_recovery(self) -> Dict[str, Any]:
         """測試災難恢復"""
@@ -427,7 +497,9 @@ class SystemIntegrationTester:
             auto_recovery_result = await self._test_auto_recovery()
 
             # 測試數據一致性
-            data_consistency_result = await self._test_data_consistency_after_recovery()
+            data_consistency_result = (
+                await self._test_data_consistency_after_recovery()
+            )
 
             dr_tests_passed = all(
                 [
@@ -445,7 +517,11 @@ class SystemIntegrationTester:
             }
 
         except Exception as e:
-            return {"status": "FAIL", "duration_seconds": time.time() - start_time, "error": str(e)}
+            return {
+                "status": "FAIL",
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+            }
 
     async def _test_end_to_end_workflows(self) -> Dict[str, Any]:
         """測試端到端工作流程"""
@@ -454,7 +530,9 @@ class SystemIntegrationTester:
 
         try:
             # 測試影片生成完整流程
-            video_generation_result = await self._test_video_generation_workflow()
+            video_generation_result = (
+                await self._test_video_generation_workflow()
+            )
 
             # 測試用戶註冊到使用的完整流程
             user_journey_result = await self._test_complete_user_journey()
@@ -478,7 +556,11 @@ class SystemIntegrationTester:
             }
 
         except Exception as e:
-            return {"status": "FAIL", "duration_seconds": time.time() - start_time, "error": str(e)}
+            return {
+                "status": "FAIL",
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+            }
 
     # 輔助方法實現
     async def _check_database_connections(self) -> Dict[str, bool]:
@@ -536,7 +618,9 @@ class SystemIntegrationTester:
         except Exception as e:
             return {"status": "unhealthy", "error": str(e)}
 
-    async def _execute_api_test(self, test_case: Dict[str, Any]) -> Dict[str, Any]:
+    async def _execute_api_test(
+        self, test_case: Dict[str, Any]
+    ) -> Dict[str, Any]:
         """執行 API 測試"""
         start_time = time.time()
         try:
@@ -546,9 +630,14 @@ class SystemIntegrationTester:
             if method == "GET":
                 response = requests.get(url, timeout=self.test_timeout)
             elif method == "POST":
-                response = requests.post(url, json=test_case.get("data"), timeout=self.test_timeout)
+                response = requests.post(
+                    url, json=test_case.get("data"), timeout=self.test_timeout
+                )
             else:
-                return {"status": "SKIP", "reason": f"不支持的 HTTP 方法: {method}"}
+                return {
+                    "status": "SKIP",
+                    "reason": f"不支持的 HTTP 方法: {method}",
+                }
 
             expected_status = test_case["expected_status"]
             if isinstance(expected_status, list):
@@ -565,9 +654,15 @@ class SystemIntegrationTester:
             }
 
         except Exception as e:
-            return {"status": "FAIL", "duration_seconds": time.time() - start_time, "error": str(e)}
+            return {
+                "status": "FAIL",
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+            }
 
-    def _generate_test_summary(self, test_results: Dict[str, Any]) -> Dict[str, Any]:
+    def _generate_test_summary(
+        self, test_results: Dict[str, Any]
+    ) -> Dict[str, Any]:
         """生成測試摘要"""
         total_tests = 0
         passed_tests = 0
@@ -650,7 +745,9 @@ class SystemIntegrationTester:
     async def _test_retention_policies(self) -> Dict[str, Any]:
         return {"status": "PASS", "message": "保留政策測試通過"}
 
-    async def _execute_load_test(self, concurrent_users: int, duration: int) -> Dict[str, Any]:
+    async def _execute_load_test(
+        self, concurrent_users: int, duration: int
+    ) -> Dict[str, Any]:
         return {
             "avg_response_time_ms": 150,
             "error_rate": 0.02,
@@ -685,9 +782,13 @@ async def main():
 
     parser = argparse.ArgumentParser(description="系統整合測試")
     parser.add_argument(
-        "--config", default="config/integration-test-config.json", help="配置檔案路徑"
+        "--config",
+        default="config/integration-test-config.json",
+        help="配置檔案路徑",
+    )
+    parser.add_argument(
+        "--output", default="test-results.json", help="結果輸出檔案"
     )
-    parser.add_argument("--output", default="test-results.json", help="結果輸出檔案")
     parser.add_argument("--verbose", action="store_true", help="詳細輸出")
 
     args = parser.parse_args()
@@ -695,7 +796,8 @@ async def main():
     # 設置日誌
     log_level = logging.DEBUG if args.verbose else logging.INFO
     logging.basicConfig(
-        level=log_level, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
+        level=log_level,
+        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
     )
 
     # 執行測試
@@ -708,9 +810,9 @@ async def main():
 
     # 輸出摘要
     summary = results.get("summary", {})
-    print(f"\n{'='*50}")
+    print(f"\n{'=' * 50}")
     print("🔍 系統整合測試結果摘要")
-    print(f"{'='*50}")
+    print(f"{'=' * 50}")
     print(f"總測試數: {summary.get('total_tests', 0)}")
     print(f"通過測試: {summary.get('passed_tests', 0)}")
     print(f"失敗測試: {summary.get('failed_tests', 0)}")
@@ -718,7 +820,7 @@ async def main():
     print(f"品質等級: {summary.get('quality_grade', 'Unknown')}")
     print(f"整體狀態: {results.get('overall_status', 'Unknown')}")
     print(f"總持續時間: {results.get('total_duration_seconds', 0):.2f} 秒")
-    print(f"{'='*50}")
+    print(f"{'=' * 50}")
 
     if results.get("overall_status") == "PASS":
         print("✅ 所有整合測試通過！系統已準備好進行生產部署。")
diff --git a/auto_generate_video_fold6/scripts/mock_services_e2e.py b/auto_generate_video_fold6/scripts/mock_services_e2e.py
index a38c08d..060ce46 100644
--- a/auto_generate_video_fold6/scripts/mock_services_e2e.py
+++ b/auto_generate_video_fold6/scripts/mock_services_e2e.py
@@ -25,7 +25,7 @@ MOCK_DATA = {
             "user_id": "e2e_test_user",
             "email": "e2e@test.com",
             "username": "e2e_tester",
-            "created_at": datetime.utcnow().isoformat()
+            "created_at": datetime.utcnow().isoformat(),
         }
     },
     "trends": [
@@ -36,7 +36,7 @@ MOCK_DATA = {
             "engagement_score": 0.855,
             "view_count": 1250000,
             "hashtags": ["#AI", "#technology", "#innovation"],
-            "created_at": datetime.utcnow().isoformat()
+            "created_at": datetime.utcnow().isoformat(),
         },
         {
             "id": 2,
@@ -45,7 +45,7 @@ MOCK_DATA = {
             "engagement_score": 0.782,
             "view_count": 890000,
             "hashtags": ["#ML", "#tutorial", "#coding"],
-            "created_at": datetime.utcnow().isoformat()
+            "created_at": datetime.utcnow().isoformat(),
         },
         {
             "id": 3,
@@ -54,27 +54,30 @@ MOCK_DATA = {
             "engagement_score": 0.921,
             "view_count": 2100000,
             "hashtags": ["#automation", "#business", "#tools"],
-            "created_at": datetime.utcnow().isoformat()
-        }
+            "created_at": datetime.utcnow().isoformat(),
+        },
     ],
     "workflows": {},
     "scheduled_tasks": {},
-    "publish_records": {}
+    "publish_records": {},
 }
 
+
 class MockTrendService:
     """趨勢服務模擬"""
-    
+
     async def handle_health(self, request):
-        return web.json_response({"status": "healthy", "service": "trend-service"})
-    
+        return web.json_response(
+            {"status": "healthy", "service": "trend-service"}
+        )
+
     async def handle_fetch_trends(self, request):
         data = await request.json()
         categories = data.get("categories", [])
         platforms = data.get("platforms", [])
         hours_back = data.get("hours_back", 24)
         min_engagement = data.get("min_engagement", 1000)
-        
+
         # 根據參數篩選趨勢
         filtered_trends = []
         for trend in MOCK_DATA["trends"]:
@@ -83,45 +86,46 @@ class MockTrendService:
             if trend["view_count"] < min_engagement:
                 continue
             filtered_trends.append(trend)
-        
+
         # 模擬處理延遲
         await asyncio.sleep(0.5)
-        
-        return web.json_response({
-            "trends": filtered_trends,
-            "total_count": len(filtered_trends),
-            "categories_analyzed": categories or ["technology", "ai"],
-            "processing_time": 0.5
-        })
+
+        return web.json_response(
+            {
+                "trends": filtered_trends,
+                "total_count": len(filtered_trends),
+                "categories_analyzed": categories or ["technology", "ai"],
+                "processing_time": 0.5,
+            }
+        )
+
 
 class MockVideoService:
     """影片服務模擬"""
-    
+
     async def handle_health(self, request):
-        return web.json_response({"status": "healthy", "service": "video-service"})
-    
+        return web.json_response(
+            {"status": "healthy", "service": "video-service"}
+        )
+
     async def handle_create_workflow(self, request):
         data = await request.json()
         user_id = data.get("user_id")
         trend_keywords = data.get("trend_keywords", [])
         video_count = data.get("video_count", 1)
-        
+
         logger.info(f"收到工作流程創建請求: {data}")
-        
+
         if not user_id:
-            return web.json_response(
-                {"error": "Missing user_id"}, 
-                status=400
-            )
-        
+            return web.json_response({"error": "Missing user_id"}, status=400)
+
         if video_count <= 0:
             return web.json_response(
-                {"error": "Invalid video_count"}, 
-                status=400
+                {"error": "Invalid video_count"}, status=400
             )
-        
+
         # trend_keywords 可以為空，系統會自動抓取
-        
+
         workflow_id = str(uuid.uuid4())
         workflow_data = {
             "workflow_id": workflow_id,
@@ -132,102 +136,107 @@ class MockVideoService:
             "completed_steps": 0,
             "step_results": {},
             "videos_generated": 0,
-            "created_at": datetime.utcnow().isoformat()
+            "created_at": datetime.utcnow().isoformat(),
         }
-        
+
         MOCK_DATA["workflows"][workflow_id] = workflow_data
-        
+
         # 啟動模擬工作流程
         asyncio.create_task(self._simulate_workflow(workflow_id, video_count))
-        
-        return web.json_response({
-            "workflow_id": workflow_id,
-            "status": "started",
-            "estimated_duration": 60,
-            "message": "影片工作流程已啟動"
-        })
-    
+
+        return web.json_response(
+            {
+                "workflow_id": workflow_id,
+                "status": "started",
+                "estimated_duration": 60,
+                "message": "影片工作流程已啟動",
+            }
+        )
+
     async def handle_workflow_status(self, request):
-        workflow_id = request.match_info['workflow_id']
-        
+        workflow_id = request.match_info["workflow_id"]
+
         if workflow_id not in MOCK_DATA["workflows"]:
             return web.json_response(
-                {"error": "Workflow not found"}, 
-                status=404
+                {"error": "Workflow not found"}, status=404
             )
-        
+
         workflow = MOCK_DATA["workflows"][workflow_id]
         return web.json_response(workflow)
-    
+
     async def _simulate_workflow(self, workflow_id: str, video_count: int):
         """模擬工作流程執行"""
         workflow = MOCK_DATA["workflows"][workflow_id]
         steps = [
             "trend_analysis",
-            "keyword_extraction", 
+            "keyword_extraction",
             "script_generation",
             "image_generation",
             "voice_synthesis",
             "video_composition",
-            "quality_check"
+            "quality_check",
         ]
-        
+
         try:
             for i, step in enumerate(steps, 1):
                 # 模擬每步驟處理時間
                 await asyncio.sleep(2)
-                
+
                 workflow["current_step"] = step
                 workflow["completed_steps"] = i
                 workflow["step_results"][step] = {
                     "success": True,
                     "duration": 2.0,
-                    "details": f"Mock {step} completed successfully"
+                    "details": f"Mock {step} completed successfully",
                 }
                 workflow["updated_at"] = datetime.utcnow().isoformat()
-                
+
                 logger.info(f"工作流程 {workflow_id} 完成步驟: {step}")
-            
+
             # 工作流程完成
             workflow["status"] = "completed"
             workflow["videos_generated"] = video_count
             workflow["generated_videos"] = [
                 {
                     "video_id": f"video_{uuid.uuid4()}",
-                    "title": f"AI 趨勢分析影片 {i+1}",
+                    "title": f"AI 趨勢分析影片 {i + 1}",
                     "description": "基於最新趨勢數據生成的影片",
                     "duration": 30,
                     "quality": "1080p",
-                    "tags": ["AI", "technology", "trends"]
+                    "tags": ["AI", "technology", "trends"],
                 }
                 for i in range(video_count)
             ]
-            
-            logger.info(f"工作流程 {workflow_id} 完成，生成 {video_count} 個影片")
-            
+
+            logger.info(
+                f"工作流程 {workflow_id} 完成，生成 {video_count} 個影片"
+            )
+
         except Exception as e:
             workflow["status"] = "failed"
             workflow["error"] = str(e)
             logger.error(f"工作流程 {workflow_id} 失敗: {e}")
 
+
 class MockSocialService:
     """社群服務模擬"""
-    
+
     async def handle_health(self, request):
-        return web.json_response({"status": "healthy", "service": "social-service"})
-    
+        return web.json_response(
+            {"status": "healthy", "service": "social-service"}
+        )
+
     async def handle_publish(self, request):
         data = await request.json()
         user_id = data.get("user_id")
         video_id = data.get("video_id")
         platforms = data.get("platforms", [])
-        
+
         if not all([user_id, video_id, platforms]):
             return web.json_response(
-                {"error": "Missing required parameters"}, 
-                status=400
+                {"error": "Missing required parameters"}, status=400
             )
-        
+
         publish_id = str(uuid.uuid4())
         publish_data = {
             "publish_id": publish_id,
@@ -237,176 +246,214 @@ class MockSocialService:
             "status": "in_progress",
             "platform_results": {},
             "all_completed": False,
-            "created_at": datetime.utcnow().isoformat()
+            "created_at": datetime.utcnow().isoformat(),
         }
-        
+
         MOCK_DATA["publish_records"][publish_id] = publish_data
-        
+
         # 啟動模擬發布流程
         asyncio.create_task(self._simulate_publishing(publish_id, platforms))
-        
-        return web.json_response({
-            "publish_id": publish_id,
-            "status": "started",
-            "message": "發布流程已啟動"
-        })
-    
+
+        return web.json_response(
+            {
+                "publish_id": publish_id,
+                "status": "started",
+                "message": "發布流程已啟動",
+            }
+        )
+
     async def handle_publish_status(self, request):
-        publish_id = request.match_info['publish_id']
-        
+        publish_id = request.match_info["publish_id"]
+
         if publish_id not in MOCK_DATA["publish_records"]:
             return web.json_response(
-                {"error": "Publish record not found"}, 
-                status=404
+                {"error": "Publish record not found"}, status=404
             )
-        
+
         publish_record = MOCK_DATA["publish_records"][publish_id]
         return web.json_response(publish_record)
-    
-    async def _simulate_publishing(self, publish_id: str, platforms: List[str]):
+
+    async def _simulate_publishing(
+        self, publish_id: str, platforms: List[str]
+    ):
         """模擬發布流程"""
         publish_record = MOCK_DATA["publish_records"][publish_id]
-        
+
         try:
             for platform in platforms:
                 # 模擬發布延遲
                 await asyncio.sleep(3)
-                
+
                 # 模擬成功發布
                 publish_record["platform_results"][platform] = {
                     "status": "success",
                     "platform_post_id": f"{platform}_{uuid.uuid4()}",
                     "published_at": datetime.utcnow().isoformat(),
-                    "url": f"https://{platform}.com/post/{uuid.uuid4()}"
+                    "url": f"https://{platform}.com/post/{uuid.uuid4()}",
                 }
-                
+
                 logger.info(f"發布 {publish_id} 到 {platform} 成功")
-            
+
             publish_record["status"] = "completed"
             publish_record["all_completed"] = True
-            
+
         except Exception as e:
             publish_record["status"] = "failed"
             publish_record["error"] = str(e)
             logger.error(f"發布 {publish_id} 失敗: {e}")
 
+
 class MockSchedulerService:
     """排程服務模擬"""
-    
+
     def __init__(self):
         self.is_running = False
         self.config = {}
-    
+
     async def handle_health(self, request):
-        return web.json_response({
-            "status": "healthy", 
-            "service": "scheduler-service",
-            "is_running": self.is_running
-        })
-    
+        return web.json_response(
+            {
+                "status": "healthy",
+                "service": "scheduler-service",
+                "is_running": self.is_running,
+            }
+        )
+
     async def handle_configure(self, request):
         self.config = await request.json()
-        return web.json_response({
-            "message": "排程器配置已更新",
-            "config": self.config,
-            "status": "configured"
-        })
-    
+        return web.json_response(
+            {
+                "message": "排程器配置已更新",
+                "config": self.config,
+                "status": "configured",
+            }
+        )
+
     async def handle_start(self, request):
         self.is_running = True
-        return web.json_response({
-            "message": "排程器已啟動",
-            "status": "running",
-            "started_at": datetime.utcnow().isoformat()
-        })
-    
+        return web.json_response(
+            {
+                "message": "排程器已啟動",
+                "status": "running",
+                "started_at": datetime.utcnow().isoformat(),
+            }
+        )
+
     async def handle_stop(self, request):
         self.is_running = False
-        return web.json_response({
-            "message": "排程器已停止",
-            "status": "stopped",
-            "stopped_at": datetime.utcnow().isoformat()
-        })
-    
+        return web.json_response(
+            {
+                "message": "排程器已停止",
+                "status": "stopped",
+                "stopped_at": datetime.utcnow().isoformat(),
+            }
+        )
+
     async def handle_status(self, request):
-        return web.json_response({
-            "is_running": self.is_running,
-            "daily_stats": {
-                "videos_generated": 0,
-                "budget_used": 0.0,
-                "tasks_completed": 0,
-                "tasks_failed": 0
-            },
-            "active_tasks_count": 0,
-            "scheduled_tasks_count": len(MOCK_DATA["scheduled_tasks"]),
-            "config": self.config
-        })
+        return web.json_response(
+            {
+                "is_running": self.is_running,
+                "daily_stats": {
+                    "videos_generated": 0,
+                    "budget_used": 0.0,
+                    "tasks_completed": 0,
+                    "tasks_failed": 0,
+                },
+                "active_tasks_count": 0,
+                "scheduled_tasks_count": len(MOCK_DATA["scheduled_tasks"]),
+                "config": self.config,
+            }
+        )
+
 
 async def create_mock_services():
     """創建所有模擬服務"""
-    
+
     # 趨勢服務 (端口 8001)
     trend_service = MockTrendService()
     trend_app = web.Application()
-    trend_app.router.add_get('/health', trend_service.handle_health)
-    trend_app.router.add_post('/api/v1/entrepreneur/fetch-trends', trend_service.handle_fetch_trends)
-    
+    trend_app.router.add_get("/health", trend_service.handle_health)
+    trend_app.router.add_post(
+        "/api/v1/entrepreneur/fetch-trends", trend_service.handle_fetch_trends
+    )
+
     # 影片服務 (端口 8003)
     video_service = MockVideoService()
     video_app = web.Application()
-    video_app.router.add_get('/health', video_service.handle_health)
-    video_app.router.add_post('/api/v1/entrepreneur/create', video_service.handle_create_workflow)
-    video_app.router.add_get('/api/v1/entrepreneur/status/{workflow_id}', video_service.handle_workflow_status)
-    
+    video_app.router.add_get("/health", video_service.handle_health)
+    video_app.router.add_post(
+        "/api/v1/entrepreneur/create", video_service.handle_create_workflow
+    )
+    video_app.router.add_get(
+        "/api/v1/entrepreneur/status/{workflow_id}",
+        video_service.handle_workflow_status,
+    )
+
     # 社群服務 (端口 8004)
     social_service = MockSocialService()
     social_app = web.Application()
-    social_app.router.add_get('/health', social_service.handle_health)
-    social_app.router.add_post('/api/v1/entrepreneur/publish', social_service.handle_publish)
-    social_app.router.add_get('/api/v1/entrepreneur/publish-status/{publish_id}', social_service.handle_publish_status)
-    
+    social_app.router.add_get("/health", social_service.handle_health)
+    social_app.router.add_post(
+        "/api/v1/entrepreneur/publish", social_service.handle_publish
+    )
+    social_app.router.add_get(
+        "/api/v1/entrepreneur/publish-status/{publish_id}",
+        social_service.handle_publish_status,
+    )
+
     # 排程服務 (端口 8008)
     scheduler_service = MockSchedulerService()
     scheduler_app = web.Application()
-    scheduler_app.router.add_get('/health', scheduler_service.handle_health)
-    scheduler_app.router.add_post('/api/v1/entrepreneur-scheduler/configure', scheduler_service.handle_configure)
-    scheduler_app.router.add_post('/api/v1/entrepreneur-scheduler/start', scheduler_service.handle_start)
-    scheduler_app.router.add_post('/api/v1/entrepreneur-scheduler/stop', scheduler_service.handle_stop)
-    scheduler_app.router.add_get('/api/v1/entrepreneur-scheduler/status', scheduler_service.handle_status)
-    
+    scheduler_app.router.add_get("/health", scheduler_service.handle_health)
+    scheduler_app.router.add_post(
+        "/api/v1/entrepreneur-scheduler/configure",
+        scheduler_service.handle_configure,
+    )
+    scheduler_app.router.add_post(
+        "/api/v1/entrepreneur-scheduler/start", scheduler_service.handle_start
+    )
+    scheduler_app.router.add_post(
+        "/api/v1/entrepreneur-scheduler/stop", scheduler_service.handle_stop
+    )
+    scheduler_app.router.add_get(
+        "/api/v1/entrepreneur-scheduler/status",
+        scheduler_service.handle_status,
+    )
+
     # 啟動所有服務
     runners = []
-    
+
     services = [
         (trend_app, 8001, "Trend Service"),
         (video_app, 8003, "Video Service"),
         (social_app, 8004, "Social Service"),
-        (scheduler_app, 8008, "Scheduler Service")
+        (scheduler_app, 8008, "Scheduler Service"),
     ]
-    
+
     for app, port, name in services:
         runner = web.AppRunner(app)
         await runner.setup()
-        site = web.TCPSite(runner, 'localhost', port)
+        site = web.TCPSite(runner, "localhost", port)
         await site.start()
         runners.append(runner)
         logger.info(f"🚀 {name} 啟動在端口 {port}")
-    
+
     return runners
 
+
 async def main():
     """啟動所有模擬服務"""
     logger.info("🎭 啟動 E2E 測試模擬服務...")
-    
+
     runners = await create_mock_services()
-    
+
     logger.info("✅ 所有模擬服務已啟動")
     logger.info("📋 服務列表:")
     logger.info("  - Trend Service: http://localhost:8001")
     logger.info("  - Video Service: http://localhost:8003")
     logger.info("  - Social Service: http://localhost:8004")
     logger.info("  - Scheduler Service: http://localhost:8008")
-    
+
     try:
         # 保持服務運行
         while True:
@@ -417,23 +464,25 @@ async def main():
         for runner in runners:
             await runner.cleanup()
 
+
 def run_mock_services():
     """在背景執行緒中運行模擬服務"""
     asyncio.run(main())
 
+
 if __name__ == "__main__":
     # 在背景啟動模擬服務
     service_thread = threading.Thread(target=run_mock_services, daemon=True)
     service_thread.start()
-    
+
     # 給服務時間啟動
     time.sleep(3)
-    
+
     logger.info("🧪 模擬服務已準備就緒，可以運行 E2E 測試")
-    
+
     # 保持主程序運行
     try:
         while True:
             time.sleep(1)
     except KeyboardInterrupt:
-        logger.info("🏁 退出模擬服務")
\ No newline at end of file
+        logger.info("🏁 退出模擬服務")
diff --git a/auto_generate_video_fold6/scripts/performance_benchmark.py b/auto_generate_video_fold6/scripts/performance_benchmark.py
index 6c36367..5037053 100644
--- a/auto_generate_video_fold6/scripts/performance_benchmark.py
+++ b/auto_generate_video_fold6/scripts/performance_benchmark.py
@@ -86,7 +86,12 @@ class PerformanceBenchmark:
                 "acceptable": 500,
                 "poor": 1000,
             },
-            "throughput_rps": {"excellent": 1000, "good": 500, "acceptable": 200, "poor": 100},
+            "throughput_rps": {
+                "excellent": 1000,
+                "good": 500,
+                "acceptable": 200,
+                "poor": 100,
+            },
             "error_rate": {
                 "excellent": 0.001,  # 0.1%
                 "good": 0.01,  # 1%
@@ -99,7 +104,12 @@ class PerformanceBenchmark:
                 "acceptable": 0.7,  # 70%
                 "poor": 0.9,  # 90%
             },
-            "memory_usage_mb": {"excellent": 512, "good": 1024, "acceptable": 2048, "poor": 4096},
+            "memory_usage_mb": {
+                "excellent": 512,
+                "good": 1024,
+                "acceptable": 2048,
+                "poor": 4096,
+            },
         }
 
     def _load_config(self, config_file: str) -> Dict[str, Any]:
@@ -157,7 +167,9 @@ class PerformanceBenchmark:
                 "total_duration_seconds": time.time() - start_time,
                 "overall_grade": overall_grade,
                 "recommendations": recommendations,
-                "industry_comparison": self._generate_industry_comparison(benchmark_results),
+                "industry_comparison": self._generate_industry_comparison(
+                    benchmark_results
+                ),
             }
         )
 
@@ -177,14 +189,22 @@ class PerformanceBenchmark:
             results = {}
 
             for endpoint in endpoints:
-                endpoint_results = await self._test_endpoint_performance(endpoint)
+                endpoint_results = await self._test_endpoint_performance(
+                    endpoint
+                )
                 results[endpoint] = endpoint_results
 
             # 計算平均性能指標
-            avg_response_time = np.mean([r["avg_response_time_ms"] for r in results.values()])
-            avg_throughput = np.mean([r["throughput_rps"] for r in results.values()])
+            avg_response_time = np.mean(
+                [r["avg_response_time_ms"] for r in results.values()]
+            )
+            avg_throughput = np.mean(
+                [r["throughput_rps"] for r in results.values()]
+            )
 
-            grade = self._grade_metric("api_response_time_ms", avg_response_time)
+            grade = self._grade_metric(
+                "api_response_time_ms", avg_response_time
+            )
 
             return {
                 "duration_seconds": time.time() - start_time,
@@ -192,11 +212,17 @@ class PerformanceBenchmark:
                 "avg_response_time_ms": avg_response_time,
                 "avg_throughput_rps": avg_throughput,
                 "grade": grade,
-                "status": "PASS" if grade in ["excellent", "good"] else "NEEDS_IMPROVEMENT",
+                "status": "PASS"
+                if grade in ["excellent", "good"]
+                else "NEEDS_IMPROVEMENT",
             }
 
         except Exception as e:
-            return {"duration_seconds": time.time() - start_time, "error": str(e), "status": "FAIL"}
+            return {
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+                "status": "FAIL",
+            }
 
     async def _benchmark_load_testing(self) -> Dict[str, Any]:
         """負載測試基準"""
@@ -223,22 +249,34 @@ class PerformanceBenchmark:
             best_throughput = max([r.throughput_rps for r in results.values()])
             avg_error_rate = np.mean([r.error_rate for r in results.values()])
 
-            throughput_grade = self._grade_metric("throughput_rps", best_throughput)
+            throughput_grade = self._grade_metric(
+                "throughput_rps", best_throughput
+            )
             error_rate_grade = self._grade_metric("error_rate", avg_error_rate)
 
-            overall_grade = self._combine_grades([throughput_grade, error_rate_grade])
+            overall_grade = self._combine_grades(
+                [throughput_grade, error_rate_grade]
+            )
 
             return {
                 "duration_seconds": time.time() - start_time,
-                "load_test_results": {k: asdict(v) for k, v in results.items()},
+                "load_test_results": {
+                    k: asdict(v) for k, v in results.items()
+                },
                 "best_throughput_rps": best_throughput,
                 "avg_error_rate": avg_error_rate,
                 "grade": overall_grade,
-                "status": "PASS" if overall_grade in ["excellent", "good"] else "NEEDS_IMPROVEMENT",
+                "status": "PASS"
+                if overall_grade in ["excellent", "good"]
+                else "NEEDS_IMPROVEMENT",
             }
 
         except Exception as e:
-            return {"duration_seconds": time.time() - start_time, "error": str(e), "status": "FAIL"}
+            return {
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+                "status": "FAIL",
+            }
 
     async def _benchmark_database_performance(self) -> Dict[str, Any]:
         """資料庫性能基準測試"""
@@ -254,10 +292,12 @@ class PerformanceBenchmark:
 
             # 組合評估
             db_grade = self._grade_metric(
-                "api_response_time_ms", pg_results.get("avg_query_time_ms", 999)
+                "api_response_time_ms",
+                pg_results.get("avg_query_time_ms", 999),
             )
             cache_grade = self._grade_metric(
-                "api_response_time_ms", redis_results.get("avg_access_time_ms", 999)
+                "api_response_time_ms",
+                redis_results.get("avg_access_time_ms", 999),
             )
 
             overall_grade = self._combine_grades([db_grade, cache_grade])
@@ -267,11 +307,17 @@ class PerformanceBenchmark:
                 "postgresql": pg_results,
                 "redis": redis_results,
                 "grade": overall_grade,
-                "status": "PASS" if overall_grade in ["excellent", "good"] else "NEEDS_IMPROVEMENT",
+                "status": "PASS"
+                if overall_grade in ["excellent", "good"]
+                else "NEEDS_IMPROVEMENT",
             }
 
         except Exception as e:
-            return {"duration_seconds": time.time() - start_time, "error": str(e), "status": "FAIL"}
+            return {
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+                "status": "FAIL",
+            }
 
     async def _benchmark_cache_performance(self) -> Dict[str, Any]:
         """快取性能基準測試"""
@@ -290,10 +336,12 @@ class PerformanceBenchmark:
 
             # 綜合評估
             read_grade = self._grade_metric(
-                "api_response_time_ms", cache_results.get("avg_read_time_ms", 999)
+                "api_response_time_ms",
+                cache_results.get("avg_read_time_ms", 999),
             )
             write_grade = self._grade_metric(
-                "api_response_time_ms", cache_results.get("avg_write_time_ms", 999)
+                "api_response_time_ms",
+                cache_results.get("avg_write_time_ms", 999),
             )
 
             overall_grade = self._combine_grades([read_grade, write_grade])
@@ -304,11 +352,17 @@ class PerformanceBenchmark:
                 "hit_ratio": hit_ratio_results,
                 "consistency": consistency_results,
                 "grade": overall_grade,
-                "status": "PASS" if overall_grade in ["excellent", "good"] else "NEEDS_IMPROVEMENT",
+                "status": "PASS"
+                if overall_grade in ["excellent", "good"]
+                else "NEEDS_IMPROVEMENT",
             }
 
         except Exception as e:
-            return {"duration_seconds": time.time() - start_time, "error": str(e), "status": "FAIL"}
+            return {
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+                "status": "FAIL",
+            }
 
     async def _benchmark_resource_utilization(self) -> Dict[str, Any]:
         """資源利用率基準測試"""
@@ -336,9 +390,13 @@ class PerformanceBenchmark:
                 memory_samples.append(memory_info.used / (1024**3))  # GB
 
                 if disk_io:
-                    disk_io_samples.append(disk_io.read_bytes + disk_io.write_bytes)
+                    disk_io_samples.append(
+                        disk_io.read_bytes + disk_io.write_bytes
+                    )
                 if network_io:
-                    network_io_samples.append(network_io.bytes_sent + network_io.bytes_recv)
+                    network_io_samples.append(
+                        network_io.bytes_sent + network_io.bytes_recv
+                    )
 
                 await asyncio.sleep(sample_interval)
 
@@ -350,7 +408,9 @@ class PerformanceBenchmark:
 
             # 評級
             cpu_grade = self._grade_metric("cpu_usage", avg_cpu / 100)
-            memory_grade = self._grade_metric("memory_usage_mb", avg_memory_gb * 1024)
+            memory_grade = self._grade_metric(
+                "memory_usage_mb", avg_memory_gb * 1024
+            )
 
             overall_grade = self._combine_grades([cpu_grade, memory_grade])
 
@@ -367,11 +427,17 @@ class PerformanceBenchmark:
                     "samples": len(memory_samples),
                 },
                 "grade": overall_grade,
-                "status": "PASS" if overall_grade in ["excellent", "good"] else "NEEDS_IMPROVEMENT",
+                "status": "PASS"
+                if overall_grade in ["excellent", "good"]
+                else "NEEDS_IMPROVEMENT",
             }
 
         except Exception as e:
-            return {"duration_seconds": time.time() - start_time, "error": str(e), "status": "FAIL"}
+            return {
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+                "status": "FAIL",
+            }
 
     async def _benchmark_concurrent_processing(self) -> Dict[str, Any]:
         """併發處理性能基準測試"""
@@ -388,10 +454,16 @@ class PerformanceBenchmark:
                 results[f"concurrency_{level}"] = level_results
 
             # 找出最佳性能點
-            best_throughput = max([r["throughput_rps"] for r in results.values()])
-            optimal_concurrency = max(results.keys(), key=lambda k: results[k]["throughput_rps"])
+            best_throughput = max(
+                [r["throughput_rps"] for r in results.values()]
+            )
+            optimal_concurrency = max(
+                results.keys(), key=lambda k: results[k]["throughput_rps"]
+            )
 
-            throughput_grade = self._grade_metric("throughput_rps", best_throughput)
+            throughput_grade = self._grade_metric(
+                "throughput_rps", best_throughput
+            )
 
             return {
                 "duration_seconds": time.time() - start_time,
@@ -400,12 +472,18 @@ class PerformanceBenchmark:
                 "optimal_concurrency": optimal_concurrency,
                 "grade": throughput_grade,
                 "status": (
-                    "PASS" if throughput_grade in ["excellent", "good"] else "NEEDS_IMPROVEMENT"
+                    "PASS"
+                    if throughput_grade in ["excellent", "good"]
+                    else "NEEDS_IMPROVEMENT"
                 ),
             }
 
         except Exception as e:
-            return {"duration_seconds": time.time() - start_time, "error": str(e), "status": "FAIL"}
+            return {
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+                "status": "FAIL",
+            }
 
     async def _benchmark_ai_services(self) -> Dict[str, Any]:
         """AI 服務性能基準測試"""
@@ -423,11 +501,15 @@ class PerformanceBenchmark:
 
             results = {}
             for service in ai_services:
-                service_results = await self._test_ai_service_performance(service)
+                service_results = await self._test_ai_service_performance(
+                    service
+                )
                 results[service] = service_results
 
             # 計算平均處理時間
-            avg_processing_time = np.mean([r["avg_processing_time_ms"] for r in results.values()])
+            avg_processing_time = np.mean(
+                [r["avg_processing_time_ms"] for r in results.values()]
+            )
 
             # AI 服務有特殊的性能標準
             ai_grade = self._grade_ai_service_performance(avg_processing_time)
@@ -437,11 +519,17 @@ class PerformanceBenchmark:
                 "ai_service_results": results,
                 "avg_processing_time_ms": avg_processing_time,
                 "grade": ai_grade,
-                "status": "PASS" if ai_grade in ["excellent", "good"] else "NEEDS_IMPROVEMENT",
+                "status": "PASS"
+                if ai_grade in ["excellent", "good"]
+                else "NEEDS_IMPROVEMENT",
             }
 
         except Exception as e:
-            return {"duration_seconds": time.time() - start_time, "error": str(e), "status": "FAIL"}
+            return {
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+                "status": "FAIL",
+            }
 
     async def _benchmark_file_io(self) -> Dict[str, Any]:
         """檔案 I/O 性能基準測試"""
@@ -458,11 +546,17 @@ class PerformanceBenchmark:
                 results[f"{size_mb}MB"] = size_results
 
             # 計算平均吞吐量
-            avg_read_throughput = np.mean([r["read_throughput_mbps"] for r in results.values()])
-            avg_write_throughput = np.mean([r["write_throughput_mbps"] for r in results.values()])
+            avg_read_throughput = np.mean(
+                [r["read_throughput_mbps"] for r in results.values()]
+            )
+            avg_write_throughput = np.mean(
+                [r["write_throughput_mbps"] for r in results.values()]
+            )
 
             # 檔案 I/O 評級
-            io_grade = self._grade_file_io_performance(avg_read_throughput, avg_write_throughput)
+            io_grade = self._grade_file_io_performance(
+                avg_read_throughput, avg_write_throughput
+            )
 
             return {
                 "duration_seconds": time.time() - start_time,
@@ -470,11 +564,17 @@ class PerformanceBenchmark:
                 "avg_read_throughput_mbps": avg_read_throughput,
                 "avg_write_throughput_mbps": avg_write_throughput,
                 "grade": io_grade,
-                "status": "PASS" if io_grade in ["excellent", "good"] else "NEEDS_IMPROVEMENT",
+                "status": "PASS"
+                if io_grade in ["excellent", "good"]
+                else "NEEDS_IMPROVEMENT",
             }
 
         except Exception as e:
-            return {"duration_seconds": time.time() - start_time, "error": str(e), "status": "FAIL"}
+            return {
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+                "status": "FAIL",
+            }
 
     async def _benchmark_network_performance(self) -> Dict[str, Any]:
         """網路性能基準測試"""
@@ -490,20 +590,30 @@ class PerformanceBenchmark:
             latency_grade = self._grade_metric(
                 "api_response_time_ms", latency_results["avg_latency_ms"]
             )
-            bandwidth_grade = self._grade_network_bandwidth(bandwidth_results["throughput_mbps"])
+            bandwidth_grade = self._grade_network_bandwidth(
+                bandwidth_results["throughput_mbps"]
+            )
 
-            overall_grade = self._combine_grades([latency_grade, bandwidth_grade])
+            overall_grade = self._combine_grades(
+                [latency_grade, bandwidth_grade]
+            )
 
             return {
                 "duration_seconds": time.time() - start_time,
                 "latency": latency_results,
                 "bandwidth": bandwidth_results,
                 "grade": overall_grade,
-                "status": "PASS" if overall_grade in ["excellent", "good"] else "NEEDS_IMPROVEMENT",
+                "status": "PASS"
+                if overall_grade in ["excellent", "good"]
+                else "NEEDS_IMPROVEMENT",
             }
 
         except Exception as e:
-            return {"duration_seconds": time.time() - start_time, "error": str(e), "status": "FAIL"}
+            return {
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+                "status": "FAIL",
+            }
 
     async def _benchmark_scalability(self) -> Dict[str, Any]:
         """可擴展性基準測試"""
@@ -528,7 +638,9 @@ class PerformanceBenchmark:
                 )
 
             # 分析可擴展性特徵
-            scalability_analysis = self._analyze_scalability_curve(scalability_data)
+            scalability_analysis = self._analyze_scalability_curve(
+                scalability_data
+            )
 
             return {
                 "duration_seconds": time.time() - start_time,
@@ -543,10 +655,16 @@ class PerformanceBenchmark:
             }
 
         except Exception as e:
-            return {"duration_seconds": time.time() - start_time, "error": str(e), "status": "FAIL"}
+            return {
+                "duration_seconds": time.time() - start_time,
+                "error": str(e),
+                "status": "FAIL",
+            }
 
     # 輔助測試方法（簡化實現）
-    async def _test_endpoint_performance(self, endpoint: str) -> Dict[str, Any]:
+    async def _test_endpoint_performance(
+        self, endpoint: str
+    ) -> Dict[str, Any]:
         """測試單個端點性能"""
         # 模擬實現
         return {
@@ -633,7 +751,9 @@ class PerformanceBenchmark:
             "error_rate": 0.005 * (level / 100),  # 隨併發增加錯誤率略增
         }
 
-    async def _test_ai_service_performance(self, service: str) -> Dict[str, Any]:
+    async def _test_ai_service_performance(
+        self, service: str
+    ) -> Dict[str, Any]:
         """測試 AI 服務性能"""
         # 不同 AI 服務有不同的基準處理時間
         base_times = {
@@ -646,7 +766,9 @@ class PerformanceBenchmark:
         base_time = base_times.get(service, 5000)
 
         return {
-            "avg_processing_time_ms": np.random.normal(base_time, base_time * 0.2),
+            "avg_processing_time_ms": np.random.normal(
+                base_time, base_time * 0.2
+            ),
             "success_rate": 0.95,
             "queue_length": np.random.randint(0, 10),
             "cost_per_request": np.random.uniform(0.01, 0.1),
@@ -659,7 +781,9 @@ class PerformanceBenchmark:
 
         return {
             "read_throughput_mbps": np.random.normal(base_throughput, 20),
-            "write_throughput_mbps": np.random.normal(base_throughput * 0.8, 15),
+            "write_throughput_mbps": np.random.normal(
+                base_throughput * 0.8, 15
+            ),
             "read_latency_ms": np.random.normal(10, 3),
             "write_latency_ms": np.random.normal(15, 5),
         }
@@ -684,7 +808,9 @@ class PerformanceBenchmark:
     async def _test_scalability_point(self, load: int) -> Dict[str, Any]:
         """測試特定負載點的性能"""
         # 模擬系統在不同負載下的性能
-        throughput_degradation = max(0, 1 - (load / 1000))  # 負載增加時吞吐量衰減
+        throughput_degradation = max(
+            0, 1 - (load / 1000)
+        )  # 負載增加時吞吐量衰減
         response_time_increase = 1 + (load / 200)  # 負載增加時響應時間增加
 
         return {
@@ -787,7 +913,9 @@ class PerformanceBenchmark:
         else:
             return "poor"
 
-    def _grade_file_io_performance(self, read_mbps: float, write_mbps: float) -> str:
+    def _grade_file_io_performance(
+        self, read_mbps: float, write_mbps: float
+    ) -> str:
         """檔案 I/O 性能評級"""
         avg_throughput = (read_mbps + write_mbps) / 2
 
@@ -813,7 +941,13 @@ class PerformanceBenchmark:
 
     def _combine_grades(self, grades: List[str]) -> str:
         """組合多個評級"""
-        grade_scores = {"excellent": 4, "good": 3, "acceptable": 2, "poor": 1, "unknown": 0}
+        grade_scores = {
+            "excellent": 4,
+            "good": 3,
+            "acceptable": 2,
+            "poor": 1,
+            "unknown": 0,
+        }
 
         scores = [grade_scores.get(grade, 0) for grade in grades]
         avg_score = sum(scores) / len(scores) if scores else 0
@@ -842,7 +976,10 @@ class PerformanceBenchmark:
 
         # 基於結果生成建議
         for category, result in results.items():
-            if isinstance(result, dict) and result.get("grade") in ["acceptable", "poor"]:
+            if isinstance(result, dict) and result.get("grade") in [
+                "acceptable",
+                "poor",
+            ]:
                 if category == "api_performance":
                     recommendations.append("考慮實施 API 快取和響應壓縮")
                 elif category == "load_testing":
@@ -859,7 +996,9 @@ class PerformanceBenchmark:
 
         return recommendations
 
-    def _generate_industry_comparison(self, results: Dict[str, Any]) -> Dict[str, str]:
+    def _generate_industry_comparison(
+        self, results: Dict[str, Any]
+    ) -> Dict[str, str]:
         """生成業界比較"""
         overall_grade = results.get("overall_grade", "unknown")
 
@@ -873,9 +1012,12 @@ class PerformanceBenchmark:
         return {
             "grade": overall_grade,
             "comparison": comparisons.get(overall_grade, "無法評估"),
-            "percentile": {"excellent": 95, "good": 80, "acceptable": 60, "poor": 30}.get(
-                overall_grade, 0
-            ),
+            "percentile": {
+                "excellent": 95,
+                "good": 80,
+                "acceptable": 60,
+                "poor": 30,
+            }.get(overall_grade, 0),
         }
 
     async def _generate_performance_report(self, results: Dict[str, Any]):
@@ -886,7 +1028,8 @@ class PerformanceBenchmark:
 
         # 生成 JSON 報告
         json_report_path = (
-            report_dir / f"performance_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
+            report_dir
+            / f"performance_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
         )
         with open(json_report_path, "w", encoding="utf-8") as f:
             json.dump(results, f, indent=2, ensure_ascii=False, default=str)
@@ -900,8 +1043,12 @@ async def main():
     import argparse
 
     parser = argparse.ArgumentParser(description="性能基準測試")
-    parser.add_argument("--config", default="config/benchmark-config.json", help="配置檔案路徑")
-    parser.add_argument("--output", default="benchmark-results.json", help="結果輸出檔案")
+    parser.add_argument(
+        "--config", default="config/benchmark-config.json", help="配置檔案路徑"
+    )
+    parser.add_argument(
+        "--output", default="benchmark-results.json", help="結果輸出檔案"
+    )
     parser.add_argument("--verbose", action="store_true", help="詳細輸出")
 
     args = parser.parse_args()
@@ -909,7 +1056,8 @@ async def main():
     # 設置日誌
     log_level = logging.DEBUG if args.verbose else logging.INFO
     logging.basicConfig(
-        level=log_level, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
+        level=log_level,
+        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
     )
 
     # 執行基準測試
@@ -921,9 +1069,9 @@ async def main():
         json.dump(results, f, indent=2, ensure_ascii=False, default=str)
 
     # 輸出摘要
-    print(f"\n{'='*60}")
+    print(f"\n{'=' * 60}")
     print("📊 性能基準測試結果摘要")
-    print(f"{'='*60}")
+    print(f"{'=' * 60}")
     print(f"總體評級: {results.get('overall_grade', 'Unknown')}")
     print(f"測試持續時間: {results.get('total_duration_seconds', 0):.2f} 秒")
 
@@ -935,7 +1083,7 @@ async def main():
     for i, recommendation in enumerate(results.get("recommendations", []), 1):
         print(f"{i}. {recommendation}")
 
-    print(f"{'='*60}")
+    print(f"{'=' * 60}")
     print(f"詳細報告已保存至: {args.output}")
 
     # 根據結果設置退出代碼
diff --git a/auto_generate_video_fold6/scripts/remove_branch_protection.py b/auto_generate_video_fold6/scripts/remove_branch_protection.py
index cc21428..842adf0 100755
--- a/auto_generate_video_fold6/scripts/remove_branch_protection.py
+++ b/auto_generate_video_fold6/scripts/remove_branch_protection.py
@@ -84,7 +84,10 @@ def show_current_protection():
         return
 
     url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/branches/{branch}/protection"
-    headers = {"Authorization": f"token {github_token}", "Accept": "application/vnd.github.v3+json"}
+    headers = {
+        "Authorization": f"token {github_token}",
+        "Accept": "application/vnd.github.v3+json",
+    }
 
     try:
         response = requests.get(url, headers=headers)
@@ -120,7 +123,9 @@ def main():
         print("2. Token 是否有足夠權限 (需要 repo 權限)")
         print("3. 倉庫名稱是否正確")
         print("\n💡 或者直接在 GitHub 網頁移除:")
-        print("https://github.com/ilyi1116/auto-video-generation-fold6/settings/branches")
+        print(
+            "https://github.com/ilyi1116/auto-video-generation-fold6/settings/branches"
+        )
 
 
 if __name__ == "__main__":
diff --git a/auto_generate_video_fold6/scripts/run_e2e_test.py b/auto_generate_video_fold6/scripts/run_e2e_test.py
index 48901d8..12b1c44 100644
--- a/auto_generate_video_fold6/scripts/run_e2e_test.py
+++ b/auto_generate_video_fold6/scripts/run_e2e_test.py
@@ -12,21 +12,24 @@ import sys
 import os
 from concurrent.futures import ThreadPoolExecutor
 
+
 class E2ETestRunner:
     def __init__(self):
         self.mock_process = None
-        
+
     def start_mock_services(self):
         """啟動模擬服務"""
         print("🎭 啟動模擬服務...")
-        self.mock_process = subprocess.Popen([
-            sys.executable, "mock_services_e2e.py"
-        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-        
+        self.mock_process = subprocess.Popen(
+            [sys.executable, "mock_services_e2e.py"],
+            stdout=subprocess.PIPE,
+            stderr=subprocess.PIPE,
+        )
+
         # 等待服務啟動
         time.sleep(5)
         return self.mock_process.poll() is None
-    
+
     def stop_mock_services(self):
         """停止模擬服務"""
         if self.mock_process:
@@ -37,20 +40,22 @@ class E2ETestRunner:
             except subprocess.TimeoutExpired:
                 self.mock_process.kill()
                 self.mock_process.wait()
-    
+
     def run_tests(self):
         """運行 E2E 測試"""
         print("🧪 運行 E2E 測試...")
-        test_process = subprocess.run([
-            sys.executable, "test_e2e_simple.py"
-        ], capture_output=True, text=True)
-        
+        test_process = subprocess.run(
+            [sys.executable, "test_e2e_simple.py"],
+            capture_output=True,
+            text=True,
+        )
+
         print(test_process.stdout)
         if test_process.stderr:
             print("STDERR:", test_process.stderr)
-            
+
         return test_process.returncode == 0
-    
+
     def run(self):
         """執行完整的 E2E 測試流程"""
         try:
@@ -58,14 +63,14 @@ class E2ETestRunner:
             if not self.start_mock_services():
                 print("❌ 模擬服務啟動失敗")
                 return False
-            
+
             print("✅ 模擬服務已啟動")
-            
+
             # 運行測試
             success = self.run_tests()
-            
+
             return success
-            
+
         except KeyboardInterrupt:
             print("\n⚠️ 用戶中斷測試")
             return False
@@ -76,25 +81,26 @@ class E2ETestRunner:
             # 清理資源
             self.stop_mock_services()
 
+
 def main():
     """主函數"""
     print("🚀 創業者模式 E2E 測試運行器")
     print("=" * 40)
-    
+
     runner = E2ETestRunner()
-    
+
     # 設定信號處理
     def signal_handler(signum, frame):
         print("\n🛑 收到終止信號，清理資源...")
         runner.stop_mock_services()
         sys.exit(0)
-    
+
     signal.signal(signal.SIGINT, signal_handler)
     signal.signal(signal.SIGTERM, signal_handler)
-    
+
     # 執行測試
     success = runner.run()
-    
+
     if success:
         print("\n🎉 E2E 測試完成並通過！")
         print("🎯 TDD Green 階段完成，準備進入 Refactor 階段")
@@ -104,6 +110,7 @@ def main():
         print("🔴 需要修復問題後重新運行測試")
         return 1
 
+
 if __name__ == "__main__":
     exit_code = main()
-    sys.exit(exit_code)
\ No newline at end of file
+    sys.exit(exit_code)
diff --git a/auto_generate_video_fold6/scripts/run_tests.py b/auto_generate_video_fold6/scripts/run_tests.py
index 102db8b..1b60e78 100755
--- a/auto_generate_video_fold6/scripts/run_tests.py
+++ b/auto_generate_video_fold6/scripts/run_tests.py
@@ -15,7 +15,9 @@ from typing import Dict, List, Any, Optional
 import logging
 
 # 設置日誌
-logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
+logging.basicConfig(
+    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
+)
 logger = logging.getLogger(__name__)
 
 
@@ -27,7 +29,10 @@ class TestRunner:
         self.results = {}
 
     def run_python_tests(
-        self, test_type: str = "all", coverage: bool = True, verbose: bool = True
+        self,
+        test_type: str = "all",
+        coverage: bool = True,
+        verbose: bool = True,
     ) -> Dict[str, Any]:
         """執行 Python 測試"""
         logger.info(f"執行 Python 測試: {test_type}")
@@ -46,7 +51,14 @@ class TestRunner:
 
         # 覆蓋率選項
         if coverage:
-            cmd.extend(["--cov=.", "--cov-report=html", "--cov-report=xml", "--cov-report=term"])
+            cmd.extend(
+                [
+                    "--cov=.",
+                    "--cov-report=html",
+                    "--cov-report=xml",
+                    "--cov-report=term",
+                ]
+            )
 
         # 詳細輸出
         if verbose:
@@ -62,7 +74,11 @@ class TestRunner:
         start_time = time.time()
         try:
             result = subprocess.run(
-                cmd, cwd=self.project_root, capture_output=True, text=True, timeout=300  # 5分鐘超時
+                cmd,
+                cwd=self.project_root,
+                capture_output=True,
+                text=True,
+                timeout=300,  # 5分鐘超時
             )
 
             duration = time.time() - start_time
@@ -123,7 +139,10 @@ class TestRunner:
         if not node_modules.exists():
             logger.info("安裝前端依賴...")
             npm_install = subprocess.run(
-                ["npm", "install"], cwd=frontend_dir, capture_output=True, text=True
+                ["npm", "install"],
+                cwd=frontend_dir,
+                capture_output=True,
+                text=True,
             )
             if npm_install.returncode != 0:
                 return {
@@ -223,7 +242,10 @@ class TestRunner:
 
             # Ruff 檢查
             ruff_result = subprocess.run(
-                ["ruff", "check", "."], cwd=self.project_root, capture_output=True, text=True
+                ["ruff", "check", "."],
+                cwd=self.project_root,
+                capture_output=True,
+                text=True,
             )
             python_results["ruff"] = {
                 "success": ruff_result.returncode == 0,
@@ -238,7 +260,10 @@ class TestRunner:
             frontend_dir = self.project_root / "frontend"
             if frontend_dir.exists():
                 eslint_result = subprocess.run(
-                    ["npm", "run", "lint"], cwd=frontend_dir, capture_output=True, text=True
+                    ["npm", "run", "lint"],
+                    cwd=frontend_dir,
+                    capture_output=True,
+                    text=True,
                 )
                 results["frontend"] = {
                     "eslint": {
@@ -267,7 +292,15 @@ class TestRunner:
 
         # Bandit 安全掃描
         bandit_result = subprocess.run(
-            ["bandit", "-r", ".", "-f", "json", "-o", "test-results/bandit-report.json"],
+            [
+                "bandit",
+                "-r",
+                ".",
+                "-f",
+                "json",
+                "-o",
+                "test-results/bandit-report.json",
+            ],
             cwd=self.project_root,
             capture_output=True,
             text=True,
@@ -280,7 +313,10 @@ class TestRunner:
 
         # Safety 依賴檢查
         safety_result = subprocess.run(
-            ["safety", "check", "--json"], cwd=self.project_root, capture_output=True, text=True
+            ["safety", "check", "--json"],
+            cwd=self.project_root,
+            capture_output=True,
+            text=True,
         )
         results["safety"] = {
             "success": safety_result.returncode == 0,
@@ -290,7 +326,9 @@ class TestRunner:
 
         return {
             "type": "security",
-            "success": all(result.get("success", False) for result in results.values()),
+            "success": all(
+                result.get("success", False) for result in results.values()
+            ),
             "results": results,
         }
 
@@ -311,9 +349,17 @@ class TestRunner:
             if health_result.returncode == 0:
                 try:
                     health_data = json.loads(health_result.stdout)
-                    return {"type": "health_check", "success": True, "data": health_data}
+                    return {
+                        "type": "health_check",
+                        "success": True,
+                        "data": health_data,
+                    }
                 except json.JSONDecodeError:
-                    return {"type": "health_check", "success": True, "output": health_result.stdout}
+                    return {
+                        "type": "health_check",
+                        "success": True,
+                        "output": health_result.stdout,
+                    }
             else:
                 return {
                     "type": "health_check",
@@ -325,7 +371,9 @@ class TestRunner:
         except Exception as e:
             return {"type": "health_check", "success": False, "error": str(e)}
 
-    def generate_report(self, results: List[Dict[str, Any]], format: str = "json") -> str:
+    def generate_report(
+        self, results: List[Dict[str, Any]], format: str = "json"
+    ) -> str:
         """生成測試報告"""
         logger.info(f"生成測試報告: {format}")
 
@@ -390,24 +438,24 @@ class TestRunner:
     <div class="header">
         <h1>🧪 測試報告</h1>
         <p>Auto Video Generation System - 測試執行結果</p>
-        <p>生成時間: {time.strftime('%Y-%m-%d %H:%M:%S')}</p>
+        <p>生成時間: {time.strftime("%Y-%m-%d %H:%M:%S")}</p>
     </div>
     
     <div class="summary">
         <div class="stat">
-            <div class="stat-value">{summary['total_tests']}</div>
+            <div class="stat-value">{summary["total_tests"]}</div>
             <div>總測試數</div>
         </div>
         <div class="stat">
-            <div class="stat-value success">{summary['passed']}</div>
+            <div class="stat-value success">{summary["passed"]}</div>
             <div>通過</div>
         </div>
         <div class="stat">
-            <div class="stat-value failure">{summary['failed']}</div>
+            <div class="stat-value failure">{summary["failed"]}</div>
             <div>失敗</div>
         </div>
         <div class="stat">
-            <div class="stat-value">{summary['duration']:.1f}s</div>
+            <div class="stat-value">{summary["duration"]:.1f}s</div>
             <div>總耗時</div>
         </div>
     </div>
@@ -416,16 +464,22 @@ class TestRunner:
 """
 
         for result in results:
-            status_class = "success" if result.get("success", False) else "failure"
-            badge_class = "status-success" if result.get("success", False) else "status-failure"
+            status_class = (
+                "success" if result.get("success", False) else "failure"
+            )
+            badge_class = (
+                "status-success"
+                if result.get("success", False)
+                else "status-failure"
+            )
             status_text = "通過" if result.get("success", False) else "失敗"
 
             html += f"""
     <div class="test-result">
         <div class="test-header">
             <span class="status-badge {badge_class}">{status_text}</span>
-            <strong>{result.get('type', 'Unknown')} - {result.get('test_type', 'General')}</strong>
-            <span style="float: right;">耗時: {result.get('duration', 0):.1f}s</span>
+            <strong>{result.get("type", "Unknown")} - {result.get("test_type", "General")}</strong>
+            <span style="float: right;">耗時: {result.get("duration", 0):.1f}s</span>
         </div>
         <div class="test-details">
 """
@@ -472,11 +526,18 @@ def main():
         default="all",
         help="前端測試類型",
     )
-    parser.add_argument("--no-coverage", action="store_true", help="跳過覆蓋率收集")
     parser.add_argument(
-        "--report-format", choices=["json", "html"], default="json", help="報告格式"
+        "--no-coverage", action="store_true", help="跳過覆蓋率收集"
+    )
+    parser.add_argument(
+        "--report-format",
+        choices=["json", "html"],
+        default="json",
+        help="報告格式",
+    )
+    parser.add_argument(
+        "--verbose", "-v", action="store_true", help="詳細輸出"
     )
-    parser.add_argument("--verbose", "-v", action="store_true", help="詳細輸出")
 
     args = parser.parse_args()
 
@@ -487,13 +548,17 @@ def main():
         if args.type in ["all", "python"]:
             logger.info("執行 Python 測試...")
             python_result = runner.run_python_tests(
-                test_type=args.python_test_type, coverage=not args.no_coverage, verbose=args.verbose
+                test_type=args.python_test_type,
+                coverage=not args.no_coverage,
+                verbose=args.verbose,
             )
             results.append(python_result)
 
         if args.type in ["all", "frontend"]:
             logger.info("執行前端測試...")
-            frontend_result = runner.run_frontend_tests(test_type=args.frontend_test_type)
+            frontend_result = runner.run_frontend_tests(
+                test_type=args.frontend_test_type
+            )
             results.append(frontend_result)
 
         if args.type in ["all", "lint"]:
@@ -512,7 +577,9 @@ def main():
             results.append(health_result)
 
         # 生成報告
-        report_file = runner.generate_report(results, format=args.report_format)
+        report_file = runner.generate_report(
+            results, format=args.report_format
+        )
         logger.info(f"測試報告已生成: {report_file}")
 
         # 輸出摘要
@@ -525,7 +592,7 @@ def main():
         print(f"   通過: {passed_tests}")
         print(f"   失敗: {failed_tests}")
         print(
-            f"   成功率: {(passed_tests/total_tests)*100:.1f}%"
+            f"   成功率: {(passed_tests / total_tests) * 100:.1f}%"
             if total_tests > 0
             else "   成功率: N/A"
         )
diff --git a/auto_generate_video_fold6/scripts/scheduler.py b/auto_generate_video_fold6/scripts/scheduler.py
index 2095a3d..42f7c57 100644
--- a/auto_generate_video_fold6/scripts/scheduler.py
+++ b/auto_generate_video_fold6/scripts/scheduler.py
@@ -37,7 +37,10 @@ except ImportError:
 logging.basicConfig(
     level=logging.INFO,
     format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
-    handlers=[logging.FileHandler("/app/logs/scheduler.log"), logging.StreamHandler(sys.stdout)],
+    handlers=[
+        logging.FileHandler("/app/logs/scheduler.log"),
+        logging.StreamHandler(sys.stdout),
+    ],
 )
 logger = logging.getLogger(__name__)
 
@@ -77,9 +80,15 @@ class VideoScheduler:
                     "auto_generation_interval": scheduling.get(
                         "auto_generation_interval", 6
                     ),  # 小時
-                    "work_hours_only": scheduling.get("work_hours_only", False),
-                    "work_hours": scheduling.get("work_hours", {"start": "09:00", "end": "18:00"}),
-                    "max_daily_videos": get_config("generation.daily_video_limit", 10),
+                    "work_hours_only": scheduling.get(
+                        "work_hours_only", False
+                    ),
+                    "work_hours": scheduling.get(
+                        "work_hours", {"start": "09:00", "end": "18:00"}
+                    ),
+                    "max_daily_videos": get_config(
+                        "generation.daily_video_limit", 10
+                    ),
                     "batch_size": get_config("generation.batch_size", 3),
                 }
             else:
@@ -119,7 +128,10 @@ class VideoScheduler:
             # 估算批次成本
             estimated_cost = self._estimate_batch_cost()
 
-            can_proceed, message = await self.budget_controller.pre_operation_check(
+            (
+                can_proceed,
+                message,
+            ) = await self.budget_controller.pre_operation_check(
                 "scheduled_generation", estimated_cost
             )
 
@@ -174,7 +186,9 @@ class VideoScheduler:
         # 檢查間隔時間
         last_run_key = "auto_generation"
         if last_run_key in self.last_run:
-            interval_hours = self.schedule_config.get("auto_generation_interval", 6)
+            interval_hours = self.schedule_config.get(
+                "auto_generation_interval", 6
+            )
             time_since_last = datetime.now() - self.last_run[last_run_key]
 
             if time_since_last < timedelta(hours=interval_hours):
diff --git a/auto_generate_video_fold6/scripts/security_scanner.py b/auto_generate_video_fold6/scripts/security_scanner.py
index db812bd..5cd1048 100644
--- a/auto_generate_video_fold6/scripts/security_scanner.py
+++ b/auto_generate_video_fold6/scripts/security_scanner.py
@@ -147,7 +147,11 @@ class SecurityScanner:
                     "compliance_check",
                 ],
                 "target_directories": [".", "services", "scripts"],
-                "exclude_patterns": ["node_modules", "*.min.js", "__pycache__"],
+                "exclude_patterns": [
+                    "node_modules",
+                    "*.min.js",
+                    "__pycache__",
+                ],
                 "severity_threshold": "medium",
                 "compliance_frameworks": ["OWASP", "NIST", "CIS"],
                 "network_targets": ["localhost"],
@@ -167,13 +171,19 @@ class SecurityScanner:
             scan_results = {}
 
             if "static_analysis" in self.config.get("scan_types", []):
-                scan_results["static_analysis"] = await self._run_static_analysis()
+                scan_results[
+                    "static_analysis"
+                ] = await self._run_static_analysis()
 
             if "dependency_scan" in self.config.get("scan_types", []):
-                scan_results["dependency_scan"] = await self._run_dependency_scan()
+                scan_results[
+                    "dependency_scan"
+                ] = await self._run_dependency_scan()
 
             if "container_scan" in self.config.get("scan_types", []):
-                scan_results["container_scan"] = await self._run_container_scan()
+                scan_results[
+                    "container_scan"
+                ] = await self._run_container_scan()
 
             if "network_scan" in self.config.get("scan_types", []):
                 scan_results["network_scan"] = await self._run_network_scan()
@@ -182,16 +192,22 @@ class SecurityScanner:
                 scan_results["web_app_scan"] = await self._run_web_app_scan()
 
             if "compliance_check" in self.config.get("scan_types", []):
-                scan_results["compliance_check"] = await self._run_compliance_check()
+                scan_results[
+                    "compliance_check"
+                ] = await self._run_compliance_check()
 
             # API 安全測試
             scan_results["api_security"] = await self._run_api_security_scan()
 
             # 配置安全檢查
-            scan_results["config_security"] = await self._run_config_security_scan()
+            scan_results[
+                "config_security"
+            ] = await self._run_config_security_scan()
 
             # 密碼學安全檢查
-            scan_results["crypto_security"] = await self._run_crypto_security_scan()
+            scan_results[
+                "crypto_security"
+            ] = await self._run_crypto_security_scan()
 
             end_time = datetime.utcnow()
             duration = (end_time - start_time).total_seconds()
@@ -217,7 +233,9 @@ class SecurityScanner:
             # 保存報告
             await self._save_security_report(report)
 
-            logger.info(f"✅ 安全掃描完成，發現 {len(self.findings)} 個安全問題")
+            logger.info(
+                f"✅ 安全掃描完成，發現 {len(self.findings)} 個安全問題"
+            )
             return report
 
         except Exception as e:
@@ -272,8 +290,12 @@ class SecurityScanner:
                             description=issue.text,
                             severity=self._map_bandit_severity(issue.severity),
                             category=self._map_bandit_category(issue.test_id),
-                            cwe_id=self._get_cwe_for_bandit_issue(issue.test_id),
-                            owasp_category=self._get_owasp_for_bandit_issue(issue.test_id),
+                            cwe_id=self._get_cwe_for_bandit_issue(
+                                issue.test_id
+                            ),
+                            owasp_category=self._get_owasp_for_bandit_issue(
+                                issue.test_id
+                            ),
                             file_path=py_file,
                             line_number=issue.lineno,
                             code_snippet=issue.get_code(),
@@ -281,7 +303,8 @@ class SecurityScanner:
                             references=[
                                 f"https://bandit.readthedocs.io/en/latest/plugins/{issue.test_id.lower()}.html"
                             ],
-                            confidence=issue.confidence.value / 3.0,  # 轉換為 0-1 範圍
+                            confidence=issue.confidence.value
+                            / 3.0,  # 轉換為 0-1 範圍
                             scanner="bandit",
                             timestamp=datetime.utcnow(),
                         )
@@ -323,9 +346,18 @@ class SecurityScanner:
             for ruleset in rulesets:
                 try:
                     # 執行 Semgrep 掃描
-                    cmd = ["semgrep", "--config", ruleset, "--json", "--quiet", "."]
-
-                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
+                    cmd = [
+                        "semgrep",
+                        "--config",
+                        ruleset,
+                        "--json",
+                        "--quiet",
+                        ".",
+                    ]
+
+                    result = subprocess.run(
+                        cmd, capture_output=True, text=True, timeout=300
+                    )
 
                     if result.returncode == 0 and result.stdout:
                         semgrep_results = json.loads(result.stdout)
@@ -333,12 +365,12 @@ class SecurityScanner:
                         for finding_data in semgrep_results.get("results", []):
                             # Create unique ID from path, line, and check_id
                             path = finding_data.get("path", "")
-                            line = finding_data.get("start", {}).get("line", "")
+                            line = finding_data.get("start", {}).get(
+                                "line", ""
+                            )
                             check_id = finding_data.get("check_id", "")
                             id_string = f"{path}_{line}_{check_id}"
-                            finding_id = (
-                                f"semgrep_{hashlib.md5(id_string.encode()).hexdigest()[:8]}"
-                            )
+                            finding_id = f"semgrep_{hashlib.md5(id_string.encode()).hexdigest()[:8]}"
 
                             finding = SecurityFinding(
                                 finding_id=finding_id,
@@ -350,11 +382,19 @@ class SecurityScanner:
                                 category=self._map_semgrep_category(
                                     finding_data.get("check_id", "")
                                 ),
-                                cwe_id=self._extract_cwe_from_semgrep(finding_data),
-                                owasp_category=self._extract_owasp_from_semgrep(finding_data),
+                                cwe_id=self._extract_cwe_from_semgrep(
+                                    finding_data
+                                ),
+                                owasp_category=self._extract_owasp_from_semgrep(
+                                    finding_data
+                                ),
                                 file_path=finding_data.get("path"),
-                                line_number=finding_data.get("start", {}).get("line"),
-                                code_snippet=finding_data.get("extra", {}).get("lines", ""),
+                                line_number=finding_data.get("start", {}).get(
+                                    "line"
+                                ),
+                                code_snippet=finding_data.get("extra", {}).get(
+                                    "lines", ""
+                                ),
                                 remediation=f"修復 {finding_data.get('check_id')} 漏洞",
                                 references=[
                                     f"https://semgrep.dev/r/{finding_data.get('check_id', '')}"
@@ -375,9 +415,15 @@ class SecurityScanner:
                 "rulesets_used": rulesets,
                 "findings_count": len(findings),
                 "critical_count": len(
-                    [f for f in findings if f.severity == SeverityLevel.CRITICAL]
+                    [
+                        f
+                        for f in findings
+                        if f.severity == SeverityLevel.CRITICAL
+                    ]
+                ),
+                "high_count": len(
+                    [f for f in findings if f.severity == SeverityLevel.HIGH]
                 ),
-                "high_count": len([f for f in findings if f.severity == SeverityLevel.HIGH]),
                 "findings": [asdict(f) for f in findings],
             }
 
@@ -510,7 +556,8 @@ class SecurityScanner:
 
         for config_file in config_files:
             if any(
-                exclude in str(config_file) for exclude in self.config.get("exclude_patterns", [])
+                exclude in str(config_file)
+                for exclude in self.config.get("exclude_patterns", [])
             ):
                 continue
 
@@ -522,7 +569,9 @@ class SecurityScanner:
         return {
             "config_files_scanned": len(config_files),
             "findings_count": len(findings),
-            "insecure_settings": len([f for f in findings if "insecure" in f.title.lower()]),
+            "insecure_settings": len(
+                [f for f in findings if "insecure" in f.title.lower()]
+            ),
         }
 
     async def _run_crypto_security_scan(self) -> Dict[str, Any]:
@@ -548,7 +597,9 @@ class SecurityScanner:
         return {
             "crypto_checks": 3,
             "findings_count": len(findings),
-            "weak_crypto_count": len([f for f in findings if "weak" in f.title.lower()]),
+            "weak_crypto_count": len(
+                [f for f in findings if "weak" in f.title.lower()]
+            ),
             "deprecated_crypto_count": len(
                 [f for f in findings if "deprecated" in f.title.lower()]
             ),
@@ -563,9 +614,13 @@ class SecurityScanner:
 
         for framework in frameworks:
             if framework == "OWASP":
-                compliance_results["OWASP"] = await self._check_owasp_compliance()
+                compliance_results[
+                    "OWASP"
+                ] = await self._check_owasp_compliance()
             elif framework == "NIST":
-                compliance_results["NIST"] = await self._check_nist_compliance()
+                compliance_results[
+                    "NIST"
+                ] = await self._check_nist_compliance()
             elif framework == "CIS":
                 compliance_results["CIS"] = await self._check_cis_compliance()
 
@@ -580,10 +635,19 @@ class SecurityScanner:
         secret_patterns = [
             (r'password\s*=\s*["\'][^"\']{8,}["\']', "hardcoded_password"),
             (r'api[_-]?key\s*=\s*["\'][^"\']{16,}["\']', "hardcoded_api_key"),
-            (r'secret[_-]?key\s*=\s*["\'][^"\']{16,}["\']', "hardcoded_secret_key"),
+            (
+                r'secret[_-]?key\s*=\s*["\'][^"\']{16,}["\']',
+                "hardcoded_secret_key",
+            ),
             (r'token\s*=\s*["\'][^"\']{20,}["\']', "hardcoded_token"),
-            (r'aws[_-]?access[_-]?key[_-]?id\s*=\s*["\'][^"\']+["\']', "aws_access_key"),
-            (r'aws[_-]?secret[_-]?access[_-]?key\s*=\s*["\'][^"\']+["\']', "aws_secret_key"),
+            (
+                r'aws[_-]?access[_-]?key[_-]?id\s*=\s*["\'][^"\']+["\']',
+                "aws_access_key",
+            ),
+            (
+                r'aws[_-]?secret[_-]?access[_-]?key\s*=\s*["\'][^"\']+["\']',
+                "aws_secret_key",
+            ),
         ]
 
         # 掃描程式碼檔案
@@ -593,12 +657,15 @@ class SecurityScanner:
 
         for code_file in code_files:
             if any(
-                exclude in str(code_file) for exclude in self.config.get("exclude_patterns", [])
+                exclude in str(code_file)
+                for exclude in self.config.get("exclude_patterns", [])
             ):
                 continue
 
             try:
-                with open(code_file, "r", encoding="utf-8", errors="ignore") as f:
+                with open(
+                    code_file, "r", encoding="utf-8", errors="ignore"
+                ) as f:
                     content = f.read()
                     lines = content.split("\n")
 
@@ -652,12 +719,15 @@ class SecurityScanner:
 
         for config_file in config_files:
             if any(
-                exclude in str(config_file) for exclude in self.config.get("exclude_patterns", [])
+                exclude in str(config_file)
+                for exclude in self.config.get("exclude_patterns", [])
             ):
                 continue
 
             try:
-                with open(config_file, "r", encoding="utf-8", errors="ignore") as f:
+                with open(
+                    config_file, "r", encoding="utf-8", errors="ignore"
+                ) as f:
                     content = f.read()
                     lines = content.split("\n")
 
@@ -699,7 +769,11 @@ class SecurityScanner:
             "python": [
                 (r"eval\s*\(", "eval_usage", "使用 eval() 可能導致程式碼注入"),
                 (r"exec\s*\(", "exec_usage", "使用 exec() 可能導致程式碼注入"),
-                (r"os\.system\s*\(", "os_system_usage", "使用 os.system() 可能導致命令注入"),
+                (
+                    r"os\.system\s*\(",
+                    "os_system_usage",
+                    "使用 os.system() 可能導致命令注入",
+                ),
                 (
                     r"subprocess\.call\s*\(.*shell=True",
                     "subprocess_shell",
@@ -713,31 +787,48 @@ class SecurityScanner:
                     "function_constructor",
                     "使用 Function 構造器可能導致程式碼注入",
                 ),
-                (r"innerHTML\s*=", "innerHTML_usage", "使用 innerHTML 可能導致 XSS"),
-                (r"document\.write\s*\(", "document_write", "使用 document.write 可能導致 XSS"),
+                (
+                    r"innerHTML\s*=",
+                    "innerHTML_usage",
+                    "使用 innerHTML 可能導致 XSS",
+                ),
+                (
+                    r"document\.write\s*\(",
+                    "document_write",
+                    "使用 document.write 可能導致 XSS",
+                ),
             ],
         }
 
-        file_extensions = {".py": "python", ".js": "javascript", ".ts": "javascript"}
+        file_extensions = {
+            ".py": "python",
+            ".js": "javascript",
+            ".ts": "javascript",
+        }
 
         for ext, lang in file_extensions.items():
             code_files = list(Path(".").rglob(f"*{ext}"))
 
             for code_file in code_files:
                 if any(
-                    exclude in str(code_file) for exclude in self.config.get("exclude_patterns", [])
+                    exclude in str(code_file)
+                    for exclude in self.config.get("exclude_patterns", [])
                 ):
                     continue
 
                 try:
-                    with open(code_file, "r", encoding="utf-8", errors="ignore") as f:
+                    with open(
+                        code_file, "r", encoding="utf-8", errors="ignore"
+                    ) as f:
                         content = f.read()
                         lines = content.split("\n")
 
                         for line_num, line in enumerate(lines, 1):
-                            for pattern, func_name, description in dangerous_functions.get(
-                                lang, []
-                            ):
+                            for (
+                                pattern,
+                                func_name,
+                                description,
+                            ) in dangerous_functions.get(lang, []):
                                 if re.search(pattern, line):
                                     finding = SecurityFinding(
                                         finding_id=f"dangerous_func_{hashlib.md5(f'{code_file}_{line_num}_{func_name}'.encode()).hexdigest()[:8]}",
@@ -784,12 +875,15 @@ class SecurityScanner:
 
         for code_file in code_files:
             if any(
-                exclude in str(code_file) for exclude in self.config.get("exclude_patterns", [])
+                exclude in str(code_file)
+                for exclude in self.config.get("exclude_patterns", [])
             ):
                 continue
 
             try:
-                with open(code_file, "r", encoding="utf-8", errors="ignore") as f:
+                with open(
+                    code_file, "r", encoding="utf-8", errors="ignore"
+                ) as f:
                     content = f.read()
                     lines = content.split("\n")
 
@@ -905,7 +999,9 @@ class SecurityScanner:
         """檢查 CSRF 保護"""
         return {"csrf_vulnerabilities": 0, "forms_checked": 0}
 
-    async def _analyze_config_file(self, config_file: Path) -> List[SecurityFinding]:
+    async def _analyze_config_file(
+        self, config_file: Path
+    ) -> List[SecurityFinding]:
         """分析配置檔案"""
         # 簡化實現
         return []
@@ -998,27 +1094,51 @@ class SecurityScanner:
         else:
             return "A05"  # Security Misconfiguration
 
-    def _extract_cwe_from_semgrep(self, finding_data: Dict[str, Any]) -> Optional[str]:
+    def _extract_cwe_from_semgrep(
+        self, finding_data: Dict[str, Any]
+    ) -> Optional[str]:
         """從 Semgrep 結果中提取 CWE"""
         # 檢查 metadata 中是否有 CWE 資訊
         metadata = finding_data.get("extra", {}).get("metadata", {})
         return metadata.get("cwe")
 
-    def _extract_owasp_from_semgrep(self, finding_data: Dict[str, Any]) -> Optional[str]:
+    def _extract_owasp_from_semgrep(
+        self, finding_data: Dict[str, Any]
+    ) -> Optional[str]:
         """從 Semgrep 結果中提取 OWASP 類別"""
         metadata = finding_data.get("extra", {}).get("metadata", {})
         return metadata.get("owasp")
 
-    def _generate_security_summary(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:
+    def _generate_security_summary(
+        self, scan_results: Dict[str, Any]
+    ) -> Dict[str, Any]:
         """生成安全摘要"""
         total_findings = len(self.findings)
 
         severity_counts = {
-            "critical": len([f for f in self.findings if f.severity == SeverityLevel.CRITICAL]),
-            "high": len([f for f in self.findings if f.severity == SeverityLevel.HIGH]),
-            "medium": len([f for f in self.findings if f.severity == SeverityLevel.MEDIUM]),
-            "low": len([f for f in self.findings if f.severity == SeverityLevel.LOW]),
-            "info": len([f for f in self.findings if f.severity == SeverityLevel.INFO]),
+            "critical": len(
+                [
+                    f
+                    for f in self.findings
+                    if f.severity == SeverityLevel.CRITICAL
+                ]
+            ),
+            "high": len(
+                [f for f in self.findings if f.severity == SeverityLevel.HIGH]
+            ),
+            "medium": len(
+                [
+                    f
+                    for f in self.findings
+                    if f.severity == SeverityLevel.MEDIUM
+                ]
+            ),
+            "low": len(
+                [f for f in self.findings if f.severity == SeverityLevel.LOW]
+            ),
+            "info": len(
+                [f for f in self.findings if f.severity == SeverityLevel.INFO]
+            ),
         }
 
         category_counts = {}
@@ -1043,8 +1163,12 @@ class SecurityScanner:
     def _check_compliance_status(self) -> Dict[str, bool]:
         """檢查合規狀態"""
         # 基於發現的問題評估合規性
-        critical_issues = len([f for f in self.findings if f.severity == SeverityLevel.CRITICAL])
-        high_issues = len([f for f in self.findings if f.severity == SeverityLevel.HIGH])
+        critical_issues = len(
+            [f for f in self.findings if f.severity == SeverityLevel.CRITICAL]
+        )
+        high_issues = len(
+            [f for f in self.findings if f.severity == SeverityLevel.HIGH]
+        )
 
         return {
             "OWASP_TOP_10": critical_issues == 0 and high_issues < 5,
@@ -1067,7 +1191,9 @@ class SecurityScanner:
             SeverityLevel.INFO: 0.5,
         }
 
-        total_score = sum(weights.get(finding.severity, 0) for finding in self.findings)
+        total_score = sum(
+            weights.get(finding.severity, 0) for finding in self.findings
+        )
 
         # 正規化到 0-100 範圍
         # 假設 100 個高嚴重程度問題為最大分數
@@ -1091,7 +1217,9 @@ class SecurityScanner:
 
         # 保存 JSON 報告
         with open(report_file, "w", encoding="utf-8") as f:
-            json.dump(report_data, f, indent=2, ensure_ascii=False, default=str)
+            json.dump(
+                report_data, f, indent=2, ensure_ascii=False, default=str
+            )
 
         logger.info(f"安全報告已保存: {report_file}")
 
@@ -1102,8 +1230,12 @@ async def main():
     import argparse
 
     parser = argparse.ArgumentParser(description="安全漏洞掃描")
-    parser.add_argument("--config", default="config/security-config.json", help="配置檔案路徑")
-    parser.add_argument("--output", default="security-report.json", help="結果輸出檔案")
+    parser.add_argument(
+        "--config", default="config/security-config.json", help="配置檔案路徑"
+    )
+    parser.add_argument(
+        "--output", default="security-report.json", help="結果輸出檔案"
+    )
     parser.add_argument(
         "--severity",
         choices=["critical", "high", "medium", "low"],
@@ -1117,7 +1249,8 @@ async def main():
     # 設置日誌
     log_level = logging.DEBUG if args.verbose else logging.INFO
     logging.basicConfig(
-        level=log_level, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
+        level=log_level,
+        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
     )
 
     # 執行安全掃描
@@ -1129,9 +1262,9 @@ async def main():
         json.dump(asdict(report), f, indent=2, ensure_ascii=False, default=str)
 
     # 輸出摘要
-    print(f"\n{'='*60}")
+    print(f"\n{'=' * 60}")
     print("🔒 安全掃描結果摘要")
-    print(f"{'='*60}")
+    print(f"{'=' * 60}")
     print(f"掃描目標: {report.target}")
     print(f"掃描持續時間: {report.duration_seconds:.2f} 秒")
     print(f"總發現問題: {len(report.findings)}")
@@ -1148,7 +1281,7 @@ async def main():
         status = "✅ 合規" if compliant else "❌ 不合規"
         print(f"  {framework}: {status}")
 
-    print(f"\n{'='*60}")
+    print(f"\n{'=' * 60}")
     print(f"詳細報告已保存至: {args.output}")
 
     # 根據嚴重程度設置退出代碼
diff --git a/auto_generate_video_fold6/scripts/service_manager.py b/auto_generate_video_fold6/scripts/service_manager.py
index ee622ce..fd71ad0 100755
--- a/auto_generate_video_fold6/scripts/service_manager.py
+++ b/auto_generate_video_fold6/scripts/service_manager.py
@@ -21,7 +21,8 @@ from enum import Enum
 
 # 設置日誌
 logging.basicConfig(
-    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
+    level=logging.INFO,
+    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
 )
 logger = logging.getLogger(__name__)
 
@@ -71,7 +72,9 @@ class ServiceStatus:
         return {
             **asdict(self),
             "state": self.state.value,
-            "start_time": self.start_time.isoformat() if self.start_time else None,
+            "start_time": self.start_time.isoformat()
+            if self.start_time
+            else None,
             "metadata": self.metadata or {},
         }
 
@@ -187,7 +190,9 @@ class ServiceManager:
 
         for service in default_services:
             self.services[service.name] = service
-            self.status[service.name] = ServiceStatus(name=service.name, state=ServiceState.STOPPED)
+            self.status[service.name] = ServiceStatus(
+                name=service.name, state=ServiceState.STOPPED
+            )
 
         # 保存預設配置
         self._save_config()
@@ -195,7 +200,11 @@ class ServiceManager:
     def _save_config(self):
         """保存服務配置"""
         try:
-            config_data = {"services": [asdict(service) for service in self.services.values()]}
+            config_data = {
+                "services": [
+                    asdict(service) for service in self.services.values()
+                ]
+            }
 
             config_path = Path(self.config_file)
             config_path.parent.mkdir(parents=True, exist_ok=True)
@@ -272,10 +281,16 @@ class ServiceManager:
                 if service.health_check_url.startswith("http"):
                     # HTTP 健康檢查
                     timeout = aiohttp.ClientTimeout(total=5)
-                    async with aiohttp.ClientSession(timeout=timeout) as session:
-                        async with session.get(service.health_check_url) as response:
+                    async with aiohttp.ClientSession(
+                        timeout=timeout
+                    ) as session:
+                        async with session.get(
+                            service.health_check_url
+                        ) as response:
                             if response.status == 200:
-                                logger.info(f"服務 {service_name} 健康檢查通過")
+                                logger.info(
+                                    f"服務 {service_name} 健康檢查通過"
+                                )
                                 return True
 
                 elif service.health_check_url.startswith("redis://"):
@@ -283,7 +298,9 @@ class ServiceManager:
                     try:
                         import redis
 
-                        r = redis.Redis(host="localhost", port=6379, decode_responses=True)
+                        r = redis.Redis(
+                            host="localhost", port=6379, decode_responses=True
+                        )
                         r.ping()
                         logger.info(f"服務 {service_name} 健康檢查通過")
                         return True
@@ -351,7 +368,9 @@ class ServiceManager:
             if await self._wait_for_health_check(service_name):
                 status.state = ServiceState.RUNNING
                 status.health_status = "healthy"
-                logger.info(f"服務 {service_name} 啟動成功 (PID: {process.pid})")
+                logger.info(
+                    f"服務 {service_name} 啟動成功 (PID: {process.pid})"
+                )
                 return True
             else:
                 # 健康檢查失敗，停止進程
@@ -397,7 +416,9 @@ class ServiceManager:
                     try:
                         process.wait(timeout=service.shutdown_timeout)
                     except psutil.TimeoutExpired:
-                        logger.warning(f"服務 {service_name} 優雅停止超時，強制終止")
+                        logger.warning(
+                            f"服務 {service_name} 優雅停止超時，強制終止"
+                        )
                         process.kill()
                         process.wait(timeout=10)
 
@@ -443,7 +464,9 @@ class ServiceManager:
             ready = []
             for service_name in remaining:
                 service = self.services[service_name]
-                if not service.dependencies or all(dep in ordered for dep in service.dependencies):
+                if not service.dependencies or all(
+                    dep in ordered for dep in service.dependencies
+                ):
                     ready.append(service_name)
 
             if not ready:
@@ -508,12 +531,24 @@ class ServiceManager:
 
         return {
             "total_services": len(self.services),
-            "running": sum(1 for state in states if state == ServiceState.RUNNING),
-            "stopped": sum(1 for state in states if state == ServiceState.STOPPED),
-            "failed": sum(1 for state in states if state == ServiceState.FAILED),
-            "starting": sum(1 for state in states if state == ServiceState.STARTING),
-            "stopping": sum(1 for state in states if state == ServiceState.STOPPING),
-            "services": {name: status.to_dict() for name, status in self.status.items()},
+            "running": sum(
+                1 for state in states if state == ServiceState.RUNNING
+            ),
+            "stopped": sum(
+                1 for state in states if state == ServiceState.STOPPED
+            ),
+            "failed": sum(
+                1 for state in states if state == ServiceState.FAILED
+            ),
+            "starting": sum(
+                1 for state in states if state == ServiceState.STARTING
+            ),
+            "stopping": sum(
+                1 for state in states if state == ServiceState.STOPPING
+            ),
+            "services": {
+                name: status.to_dict() for name, status in self.status.items()
+            },
             "timestamp": datetime.now().isoformat(),
         }
 
@@ -533,8 +568,10 @@ class ServiceManager:
 
                             # 自動重啟 (如果啟用)
                             service = self.services[service_name]
-                            if service.auto_restart and status.restart_count < service.max_restarts:
-
+                            if (
+                                service.auto_restart
+                                and status.restart_count < service.max_restarts
+                            ):
                                 logger.info(
                                     f"自動重啟服務 {service_name} (第 {status.restart_count + 1} 次)"
                                 )
@@ -566,7 +603,9 @@ async def main():
         if command == "start":
             if service_name:
                 success = await manager.start_service(service_name)
-                print(f"服務 {service_name} 啟動 {'成功' if success else '失敗'}")
+                print(
+                    f"服務 {service_name} 啟動 {'成功' if success else '失敗'}"
+                )
             else:
                 success = await manager.start_all_services()
                 print(f"所有服務啟動 {'成功' if success else '失敗'}")
@@ -574,7 +613,9 @@ async def main():
         elif command == "stop":
             if service_name:
                 success = await manager.stop_service(service_name)
-                print(f"服務 {service_name} 停止 {'成功' if success else '失敗'}")
+                print(
+                    f"服務 {service_name} 停止 {'成功' if success else '失敗'}"
+                )
             else:
                 success = await manager.stop_all_services()
                 print(f"所有服務停止 {'成功' if success else '失敗'}")
@@ -582,7 +623,9 @@ async def main():
         elif command == "restart":
             if service_name:
                 success = await manager.restart_service(service_name)
-                print(f"服務 {service_name} 重啟 {'成功' if success else '失敗'}")
+                print(
+                    f"服務 {service_name} 重啟 {'成功' if success else '失敗'}"
+                )
             else:
                 await manager.stop_all_services()
                 await asyncio.sleep(3)
@@ -593,7 +636,11 @@ async def main():
             if service_name:
                 status = manager.get_service_status(service_name)
                 if status:
-                    print(json.dumps(status.to_dict(), indent=2, ensure_ascii=False))
+                    print(
+                        json.dumps(
+                            status.to_dict(), indent=2, ensure_ascii=False
+                        )
+                    )
                 else:
                     print(f"服務 {service_name} 不存在")
             else:
diff --git a/auto_generate_video_fold6/scripts/test-coverage-audit.py b/auto_generate_video_fold6/scripts/test-coverage-audit.py
index 3510904..8a4525a 100644
--- a/auto_generate_video_fold6/scripts/test-coverage-audit.py
+++ b/auto_generate_video_fold6/scripts/test-coverage-audit.py
@@ -14,18 +14,23 @@ from datetime import datetime
 
 class TestCoverageAuditor:
     """測試覆蓋率審查器"""
-    
+
     def __init__(self, project_root: str):
         self.project_root = Path(project_root)
         self.services_dir = self.project_root / "services"
         self.existing_tests = set()
         self.source_files = []
         self.coverage_report = {}
-    
+
     def scan_existing_tests(self):
         """掃描現有測試文件"""
-        test_patterns = ["test_*.py", "*_test.py", "tests/*.py", "**/*test*.py"]
-        
+        test_patterns = [
+            "test_*.py",
+            "*_test.py",
+            "tests/*.py",
+            "**/*test*.py",
+        ]
+
         for pattern in test_patterns:
             for test_file in self.project_root.rglob(pattern):
                 if test_file.is_file():
@@ -37,90 +42,109 @@ class TestCoverageAuditor:
                         module_name = test_name[:-5]
                     else:
                         module_name = test_name
-                    
+
                     self.existing_tests.add(module_name)
-        
+
         print(f"發現 {len(self.existing_tests)} 個現有測試文件")
-    
+
     def scan_source_files(self):
         """掃描所有源碼文件"""
         python_files = list(self.project_root.rglob("*.py"))
-        
+
         for py_file in python_files:
             # 跳過測試文件、__pycache__、migrations 等
-            if any(skip in str(py_file) for skip in [
-                "test", "__pycache__", "migrations", "venv", ".git", 
-                "node_modules", "dist", "build"
-            ]):
+            if any(
+                skip in str(py_file)
+                for skip in [
+                    "test",
+                    "__pycache__",
+                    "migrations",
+                    "venv",
+                    ".git",
+                    "node_modules",
+                    "dist",
+                    "build",
+                ]
+            ):
                 continue
-                
+
             # 分析文件內容
             try:
-                with open(py_file, 'r', encoding='utf-8') as f:
+                with open(py_file, "r", encoding="utf-8") as f:
                     content = f.read()
                     tree = ast.parse(content)
-                    
+
                 file_info = self.analyze_python_file(py_file, tree)
                 if file_info:
                     self.source_files.append(file_info)
-                    
+
             except Exception as e:
                 print(f"分析文件 {py_file} 時出錯: {e}")
-    
+
     def analyze_python_file(self, file_path: Path, tree: ast.AST) -> Dict:
         """分析 Python 文件結構"""
         classes = []
         functions = []
-        
+
         for node in ast.walk(tree):
             if isinstance(node, ast.ClassDef):
                 methods = []
                 for item in node.body:
                     if isinstance(item, ast.FunctionDef):
-                        methods.append({
-                            "name": item.name,
-                            "line": item.lineno,
-                            "is_private": item.name.startswith('_'),
-                            "is_async": isinstance(item, ast.AsyncFunctionDef),
-                            "args": len(item.args.args)
-                        })
-                
-                classes.append({
-                    "name": node.name,
-                    "line": node.lineno,
-                    "methods": methods
-                })
-            
+                        methods.append(
+                            {
+                                "name": item.name,
+                                "line": item.lineno,
+                                "is_private": item.name.startswith("_"),
+                                "is_async": isinstance(
+                                    item, ast.AsyncFunctionDef
+                                ),
+                                "args": len(item.args.args),
+                            }
+                        )
+
+                classes.append(
+                    {
+                        "name": node.name,
+                        "line": node.lineno,
+                        "methods": methods,
+                    }
+                )
+
             elif isinstance(node, ast.FunctionDef) and node.col_offset == 0:
-                functions.append({
-                    "name": node.name,
-                    "line": node.lineno,
-                    "is_async": isinstance(node, ast.AsyncFunctionDef),
-                    "args": len(node.args.args)
-                })
-        
+                functions.append(
+                    {
+                        "name": node.name,
+                        "line": node.lineno,
+                        "is_async": isinstance(node, ast.AsyncFunctionDef),
+                        "args": len(node.args.args),
+                    }
+                )
+
         relative_path = file_path.relative_to(self.project_root)
-        module_name = str(relative_path).replace('/', '.').replace('.py', '')
-        
+        module_name = str(relative_path).replace("/", ".").replace(".py", "")
+
         return {
             "file_path": str(file_path),
             "relative_path": str(relative_path),
             "module_name": module_name,
             "classes": classes,
             "functions": functions,
-            "has_test": any(test in str(file_path) for test in self.existing_tests),
-            "complexity": len(classes) + len(functions)
+            "has_test": any(
+                test in str(file_path) for test in self.existing_tests
+            ),
+            "complexity": len(classes) + len(functions),
         }
-    
+
     def generate_coverage_report(self):
         """生成覆蓋率報告"""
         total_files = len(self.source_files)
         tested_files = sum(1 for f in self.source_files if f["has_test"])
-        
+
         # 按服務分組
         services = {}
         unorganized = []
-        
+
         for file_info in self.source_files:
             if file_info["relative_path"].startswith("services/"):
                 service_name = file_info["relative_path"].split("/")[1]
@@ -129,85 +153,103 @@ class TestCoverageAuditor:
                 services[service_name].append(file_info)
             else:
                 unorganized.append(file_info)
-        
+
         self.coverage_report = {
             "timestamp": datetime.now().isoformat(),
             "summary": {
                 "total_files": total_files,
                 "tested_files": tested_files,
-                "coverage_percentage": round((tested_files / total_files) * 100, 2) if total_files > 0 else 0,
-                "untested_files": total_files - tested_files
+                "coverage_percentage": round(
+                    (tested_files / total_files) * 100, 2
+                )
+                if total_files > 0
+                else 0,
+                "untested_files": total_files - tested_files,
             },
             "services": {},
             "unorganized": unorganized,
-            "priority_files": []
+            "priority_files": [],
         }
-        
+
         # 分析各服務覆蓋率
         for service_name, files in services.items():
             service_tested = sum(1 for f in files if f["has_test"])
             service_total = len(files)
-            
+
             self.coverage_report["services"][service_name] = {
                 "total_files": service_total,
                 "tested_files": service_tested,
-                "coverage_percentage": round((service_tested / service_total) * 100, 2) if service_total > 0 else 0,
-                "files": files
+                "coverage_percentage": round(
+                    (service_tested / service_total) * 100, 2
+                )
+                if service_total > 0
+                else 0,
+                "files": files,
             }
-        
+
         # 識別高優先級需要測試的文件 (複雜度高且無測試)
         priority_files = []
         for file_info in self.source_files:
             if not file_info["has_test"] and file_info["complexity"] >= 3:
-                priority_files.append({
-                    "file": file_info["relative_path"],
-                    "complexity": file_info["complexity"],
-                    "classes_count": len(file_info["classes"]),
-                    "functions_count": len(file_info["functions"])
-                })
-        
+                priority_files.append(
+                    {
+                        "file": file_info["relative_path"],
+                        "complexity": file_info["complexity"],
+                        "classes_count": len(file_info["classes"]),
+                        "functions_count": len(file_info["functions"]),
+                    }
+                )
+
         # 按複雜度排序
         priority_files.sort(key=lambda x: x["complexity"], reverse=True)
         self.coverage_report["priority_files"] = priority_files[:20]  # 前20個
-    
+
     def generate_test_templates(self, output_dir: str = None):
         """為優先級文件生成測試模板"""
         if output_dir is None:
             output_dir = self.project_root / "test_templates"
         else:
             output_dir = Path(output_dir)
-        
+
         output_dir.mkdir(exist_ok=True)
-        
+
         templates_created = []
-        
-        for priority_file in self.coverage_report["priority_files"][:10]:  # 前10個
+
+        for priority_file in self.coverage_report["priority_files"][
+            :10
+        ]:  # 前10個
             file_path = self.project_root / priority_file["file"]
-            
+
             # 找到對應的文件信息
             file_info = next(
-                (f for f in self.source_files if f["relative_path"] == priority_file["file"]), 
-                None
+                (
+                    f
+                    for f in self.source_files
+                    if f["relative_path"] == priority_file["file"]
+                ),
+                None,
             )
-            
+
             if file_info:
                 template_content = self.create_test_template(file_info)
-                
+
                 # 確定測試文件路径
-                test_filename = f"test_{Path(file_info['relative_path']).stem}.py"
+                test_filename = (
+                    f"test_{Path(file_info['relative_path']).stem}.py"
+                )
                 test_file_path = output_dir / test_filename
-                
-                with open(test_file_path, 'w', encoding='utf-8') as f:
+
+                with open(test_file_path, "w", encoding="utf-8") as f:
                     f.write(template_content)
-                
+
                 templates_created.append(str(test_file_path))
-        
+
         return templates_created
-    
+
     def create_test_template(self, file_info: Dict) -> str:
         """創建測試模板"""
         module_path = file_info["module_name"]
-        
+
         template = f'''#!/usr/bin/env python3
 """
 {file_info["relative_path"]} 的測試文件
@@ -231,7 +273,7 @@ class TestModule:
         pass
 
 '''
-        
+
         # 為每個類生成測試
         for class_info in file_info["classes"]:
             template += f'''
@@ -243,7 +285,7 @@ class Test{class_info["name"]}:
         pass
     
 '''
-            
+
             # 為每個方法生成測試
             for method in class_info["methods"]:
                 if not method["is_private"]:  # 只為公共方法生成測試
@@ -253,10 +295,10 @@ class Test{class_info["name"]}:
         assert True
     
 '''
-        
+
         # 為函數生成測試
         for func_info in file_info["functions"]:
-            if not func_info["name"].startswith('_'):  # 只為公共函數生成測試
+            if not func_info["name"].startswith("_"):  # 只為公共函數生成測試
                 template += f'''def test_{func_info["name"]}():
     """測試 {func_info["name"]} 函數"""
     # TODO: 實現測試邏輯
@@ -264,75 +306,87 @@ class Test{class_info["name"]}:
 
 
 '''
-        
+
         return template
-    
+
     def save_report(self, output_file: str = None):
         """保存覆蓋率報告"""
         if output_file is None:
             timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
-            output_file = self.project_root / f"test_coverage_report_{timestamp}.json"
-        
-        with open(output_file, 'w', encoding='utf-8') as f:
+            output_file = (
+                self.project_root / f"test_coverage_report_{timestamp}.json"
+            )
+
+        with open(output_file, "w", encoding="utf-8") as f:
             json.dump(self.coverage_report, f, indent=2, ensure_ascii=False)
-        
+
         return output_file
-    
+
     def print_summary(self):
         """打印摘要報告"""
         summary = self.coverage_report["summary"]
-        
-        print("\n" + "="*60)
+
+        print("\n" + "=" * 60)
         print("🧪 測試覆蓋率審查報告")
-        print("="*60)
+        print("=" * 60)
         print(f"📊 總文件數: {summary['total_files']}")
         print(f"✅ 已測試文件: {summary['tested_files']}")
         print(f"❌ 未測試文件: {summary['untested_files']}")
         print(f"📈 覆蓋率: {summary['coverage_percentage']}%")
-        
+
         print(f"\n🎯 各服務覆蓋率:")
-        for service_name, service_info in self.coverage_report["services"].items():
+        for service_name, service_info in self.coverage_report[
+            "services"
+        ].items():
             coverage = service_info["coverage_percentage"]
-            status = "🟢" if coverage >= 80 else "🟡" if coverage >= 60 else "🔴"
-            print(f"  {status} {service_name}: {coverage}% ({service_info['tested_files']}/{service_info['total_files']})")
-        
+            status = (
+                "🟢" if coverage >= 80 else "🟡" if coverage >= 60 else "🔴"
+            )
+            print(
+                f"  {status} {service_name}: {coverage}% ({service_info['tested_files']}/{service_info['total_files']})"
+            )
+
         print(f"\n🚨 高優先級需要測試的文件 (複雜度 ≥ 3):")
-        for i, priority_file in enumerate(self.coverage_report["priority_files"][:10], 1):
-            print(f"  {i:2d}. {priority_file['file']} (複雜度: {priority_file['complexity']})")
-    
+        for i, priority_file in enumerate(
+            self.coverage_report["priority_files"][:10], 1
+        ):
+            print(
+                f"  {i:2d}. {priority_file['file']} (複雜度: {priority_file['complexity']})"
+            )
+
     def run_audit(self):
         """執行完整審查"""
         print("🔍 掃描現有測試文件...")
         self.scan_existing_tests()
-        
+
         print("📁 掃描源碼文件...")
         self.scan_source_files()
-        
+
         print("📊 生成覆蓋率報告...")
         self.generate_coverage_report()
-        
+
         print("📝 生成測試模板...")
         templates = self.generate_test_templates()
-        
+
         print("💾 保存報告...")
         report_file = self.save_report()
-        
+
         self.print_summary()
-        
+
         print(f"\n📄 詳細報告已保存至: {report_file}")
         print(f"🧪 測試模板已生成 {len(templates)} 個文件")
-        
+
         return report_file, templates
 
 
 if __name__ == "__main__":
     import sys
-    
+
     project_root = sys.argv[1] if len(sys.argv) > 1 else "."
-    
+
     auditor = TestCoverageAuditor(project_root)
     report_file, templates = auditor.run_audit()
-    
+
     print(f"\n🎉 審查完成！")
     print(f"📊 報告: {report_file}")
-    print(f"🧪 模板: {len(templates)} 個文件已生成")
\ No newline at end of file
+    print(f"🧪 模板: {len(templates)} 個文件已生成")
diff --git a/auto_generate_video_fold6/scripts/test_backup_recovery.py b/auto_generate_video_fold6/scripts/test_backup_recovery.py
index 711fb70..6a7941f 100644
--- a/auto_generate_video_fold6/scripts/test_backup_recovery.py
+++ b/auto_generate_video_fold6/scripts/test_backup_recovery.py
@@ -22,7 +22,7 @@ from dataclasses import dataclass
 # 設置日誌
 logging.basicConfig(
     level=logging.INFO,
-    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
+    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
 )
 logger = logging.getLogger(__name__)
 
@@ -30,6 +30,7 @@ logger = logging.getLogger(__name__)
 @dataclass
 class TestResult:
     """測試結果"""
+
     test_name: str
     success: bool
     duration: float
@@ -39,86 +40,90 @@ class TestResult:
 
 class BackupRecoveryTester:
     """備份恢復測試器"""
-    
+
     def __init__(self):
         self.test_results: List[TestResult] = []
         self.temp_dir = Path(tempfile.mkdtemp(prefix="backup_test_"))
         self.config = self._load_config()
-        
+
     def _load_config(self) -> Dict:
         """載入測試配置"""
         return {
-            'postgres': {
-                'host': os.getenv('POSTGRES_HOST', 'localhost'),
-                'port': os.getenv('POSTGRES_PORT', '5432'),
-                'user': os.getenv('POSTGRES_USER', 'auto_video_user'),
-                'password': os.getenv('POSTGRES_PASSWORD', 'password'),
-                'database': os.getenv('POSTGRES_DB', 'auto_video_db')
+            "postgres": {
+                "host": os.getenv("POSTGRES_HOST", "localhost"),
+                "port": os.getenv("POSTGRES_PORT", "5432"),
+                "user": os.getenv("POSTGRES_USER", "auto_video_user"),
+                "password": os.getenv("POSTGRES_PASSWORD", "password"),
+                "database": os.getenv("POSTGRES_DB", "auto_video_db"),
             },
-            'redis': {
-                'host': os.getenv('REDIS_HOST', 'localhost'),
-                'port': int(os.getenv('REDIS_PORT', '6379')),
-                'password': os.getenv('REDIS_PASSWORD', '')
+            "redis": {
+                "host": os.getenv("REDIS_HOST", "localhost"),
+                "port": int(os.getenv("REDIS_PORT", "6379")),
+                "password": os.getenv("REDIS_PASSWORD", ""),
+            },
+            "s3": {
+                "endpoint_url": os.getenv(
+                    "S3_ENDPOINT_URL", "http://localhost:9000"
+                ),
+                "access_key": os.getenv("S3_ACCESS_KEY_ID", "minioadmin"),
+                "secret_key": os.getenv("S3_SECRET_ACCESS_KEY", "minioadmin"),
+                "bucket": os.getenv("S3_BUCKET_NAME", "auto-video-backups"),
             },
-            's3': {
-                'endpoint_url': os.getenv('S3_ENDPOINT_URL', 'http://localhost:9000'),
-                'access_key': os.getenv('S3_ACCESS_KEY_ID', 'minioadmin'),
-                'secret_key': os.getenv('S3_SECRET_ACCESS_KEY', 'minioadmin'),
-                'bucket': os.getenv('S3_BUCKET_NAME', 'auto-video-backups')
-            }
         }
 
     async def test_database_backup_restore(self) -> TestResult:
         """測試資料庫備份和恢復"""
         start_time = datetime.now()
         test_name = "資料庫備份恢復測試"
-        
+
         try:
             # 1. 創建測試資料
             test_table = f"backup_test_{int(datetime.now().timestamp())}"
             test_data = [
-                ('test_user_1', 'test@example.com', '2024-01-01'),
-                ('test_user_2', 'user2@example.com', '2024-01-02'),
-                ('test_user_3', 'user3@example.com', '2024-01-03')
+                ("test_user_1", "test@example.com", "2024-01-01"),
+                ("test_user_2", "user2@example.com", "2024-01-02"),
+                ("test_user_3", "user3@example.com", "2024-01-03"),
             ]
-            
+
             logger.info(f"創建測試表: {test_table}")
             await self._create_test_data(test_table, test_data)
-            
+
             # 2. 執行資料庫備份
             backup_file = self.temp_dir / f"{test_table}_backup.sql.gz"
             logger.info(f"執行資料庫備份到: {backup_file}")
             backup_success = await self._backup_database(backup_file)
-            
+
             if not backup_success:
                 raise Exception("資料庫備份失敗")
-            
+
             # 3. 刪除測試資料
             logger.info("刪除原始測試資料")
             await self._delete_test_data(test_table)
-            
+
             # 4. 驗證資料已刪除
             data_count = await self._count_test_data(test_table)
             if data_count > 0:
                 raise Exception("測試資料刪除失敗")
-            
+
             # 5. 執行資料恢復
             logger.info("執行資料庫恢復")
             restore_success = await self._restore_database(backup_file)
-            
+
             if not restore_success:
                 raise Exception("資料庫恢復失敗")
-            
+
             # 6. 驗證恢復的資料
             logger.info("驗證恢復的資料")
             restored_data = await self._get_test_data(test_table)
-            
+
             if len(restored_data) != len(test_data):
-                raise Exception(f"恢復的資料數量不正確: 期望 {len(test_data)}, 實際 {len(restored_data)}")
-            
+                raise Exception(
+                    f"恢復的資料數量不正確: 期望 {len(test_data)}, 實際 {len(restored_data)}"
+                )
+
             # 7. 清理測試資料
             await self._delete_test_data(test_table)
-            
+
             duration = (datetime.now() - start_time).total_seconds()
             return TestResult(
                 test_name=test_name,
@@ -126,11 +131,13 @@ class BackupRecoveryTester:
                 duration=duration,
                 message=f"成功備份和恢復 {len(test_data)} 筆資料",
                 details={
-                    'backup_file_size': backup_file.stat().st_size if backup_file.exists() else 0,
-                    'restored_records': len(restored_data)
-                }
+                    "backup_file_size": backup_file.stat().st_size
+                    if backup_file.exists()
+                    else 0,
+                    "restored_records": len(restored_data),
+                },
             )
-            
+
         except Exception as e:
             duration = (datetime.now() - start_time).total_seconds()
             logger.error(f"資料庫備份恢復測試失敗: {e}")
@@ -138,67 +145,68 @@ class BackupRecoveryTester:
                 test_name=test_name,
                 success=False,
                 duration=duration,
-                message=str(e)
+                message=str(e),
             )
 
     async def test_redis_backup_restore(self) -> TestResult:
         """測試 Redis 備份和恢復"""
         start_time = datetime.now()
         test_name = "Redis 備份恢復測試"
-        
+
         try:
             # 1. 創建測試資料
             test_keys = {
-                f"test:backup:{i}": f"test_value_{i}" 
-                for i in range(100)
+                f"test:backup:{i}": f"test_value_{i}" for i in range(100)
             }
-            
+
             logger.info(f"在 Redis 中創建 {len(test_keys)} 個測試鍵")
             redis_client = redis.Redis(
-                host=self.config['redis']['host'],
-                port=self.config['redis']['port'],
-                password=self.config['redis']['password'],
-                decode_responses=True
+                host=self.config["redis"]["host"],
+                port=self.config["redis"]["port"],
+                password=self.config["redis"]["password"],
+                decode_responses=True,
             )
-            
+
             for key, value in test_keys.items():
                 redis_client.set(key, value)
-            
+
             # 2. 執行 Redis 備份 (RDB dump)
             backup_file = self.temp_dir / "redis_backup.rdb"
             logger.info(f"執行 Redis 備份到: {backup_file}")
-            
+
             # 觸發 Redis 保存
             redis_client.bgsave()
-            
+
             # 等待備份完成
             await asyncio.sleep(1)
-            
+
             # 複製 RDB 文件
             redis_dump_path = "/var/lib/redis/dump.rdb"  # 默認路徑
             if not Path(redis_dump_path).exists():
                 redis_dump_path = "/data/dump.rdb"  # Docker 容器路徑
-            
+
             if Path(redis_dump_path).exists():
                 shutil.copy2(redis_dump_path, backup_file)
             else:
                 # 如果找不到 RDB 文件，使用手動方式
                 await self._manual_redis_backup(redis_client, backup_file)
-            
+
             # 3. 清除測試資料
             logger.info("清除 Redis 測試資料")
             for key in test_keys.keys():
                 redis_client.delete(key)
-            
+
             # 4. 驗證資料已清除
             remaining_keys = redis_client.keys("test:backup:*")
             if remaining_keys:
-                raise Exception(f"測試資料清除失敗，仍有 {len(remaining_keys)} 個鍵")
-            
+                raise Exception(
+                    f"測試資料清除失敗，仍有 {len(remaining_keys)} 個鍵"
+                )
+
             # 5. 模擬恢復 (重新插入資料)
             logger.info("模擬 Redis 資料恢復")
             await self._restore_redis_data(redis_client, test_keys)
-            
+
             # 6. 驗證恢復的資料
             logger.info("驗證恢復的資料")
             restored_count = 0
@@ -206,14 +214,16 @@ class BackupRecoveryTester:
                 actual_value = redis_client.get(key)
                 if actual_value == expected_value:
                     restored_count += 1
-            
+
             if restored_count != len(test_keys):
-                raise Exception(f"恢復的資料不完整: 期望 {len(test_keys)}, 實際 {restored_count}")
-            
+                raise Exception(
+                    f"恢復的資料不完整: 期望 {len(test_keys)}, 實際 {restored_count}"
+                )
+
             # 7. 清理測試資料
             for key in test_keys.keys():
                 redis_client.delete(key)
-            
+
             duration = (datetime.now() - start_time).total_seconds()
             return TestResult(
                 test_name=test_name,
@@ -221,11 +231,13 @@ class BackupRecoveryTester:
                 duration=duration,
                 message=f"成功備份和恢復 {len(test_keys)} 個 Redis 鍵",
                 details={
-                    'backup_file_size': backup_file.stat().st_size if backup_file.exists() else 0,
-                    'restored_keys': restored_count
-                }
+                    "backup_file_size": backup_file.stat().st_size
+                    if backup_file.exists()
+                    else 0,
+                    "restored_keys": restored_count,
+                },
             )
-            
+
         except Exception as e:
             duration = (datetime.now() - start_time).total_seconds()
             logger.error(f"Redis 備份恢復測試失敗: {e}")
@@ -233,67 +245,74 @@ class BackupRecoveryTester:
                 test_name=test_name,
                 success=False,
                 duration=duration,
-                message=str(e)
+                message=str(e),
             )
 
     async def test_file_backup_restore(self) -> TestResult:
         """測試檔案備份和恢復"""
         start_time = datetime.now()
         test_name = "檔案備份恢復測試"
-        
+
         try:
             # 1. 創建測試檔案
             test_files_dir = self.temp_dir / "test_files"
             test_files_dir.mkdir(exist_ok=True)
-            
+
             test_files = {}
             for i in range(10):
                 file_path = test_files_dir / f"test_file_{i}.txt"
-                content = f"Test file {i} content\nCreated at {datetime.now()}\n" * 100
-                file_path.write_text(content, encoding='utf-8')
+                content = (
+                    f"Test file {i} content\nCreated at {datetime.now()}\n"
+                    * 100
+                )
+                file_path.write_text(content, encoding="utf-8")
                 test_files[file_path.name] = len(content)
-            
+
             logger.info(f"創建了 {len(test_files)} 個測試檔案")
-            
+
             # 2. 執行檔案備份
             backup_archive = self.temp_dir / "files_backup.tar.gz"
             logger.info(f"執行檔案備份到: {backup_archive}")
-            
+
             with tarfile.open(backup_archive, "w:gz") as tar:
                 tar.add(test_files_dir, arcname="test_files")
-            
+
             # 3. 刪除原始檔案
             logger.info("刪除原始測試檔案")
             shutil.rmtree(test_files_dir)
-            
+
             # 4. 驗證檔案已刪除
             if test_files_dir.exists():
                 raise Exception("測試檔案刪除失敗")
-            
+
             # 5. 執行檔案恢復
             logger.info("執行檔案恢復")
             with tarfile.open(backup_archive, "r:gz") as tar:
                 tar.extractall(self.temp_dir)
-            
+
             # 6. 驗證恢復的檔案
             restored_files_dir = self.temp_dir / "test_files"
             if not restored_files_dir.exists():
                 raise Exception("檔案恢復失敗，目錄不存在")
-            
+
             restored_files = list(restored_files_dir.glob("*.txt"))
             if len(restored_files) != len(test_files):
-                raise Exception(f"恢復的檔案數量不正確: 期望 {len(test_files)}, 實際 {len(restored_files)}")
-            
+                raise Exception(
+                    f"恢復的檔案數量不正確: 期望 {len(test_files)}, 實際 {len(restored_files)}"
+                )
+
             # 驗證檔案內容
             for file_path in restored_files:
                 if file_path.name not in test_files:
                     raise Exception(f"發現意外的檔案: {file_path.name}")
-                
-                actual_size = len(file_path.read_text(encoding='utf-8'))
+
+                actual_size = len(file_path.read_text(encoding="utf-8"))
                 expected_size = test_files[file_path.name]
                 if actual_size != expected_size:
-                    raise Exception(f"檔案 {file_path.name} 大小不正確: 期望 {expected_size}, 實際 {actual_size}")
-            
+                    raise Exception(
+                        f"檔案 {file_path.name} 大小不正確: 期望 {expected_size}, 實際 {actual_size}"
+                    )
+
             duration = (datetime.now() - start_time).total_seconds()
             return TestResult(
                 test_name=test_name,
@@ -301,11 +320,13 @@ class BackupRecoveryTester:
                 duration=duration,
                 message=f"成功備份和恢復 {len(test_files)} 個檔案",
                 details={
-                    'backup_archive_size': backup_archive.stat().st_size if backup_archive.exists() else 0,
-                    'restored_files': len(restored_files)
-                }
+                    "backup_archive_size": backup_archive.stat().st_size
+                    if backup_archive.exists()
+                    else 0,
+                    "restored_files": len(restored_files),
+                },
             )
-            
+
         except Exception as e:
             duration = (datetime.now() - start_time).total_seconds()
             logger.error(f"檔案備份恢復測試失敗: {e}")
@@ -313,68 +334,74 @@ class BackupRecoveryTester:
                 test_name=test_name,
                 success=False,
                 duration=duration,
-                message=str(e)
+                message=str(e),
             )
 
     async def test_s3_backup_restore(self) -> TestResult:
         """測試 S3 備份和恢復"""
         start_time = datetime.now()
         test_name = "S3 備份恢復測試"
-        
+
         try:
             # 1. 設置 S3 客戶端
             s3_client = boto3.client(
-                's3',
-                endpoint_url=self.config['s3']['endpoint_url'],
-                aws_access_key_id=self.config['s3']['access_key'],
-                aws_secret_access_key=self.config['s3']['secret_key']
+                "s3",
+                endpoint_url=self.config["s3"]["endpoint_url"],
+                aws_access_key_id=self.config["s3"]["access_key"],
+                aws_secret_access_key=self.config["s3"]["secret_key"],
             )
-            
-            bucket_name = self.config['s3']['bucket']
-            
+
+            bucket_name = self.config["s3"]["bucket"]
+
             # 2. 創建測試檔案
             test_file = self.temp_dir / "s3_test_file.json"
             test_data = {
-                'test_id': int(datetime.now().timestamp()),
-                'data': [f"item_{i}" for i in range(1000)],
-                'timestamp': datetime.now().isoformat()
+                "test_id": int(datetime.now().timestamp()),
+                "data": [f"item_{i}" for i in range(1000)],
+                "timestamp": datetime.now().isoformat(),
             }
-            
-            test_file.write_text(json.dumps(test_data, indent=2), encoding='utf-8')
+
+            test_file.write_text(
+                json.dumps(test_data, indent=2), encoding="utf-8"
+            )
             logger.info(f"創建測試檔案: {test_file}")
-            
+
             # 3. 上傳到 S3
             s3_key = f"backup-test/{test_file.name}"
             logger.info(f"上傳檔案到 S3: {s3_key}")
-            
+
             s3_client.upload_file(str(test_file), bucket_name, s3_key)
-            
+
             # 4. 刪除本地檔案
             test_file.unlink()
             logger.info("刪除本地測試檔案")
-            
+
             # 5. 從 S3 下載檔案
             restored_file = self.temp_dir / "restored_s3_test_file.json"
             logger.info(f"從 S3 下載檔案: {restored_file}")
-            
+
             s3_client.download_file(bucket_name, s3_key, str(restored_file))
-            
+
             # 6. 驗證恢復的檔案
             if not restored_file.exists():
                 raise Exception("檔案從 S3 恢復失敗")
-            
-            restored_data = json.loads(restored_file.read_text(encoding='utf-8'))
-            
-            if restored_data['test_id'] != test_data['test_id']:
+
+            restored_data = json.loads(
+                restored_file.read_text(encoding="utf-8")
+            )
+
+            if restored_data["test_id"] != test_data["test_id"]:
                 raise Exception("恢復的檔案內容不正確")
-            
-            if len(restored_data['data']) != len(test_data['data']):
-                raise Exception(f"恢復的資料項目數量不正確: 期望 {len(test_data['data'])}, 實際 {len(restored_data['data'])}")
-            
+
+            if len(restored_data["data"]) != len(test_data["data"]):
+                raise Exception(
+                    f"恢復的資料項目數量不正確: 期望 {len(test_data['data'])}, 實際 {len(restored_data['data'])}"
+                )
+
             # 7. 清理 S3 中的測試檔案
             s3_client.delete_object(Bucket=bucket_name, Key=s3_key)
             logger.info("清理 S3 中的測試檔案")
-            
+
             duration = (datetime.now() - start_time).total_seconds()
             return TestResult(
                 test_name=test_name,
@@ -382,11 +409,11 @@ class BackupRecoveryTester:
                 duration=duration,
                 message=f"成功通過 S3 備份和恢復檔案",
                 details={
-                    'file_size': restored_file.stat().st_size,
-                    'data_items': len(restored_data['data'])
-                }
+                    "file_size": restored_file.stat().st_size,
+                    "data_items": len(restored_data["data"]),
+                },
             )
-            
+
         except Exception as e:
             duration = (datetime.now() - start_time).total_seconds()
             logger.error(f"S3 備份恢復測試失敗: {e}")
@@ -394,12 +421,14 @@ class BackupRecoveryTester:
                 test_name=test_name,
                 success=False,
                 duration=duration,
-                message=str(e)
+                message=str(e),
             )
 
-    async def _create_test_data(self, table_name: str, data: List[Tuple]) -> None:
+    async def _create_test_data(
+        self, table_name: str, data: List[Tuple]
+    ) -> None:
         """創建測試資料"""
-        conn = psycopg2.connect(**self.config['postgres'])
+        conn = psycopg2.connect(**self.config["postgres"])
         try:
             with conn.cursor() as cur:
                 # 創建測試表
@@ -411,21 +440,21 @@ class BackupRecoveryTester:
                         created_date DATE
                     )
                 """)
-                
+
                 # 插入測試資料
                 for row in data:
                     cur.execute(
                         f"INSERT INTO {table_name} (name, email, created_date) VALUES (%s, %s, %s)",
-                        row
+                        row,
                     )
-                
+
                 conn.commit()
         finally:
             conn.close()
 
     async def _delete_test_data(self, table_name: str) -> None:
         """刪除測試資料"""
-        conn = psycopg2.connect(**self.config['postgres'])
+        conn = psycopg2.connect(**self.config["postgres"])
         try:
             with conn.cursor() as cur:
                 cur.execute(f"DROP TABLE IF EXISTS {table_name}")
@@ -435,7 +464,7 @@ class BackupRecoveryTester:
 
     async def _count_test_data(self, table_name: str) -> int:
         """計算測試資料數量"""
-        conn = psycopg2.connect(**self.config['postgres'])
+        conn = psycopg2.connect(**self.config["postgres"])
         try:
             with conn.cursor() as cur:
                 cur.execute(f"SELECT COUNT(*) FROM {table_name}")
@@ -447,10 +476,12 @@ class BackupRecoveryTester:
 
     async def _get_test_data(self, table_name: str) -> List[Tuple]:
         """獲取測試資料"""
-        conn = psycopg2.connect(**self.config['postgres'])
+        conn = psycopg2.connect(**self.config["postgres"])
         try:
             with conn.cursor() as cur:
-                cur.execute(f"SELECT name, email, created_date FROM {table_name}")
+                cur.execute(
+                    f"SELECT name, email, created_date FROM {table_name}"
+                )
                 return cur.fetchall()
         except psycopg2.Error:
             return []
@@ -467,12 +498,12 @@ class BackupRecoveryTester:
                 f"--username={self.config['postgres']['user']}",
                 f"--dbname={self.config['postgres']['database']}",
                 "--no-password",
-                "--format=custom"
+                "--format=custom",
             ]
-            
+
             env = os.environ.copy()
-            env["PGPASSWORD"] = self.config['postgres']['password']
-            
+            env["PGPASSWORD"] = self.config["postgres"]["password"]
+
             with gzip.open(backup_file, "wt") as f:
                 result = subprocess.run(
                     cmd,
@@ -480,11 +511,11 @@ class BackupRecoveryTester:
                     stderr=subprocess.PIPE,
                     env=env,
                     check=True,
-                    text=True
+                    text=True,
                 )
-            
+
             return backup_file.exists() and backup_file.stat().st_size > 0
-            
+
         except subprocess.CalledProcessError as e:
             logger.error(f"資料庫備份失敗: {e.stderr}")
             return False
@@ -499,36 +530,40 @@ class BackupRecoveryTester:
                     f"--port={self.config['postgres']['port']}",
                     f"--username={self.config['postgres']['user']}",
                     f"--dbname={self.config['postgres']['database']}",
-                    "--no-password"
+                    "--no-password",
                 ]
-                
+
                 env = os.environ.copy()
-                env["PGPASSWORD"] = self.config['postgres']['password']
-                
+                env["PGPASSWORD"] = self.config["postgres"]["password"]
+
                 result = subprocess.run(
                     cmd,
                     stdin=f,
                     stderr=subprocess.PIPE,
                     env=env,
                     check=True,
-                    text=True
+                    text=True,
                 )
-            
+
             return True
-            
+
         except subprocess.CalledProcessError as e:
             logger.error(f"資料庫恢復失敗: {e.stderr}")
             return False
 
-    async def _manual_redis_backup(self, redis_client, backup_file: Path) -> None:
+    async def _manual_redis_backup(
+        self, redis_client, backup_file: Path
+    ) -> None:
         """手動 Redis 備份"""
         backup_data = {}
         for key in redis_client.scan_iter("test:backup:*"):
             backup_data[key] = redis_client.get(key)
-        
-        backup_file.write_text(json.dumps(backup_data), encoding='utf-8')
 
-    async def _restore_redis_data(self, redis_client, test_keys: Dict[str, str]) -> None:
+        backup_file.write_text(json.dumps(backup_data), encoding="utf-8")
+
+    async def _restore_redis_data(
+        self, redis_client, test_keys: Dict[str, str]
+    ) -> None:
         """恢復 Redis 資料"""
         for key, value in test_keys.items():
             redis_client.set(key, value)
@@ -537,58 +572,62 @@ class BackupRecoveryTester:
         """執行所有備份恢復測試"""
         logger.info("開始執行備份恢復測試套件")
         start_time = datetime.now()
-        
+
         try:
             # 執行所有測試
             tests = [
                 self.test_database_backup_restore(),
                 self.test_redis_backup_restore(),
                 self.test_file_backup_restore(),
-                self.test_s3_backup_restore()
+                self.test_s3_backup_restore(),
             ]
-            
-            self.test_results = await asyncio.gather(*tests, return_exceptions=True)
-            
+
+            self.test_results = await asyncio.gather(
+                *tests, return_exceptions=True
+            )
+
             # 處理異常結果
             for i, result in enumerate(self.test_results):
                 if isinstance(result, Exception):
                     self.test_results[i] = TestResult(
-                        test_name=f"測試 {i+1}",
+                        test_name=f"測試 {i + 1}",
                         success=False,
                         duration=0,
-                        message=str(result)
+                        message=str(result),
                     )
-            
+
             # 生成測試報告
             total_tests = len(self.test_results)
             passed_tests = sum(1 for r in self.test_results if r.success)
             failed_tests = total_tests - passed_tests
             total_duration = (datetime.now() - start_time).total_seconds()
-            
+
             report = {
-                'summary': {
-                    'total_tests': total_tests,
-                    'passed': passed_tests,
-                    'failed': failed_tests,
-                    'success_rate': (passed_tests / total_tests) * 100 if total_tests > 0 else 0,
-                    'total_duration': total_duration,
-                    'timestamp': datetime.now().isoformat()
+                "summary": {
+                    "total_tests": total_tests,
+                    "passed": passed_tests,
+                    "failed": failed_tests,
+                    "success_rate": (passed_tests / total_tests) * 100
+                    if total_tests > 0
+                    else 0,
+                    "total_duration": total_duration,
+                    "timestamp": datetime.now().isoformat(),
                 },
-                'results': [
+                "results": [
                     {
-                        'test_name': r.test_name,
-                        'success': r.success,
-                        'duration': r.duration,
-                        'message': r.message,
-                        'details': r.details
+                        "test_name": r.test_name,
+                        "success": r.success,
+                        "duration": r.duration,
+                        "message": r.message,
+                        "details": r.details,
                     }
                     for r in self.test_results
-                ]
+                ],
             }
-            
+
             logger.info(f"測試完成: {passed_tests}/{total_tests} 通過")
             return report
-            
+
         finally:
             # 清理臨時文件
             if self.temp_dir.exists():
@@ -597,34 +636,34 @@ class BackupRecoveryTester:
 
     def generate_report(self, report: Dict[str, Any]) -> str:
         """生成人類可讀的測試報告"""
-        summary = report['summary']
-        
+        summary = report["summary"]
+
         report_text = f"""
 =================================================
 備份恢復測試報告
 =================================================
-測試時間: {summary['timestamp']}
-總測試數: {summary['total_tests']}
-通過測試: {summary['passed']}
-失敗測試: {summary['failed']}
-成功率: {summary['success_rate']:.1f}%
-總耗時: {summary['total_duration']:.2f} 秒
+測試時間: {summary["timestamp"]}
+總測試數: {summary["total_tests"]}
+通過測試: {summary["passed"]}
+失敗測試: {summary["failed"]}
+成功率: {summary["success_rate"]:.1f}%
+總耗時: {summary["total_duration"]:.2f} 秒
 
 詳細結果:
 -------------------------------------------------
 """
-        
-        for result in report['results']:
-            status = "✅ 通過" if result['success'] else "❌ 失敗"
+
+        for result in report["results"]:
+            status = "✅ 通過" if result["success"] else "❌ 失敗"
             report_text += f"""
-{status} {result['test_name']}
-   耗時: {result['duration']:.2f} 秒
-   訊息: {result['message']}
+{status} {result["test_name"]}
+   耗時: {result["duration"]:.2f} 秒
+   訊息: {result["message"]}
 """
-            if result['details']:
-                for key, value in result['details'].items():
+            if result["details"]:
+                for key, value in result["details"].items():
                     report_text += f"   {key}: {value}\n"
-        
+
         report_text += "\n================================================="
         return report_text
 
@@ -632,30 +671,32 @@ class BackupRecoveryTester:
 async def main():
     """主函數"""
     tester = BackupRecoveryTester()
-    
+
     try:
         logger.info("開始備份恢復測試")
         report = await tester.run_all_tests()
-        
+
         # 輸出報告
         print(tester.generate_report(report))
-        
+
         # 保存 JSON 報告
         report_file = Path("backup_recovery_test_report.json")
-        report_file.write_text(json.dumps(report, indent=2, ensure_ascii=False))
+        report_file.write_text(
+            json.dumps(report, indent=2, ensure_ascii=False)
+        )
         logger.info(f"詳細報告已保存到: {report_file}")
-        
+
         # 返回適當的退出碼
-        if report['summary']['failed'] > 0:
+        if report["summary"]["failed"] > 0:
             exit(1)
         else:
             logger.info("所有備份恢復測試通過!")
             exit(0)
-            
+
     except Exception as e:
         logger.error(f"測試執行失敗: {e}")
         exit(1)
 
 
 if __name__ == "__main__":
-    asyncio.run(main())
\ No newline at end of file
+    asyncio.run(main())
diff --git a/auto_generate_video_fold6/scripts/validate_backup_config.py b/auto_generate_video_fold6/scripts/validate_backup_config.py
index 73e1af2..b93b5a2 100644
--- a/auto_generate_video_fold6/scripts/validate_backup_config.py
+++ b/auto_generate_video_fold6/scripts/validate_backup_config.py
@@ -14,8 +14,7 @@ from dataclasses import dataclass
 
 # 設置日誌
 logging.basicConfig(
-    level=logging.INFO,
-    format='%(asctime)s - %(levelname)s - %(message)s'
+    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
 )
 logger = logging.getLogger(__name__)
 
@@ -23,6 +22,7 @@ logger = logging.getLogger(__name__)
 @dataclass
 class ValidationResult:
     """驗證結果"""
+
     component: str
     success: bool
     message: str
@@ -31,11 +31,11 @@ class ValidationResult:
 
 class BackupConfigValidator:
     """備份配置驗證器"""
-    
+
     def __init__(self):
         self.results: List[ValidationResult] = []
         self.project_root = Path(__file__).parent.parent
-    
+
     def validate_backup_scripts(self) -> ValidationResult:
         """驗證備份腳本存在性和可執行性"""
         try:
@@ -43,47 +43,47 @@ class BackupConfigValidator:
                 "scripts/backup_manager.py",
                 "scripts/backup-system.sh",
                 "scripts/restore-system.sh",
-                "scripts/disaster_recovery.py"
+                "scripts/disaster_recovery.py",
             ]
-            
+
             missing_scripts = []
             non_executable = []
-            
+
             for script_path in backup_scripts:
                 full_path = self.project_root / script_path
                 if not full_path.exists():
                     missing_scripts.append(script_path)
                 elif not os.access(full_path, os.X_OK):
                     non_executable.append(script_path)
-            
+
             if missing_scripts:
                 return ValidationResult(
                     component="備份腳本",
                     success=False,
-                    message=f"缺少備份腳本: {', '.join(missing_scripts)}"
+                    message=f"缺少備份腳本: {', '.join(missing_scripts)}",
                 )
-            
+
             if non_executable:
                 return ValidationResult(
                     component="備份腳本",
                     success=False,
-                    message=f"腳本不可執行: {', '.join(non_executable)}"
+                    message=f"腳本不可執行: {', '.join(non_executable)}",
                 )
-            
+
             return ValidationResult(
                 component="備份腳本",
                 success=True,
                 message="所有備份腳本都存在且可執行",
-                details={"scripts": backup_scripts}
+                details={"scripts": backup_scripts},
             )
-            
+
         except Exception as e:
             return ValidationResult(
                 component="備份腳本",
                 success=False,
-                message=f"驗證失敗: {str(e)}"
+                message=f"驗證失敗: {str(e)}",
             )
-    
+
     def validate_backup_dependencies(self) -> ValidationResult:
         """驗證備份所需的系統依賴"""
         try:
@@ -92,141 +92,165 @@ class BackupConfigValidator:
                 ("psql", "PostgreSQL 客戶端"),
                 ("tar", "檔案歸檔工具"),
                 ("gzip", "壓縮工具"),
-                ("docker", "容器管理工具")
+                ("docker", "容器管理工具"),
             ]
-            
+
             missing_deps = []
             available_deps = []
-            
+
             for cmd, description in required_commands:
                 try:
                     result = subprocess.run(
                         [cmd, "--version"],
                         capture_output=True,
                         check=True,
-                        timeout=10
+                        timeout=10,
                     )
                     available_deps.append((cmd, description))
-                except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
+                except (
+                    subprocess.CalledProcessError,
+                    FileNotFoundError,
+                    subprocess.TimeoutExpired,
+                ):
                     missing_deps.append((cmd, description))
-            
+
             if missing_deps:
                 return ValidationResult(
                     component="系統依賴",
                     success=False,
                     message=f"缺少必要工具: {', '.join([cmd for cmd, _ in missing_deps])}",
-                    details={"missing": [{"command": cmd, "description": desc} for cmd, desc in missing_deps]}
+                    details={
+                        "missing": [
+                            {"command": cmd, "description": desc}
+                            for cmd, desc in missing_deps
+                        ]
+                    },
                 )
-            
+
             return ValidationResult(
                 component="系統依賴",
                 success=True,
                 message="所有必要的系統工具都可用",
-                details={"available": [{"command": cmd, "description": desc} for cmd, desc in available_deps]}
+                details={
+                    "available": [
+                        {"command": cmd, "description": desc}
+                        for cmd, desc in available_deps
+                    ]
+                },
             )
-            
+
         except Exception as e:
             return ValidationResult(
                 component="系統依賴",
                 success=False,
-                message=f"驗證失敗: {str(e)}"
+                message=f"驗證失敗: {str(e)}",
             )
-    
+
     def validate_backup_configuration(self) -> ValidationResult:
         """驗證備份配置文件"""
         try:
             config_files = [
                 "config/backup-config.json",
                 "config/disaster-recovery-config.json",
-                "scripts/backup/config.yaml"
+                "scripts/backup/config.yaml",
             ]
-            
+
             validation_issues = []
             valid_configs = []
-            
+
             for config_path in config_files:
                 full_path = self.project_root / config_path
                 if not full_path.exists():
                     validation_issues.append(f"配置文件不存在: {config_path}")
                     continue
-                
+
                 try:
-                    if config_path.endswith('.json'):
-                        with open(full_path, 'r', encoding='utf-8') as f:
+                    if config_path.endswith(".json"):
+                        with open(full_path, "r", encoding="utf-8") as f:
                             config_data = json.load(f)
-                    elif config_path.endswith('.yaml') or config_path.endswith('.yml'):
+                    elif config_path.endswith(".yaml") or config_path.endswith(
+                        ".yml"
+                    ):
                         # 簡單驗證 YAML 文件格式
-                        with open(full_path, 'r', encoding='utf-8') as f:
+                        with open(full_path, "r", encoding="utf-8") as f:
                             content = f.read()
                             if not content.strip():
-                                validation_issues.append(f"配置文件為空: {config_path}")
+                                validation_issues.append(
+                                    f"配置文件為空: {config_path}"
+                                )
                                 continue
-                    
+
                     valid_configs.append(config_path)
-                    
+
                 except json.JSONDecodeError as e:
-                    validation_issues.append(f"JSON 格式錯誤 {config_path}: {str(e)}")
+                    validation_issues.append(
+                        f"JSON 格式錯誤 {config_path}: {str(e)}"
+                    )
                 except Exception as e:
-                    validation_issues.append(f"配置文件讀取失敗 {config_path}: {str(e)}")
-            
+                    validation_issues.append(
+                        f"配置文件讀取失敗 {config_path}: {str(e)}"
+                    )
+
             if validation_issues:
                 return ValidationResult(
                     component="備份配置",
                     success=False,
                     message=f"配置驗證失敗: {'; '.join(validation_issues)}",
-                    details={"issues": validation_issues, "valid_configs": valid_configs}
+                    details={
+                        "issues": validation_issues,
+                        "valid_configs": valid_configs,
+                    },
                 )
-            
+
             return ValidationResult(
                 component="備份配置",
                 success=True,
                 message="所有備份配置文件格式正確",
-                details={"valid_configs": valid_configs}
+                details={"valid_configs": valid_configs},
             )
-            
+
         except Exception as e:
             return ValidationResult(
                 component="備份配置",
                 success=False,
-                message=f"驗證失敗: {str(e)}"
+                message=f"驗證失敗: {str(e)}",
             )
-    
+
     def validate_backup_directories(self) -> ValidationResult:
         """驗證備份目錄結構"""
         try:
-            required_dirs = [
-                "scripts/backup",
-                "monitoring/backup",
-                "config"
-            ]
-            
+            required_dirs = ["scripts/backup", "monitoring/backup", "config"]
+
             missing_dirs = []
             existing_dirs = []
-            
+
             for dir_path in required_dirs:
                 full_path = self.project_root / dir_path
                 if not full_path.exists() or not full_path.is_dir():
                     missing_dirs.append(dir_path)
                 else:
                     existing_dirs.append(dir_path)
-            
+
             # 檢查臨時備份目錄權限
             temp_backup_dirs = ["/tmp/backups", "/var/backups", "/opt/backups"]
             writable_temp_dirs = []
-            
+
             for temp_dir in temp_backup_dirs:
                 temp_path = Path(temp_dir)
                 if temp_path.exists() and os.access(temp_path, os.W_OK):
                     writable_temp_dirs.append(temp_dir)
-            
+
             if missing_dirs and not writable_temp_dirs:
                 return ValidationResult(
                     component="備份目錄",
                     success=False,
                     message=f"缺少必要目錄: {', '.join(missing_dirs)}，且沒有可寫的臨時備份目錄",
-                    details={"missing_dirs": missing_dirs, "temp_dirs_checked": temp_backup_dirs}
+                    details={
+                        "missing_dirs": missing_dirs,
+                        "temp_dirs_checked": temp_backup_dirs,
+                    },
                 )
-            
+
             return ValidationResult(
                 component="備份目錄",
                 success=True,
@@ -234,35 +258,35 @@ class BackupConfigValidator:
                 details={
                     "existing_dirs": existing_dirs,
                     "missing_dirs": missing_dirs,
-                    "writable_temp_dirs": writable_temp_dirs
-                }
+                    "writable_temp_dirs": writable_temp_dirs,
+                },
             )
-            
+
         except Exception as e:
             return ValidationResult(
                 component="備份目錄",
                 success=False,
-                message=f"驗證失敗: {str(e)}"
+                message=f"驗證失敗: {str(e)}",
             )
-    
+
     def validate_docker_compose_backup_config(self) -> ValidationResult:
         """驗證 Docker Compose 中的備份相關配置"""
         try:
             docker_compose_files = [
                 "docker-compose.yml",
-                "docker/docker-compose.prod.yml"
+                "docker/docker-compose.prod.yml",
             ]
-            
+
             backup_volume_configs = []
             missing_configs = []
-            
+
             for compose_file in docker_compose_files:
                 full_path = self.project_root / compose_file
                 if not full_path.exists():
                     continue
-                
-                content = full_path.read_text(encoding='utf-8')
-                
+
+                content = full_path.read_text(encoding="utf-8")
+
                 # 檢查是否有備份相關的卷配置
                 backup_indicators = [
                     "postgres_data:",
@@ -270,43 +294,42 @@ class BackupConfigValidator:
                     "minio_data:",
                     "backup:",
                     "/var/backups",
-                    "/opt/backups"
+                    "/opt/backups",
                 ]
-                
+
                 found_configs = []
                 for indicator in backup_indicators:
                     if indicator in content:
                         found_configs.append(indicator)
-                
+
                 if found_configs:
-                    backup_volume_configs.append({
-                        "file": compose_file,
-                        "configs": found_configs
-                    })
+                    backup_volume_configs.append(
+                        {"file": compose_file, "configs": found_configs}
+                    )
                 else:
                     missing_configs.append(compose_file)
-            
+
             if not backup_volume_configs:
                 return ValidationResult(
                     component="Docker 備份配置",
                     success=False,
-                    message="Docker Compose 文件中缺少備份相關配置"
+                    message="Docker Compose 文件中缺少備份相關配置",
                 )
-            
+
             return ValidationResult(
                 component="Docker 備份配置",
                 success=True,
                 message="Docker Compose 備份配置正確",
-                details={"backup_configs": backup_volume_configs}
+                details={"backup_configs": backup_volume_configs},
             )
-            
+
         except Exception as e:
             return ValidationResult(
                 component="Docker 備份配置",
                 success=False,
-                message=f"驗證失敗: {str(e)}"
+                message=f"驗證失敗: {str(e)}",
             )
-    
+
     def validate_environment_variables(self) -> ValidationResult:
         """驗證備份相關的環境變數"""
         try:
@@ -318,37 +341,45 @@ class BackupConfigValidator:
                 "DATABASE_URL",
                 "REDIS_URL",
                 "S3_ACCESS_KEY_ID",
-                "S3_SECRET_ACCESS_KEY"
+                "S3_SECRET_ACCESS_KEY",
             ]
-            
+
             missing_vars = []
             configured_vars = []
-            
+
             for var_name in backup_env_vars:
                 if os.getenv(var_name):
                     configured_vars.append(var_name)
                 else:
                     missing_vars.append(var_name)
-            
+
             # 檢查 .env.example 文件中是否包含這些變數
             env_example_files = [
                 ".env.example",
-                "auto_generate_video_fold6/.env.example"
+                "auto_generate_video_fold6/.env.example",
             ]
-            
+
             documented_vars = []
             for env_file in env_example_files:
-                env_path = self.project_root / env_file if not env_file.startswith('auto_generate_video_fold6') else self.project_root.parent / env_file
+                env_path = (
+                    self.project_root / env_file
+                    if not env_file.startswith("auto_generate_video_fold6")
+                    else self.project_root.parent / env_file
+                )
                 if env_path.exists():
-                    content = env_path.read_text(encoding='utf-8')
+                    content = env_path.read_text(encoding="utf-8")
                     for var_name in backup_env_vars:
                         if var_name in content:
                             documented_vars.append(var_name)
-            
-            undocumented_vars = [var for var in backup_env_vars if var not in documented_vars]
-            
-            success = len(missing_vars) <= len(backup_env_vars) * 0.5  # 允許最多 50% 的變數未設置
-            
+
+            undocumented_vars = [
+                var for var in backup_env_vars if var not in documented_vars
+            ]
+
+            success = (
+                len(missing_vars) <= len(backup_env_vars) * 0.5
+            )  # 允許最多 50% 的變數未設置
+
             return ValidationResult(
                 component="環境變數",
                 success=success,
@@ -357,104 +388,110 @@ class BackupConfigValidator:
                     "configured": configured_vars,
                     "missing": missing_vars,
                     "documented": documented_vars,
-                    "undocumented": undocumented_vars
-                }
+                    "undocumented": undocumented_vars,
+                },
             )
-            
+
         except Exception as e:
             return ValidationResult(
                 component="環境變數",
                 success=False,
-                message=f"驗證失敗: {str(e)}"
+                message=f"驗證失敗: {str(e)}",
             )
-    
+
     def run_validation(self) -> Dict:
         """執行所有驗證"""
         logger.info("開始備份配置驗證")
-        
+
         validators = [
             self.validate_backup_scripts,
             self.validate_backup_dependencies,
             self.validate_backup_configuration,
             self.validate_backup_directories,
             self.validate_docker_compose_backup_config,
-            self.validate_environment_variables
+            self.validate_environment_variables,
         ]
-        
+
         self.results = []
         for validator in validators:
             try:
                 result = validator()
                 self.results.append(result)
-                
+
                 status = "✅" if result.success else "❌"
                 logger.info(f"{status} {result.component}: {result.message}")
-                
+
             except Exception as e:
                 error_result = ValidationResult(
                     component=validator.__name__,
                     success=False,
-                    message=f"驗證器執行失敗: {str(e)}"
+                    message=f"驗證器執行失敗: {str(e)}",
                 )
                 self.results.append(error_result)
-                logger.error(f"❌ {error_result.component}: {error_result.message}")
-        
+                logger.error(
+                    f"❌ {error_result.component}: {error_result.message}"
+                )
+
         # 生成總結報告
         total_tests = len(self.results)
         passed_tests = sum(1 for r in self.results if r.success)
         failed_tests = total_tests - passed_tests
-        
+
         report = {
             "summary": {
                 "total_validations": total_tests,
                 "passed": passed_tests,
                 "failed": failed_tests,
-                "success_rate": (passed_tests / total_tests) * 100 if total_tests > 0 else 0
+                "success_rate": (passed_tests / total_tests) * 100
+                if total_tests > 0
+                else 0,
             },
             "results": [
                 {
                     "component": r.component,
                     "success": r.success,
                     "message": r.message,
-                    "details": r.details
+                    "details": r.details,
                 }
                 for r in self.results
-            ]
+            ],
         }
-        
-        logger.info(f"驗證完成: {passed_tests}/{total_tests} 通過 ({report['summary']['success_rate']:.1f}%)")
+
+        logger.info(
+            f"驗證完成: {passed_tests}/{total_tests} 通過 ({report['summary']['success_rate']:.1f}%)"
+        )
         return report
-    
+
     def generate_report(self, report: Dict) -> str:
         """生成人類可讀的驗證報告"""
-        summary = report['summary']
-        
+        summary = report["summary"]
+
         report_text = f"""
 =================================================
 備份配置驗證報告
 =================================================
-總驗證項: {summary['total_validations']}
-通過項目: {summary['passed']}
-失敗項目: {summary['failed']}
-成功率: {summary['success_rate']:.1f}%
+總驗證項: {summary["total_validations"]}
+通過項目: {summary["passed"]}
+失敗項目: {summary["failed"]}
+成功率: {summary["success_rate"]:.1f}%
 
 詳細結果:
 -------------------------------------------------
 """
-        
-        for result in report['results']:
-            status = "✅ 通過" if result['success'] else "❌ 失敗"
+
+        for result in report["results"]:
+            status = "✅ 通過" if result["success"] else "❌ 失敗"
             report_text += f"""
-{status} {result['component']}
-   訊息: {result['message']}
+{status} {result["component"]}
+   訊息: {result["message"]}
 """
-            if result['details']:
-                for key, value in result['details'].items():
+            if result["details"]:
+                for key, value in result["details"].items():
                     if isinstance(value, list):
                         report_text += f"   {key}: {len(value)} 項\n"
                     else:
                         report_text += f"   {key}: {value}\n"
-        
+
         report_text += "\n================================================="
         return report_text
 
@@ -462,30 +499,32 @@ class BackupConfigValidator:
 def main():
     """主函數"""
     validator = BackupConfigValidator()
-    
+
     try:
         report = validator.run_validation()
-        
+
         # 輸出報告
         print(validator.generate_report(report))
-        
+
         # 保存 JSON 報告
         report_file = Path("backup_config_validation_report.json")
-        report_file.write_text(json.dumps(report, indent=2, ensure_ascii=False))
+        report_file.write_text(
+            json.dumps(report, indent=2, ensure_ascii=False)
+        )
         logger.info(f"詳細報告已保存到: {report_file}")
-        
+
         # 返回適當的退出碼
-        if report['summary']['failed'] > 0:
+        if report["summary"]["failed"] > 0:
             logger.warning("某些備份配置驗證失敗，建議檢查並修復")
             exit(1)
         else:
             logger.info("所有備份配置驗證通過!")
             exit(0)
-            
+
     except Exception as e:
         logger.error(f"驗證執行失敗: {e}")
         exit(1)
 
 
 if __name__ == "__main__":
-    main()
\ No newline at end of file
+    main()
diff --git a/auto_generate_video_fold6/security/generate_security_report.py b/auto_generate_video_fold6/security/generate_security_report.py
index c893f1b..b475afe 100644
--- a/auto_generate_video_fold6/security/generate_security_report.py
+++ b/auto_generate_video_fold6/security/generate_security_report.py
@@ -22,7 +22,13 @@ class SecurityReportGenerator:
 
     def __init__(self):
         self.findings = []
-        self.summary = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "UNKNOWN": 0}
+        self.summary = {
+            "CRITICAL": 0,
+            "HIGH": 0,
+            "MEDIUM": 0,
+            "LOW": 0,
+            "UNKNOWN": 0,
+        }
         self.scanner_results = {}
 
     def process_bandit_report(self, file_path: str):
@@ -35,7 +41,9 @@ class SecurityReportGenerator:
                 finding = {
                     "id": f"bandit_{result.get('test_id')}_{result.get('line_number')}",
                     "scanner": "bandit",
-                    "severity": result.get("issue_severity", "UNKNOWN").upper(),
+                    "severity": result.get(
+                        "issue_severity", "UNKNOWN"
+                    ).upper(),
                     "confidence": result.get("issue_confidence", "UNKNOWN"),
                     "title": result.get("issue_text", ""),
                     "description": result.get("issue_text", ""),
@@ -98,7 +106,11 @@ class SecurityReportGenerator:
                 data = json.load(f)
 
             # Safety 報告可能是列表格式
-            vulnerabilities = data if isinstance(data, list) else data.get("vulnerabilities", [])
+            vulnerabilities = (
+                data
+                if isinstance(data, list)
+                else data.get("vulnerabilities", [])
+            )
 
             for vuln in vulnerabilities:
                 finding = {
@@ -148,7 +160,9 @@ class SecurityReportGenerator:
                     "line_number": 0,
                     "rule_id": vuln_id,
                     "remediation": f"Update to version {vuln.get('fixAvailable', {}).get('version', 'latest')}",
-                    "cve_id": vuln.get("cves", [None])[0] if vuln.get("cves") else None,
+                    "cve_id": vuln.get("cves", [None])[0]
+                    if vuln.get("cves")
+                    else None,
                     "created_at": datetime.now().isoformat(),
                 }
                 self.findings.append(finding)
@@ -160,7 +174,9 @@ class SecurityReportGenerator:
             }
 
         except Exception as e:
-            logger.error(f"Failed to process npm audit report {file_path}: {e}")
+            logger.error(
+                f"Failed to process npm audit report {file_path}: {e}"
+            )
 
     def process_trivy_report(self, file_path: str):
         """處理 Trivy 報告"""
@@ -214,12 +230,16 @@ class SecurityReportGenerator:
                     finding = {
                         "id": f"trivy_config_{misconfig.get('ID')}_{misconfig.get('CauseMetadata', {}).get('StartLine', 0)}",
                         "scanner": "trivy_config",
-                        "severity": misconfig.get("Severity", "UNKNOWN").upper(),
+                        "severity": misconfig.get(
+                            "Severity", "UNKNOWN"
+                        ).upper(),
                         "confidence": "HIGH",
                         "title": f"Configuration issue: {misconfig.get('Title', '')}",
                         "description": misconfig.get("Description", ""),
                         "file_path": result.get("Target", ""),
-                        "line_number": misconfig.get("CauseMetadata", {}).get("StartLine", 0),
+                        "line_number": misconfig.get("CauseMetadata", {}).get(
+                            "StartLine", 0
+                        ),
                         "rule_id": misconfig.get("ID", ""),
                         "remediation": misconfig.get("Resolution", ""),
                         "created_at": datetime.now().isoformat(),
@@ -261,8 +281,12 @@ class SecurityReportGenerator:
                     line_number = 0
 
                     if locations:
-                        physical_location = locations[0].get("physicalLocation", {})
-                        artifact_location = physical_location.get("artifactLocation", {})
+                        physical_location = locations[0].get(
+                            "physicalLocation", {}
+                        )
+                        artifact_location = physical_location.get(
+                            "artifactLocation", {}
+                        )
                         file_path = artifact_location.get("uri", "")
 
                         region = physical_location.get("region", {})
@@ -289,7 +313,9 @@ class SecurityReportGenerator:
                     self._update_summary(finding["severity"])
 
             self.scanner_results[scanner_name] = {
-                "total_findings": sum(len(run.get("results", [])) for run in runs),
+                "total_findings": sum(
+                    len(run.get("results", [])) for run in runs
+                ),
                 "status": "completed",
             }
 
@@ -314,7 +340,9 @@ class SecurityReportGenerator:
                         logger.info(f"Processing Bandit report: {file_path}")
                         self.process_bandit_report(str(file_path))
 
-                    elif "semgrep" in file_name and file_name.endswith(".json"):
+                    elif "semgrep" in file_name and file_name.endswith(
+                        ".json"
+                    ):
                         logger.info(f"Processing Semgrep report: {file_path}")
                         self.process_semgrep_report(str(file_path))
 
@@ -322,8 +350,12 @@ class SecurityReportGenerator:
                         logger.info(f"Processing Safety report: {file_path}")
                         self.process_safety_report(str(file_path))
 
-                    elif "npm-audit" in file_name and file_name.endswith(".json"):
-                        logger.info(f"Processing npm audit report: {file_path}")
+                    elif "npm-audit" in file_name and file_name.endswith(
+                        ".json"
+                    ):
+                        logger.info(
+                            f"Processing npm audit report: {file_path}"
+                        )
                         self.process_npm_audit_report(str(file_path))
 
                     elif "trivy" in file_name and file_name.endswith(".json"):
@@ -331,7 +363,9 @@ class SecurityReportGenerator:
                         self.process_trivy_report(str(file_path))
 
                     elif file_name.endswith(".sarif"):
-                        scanner_name = self._extract_scanner_name_from_sarif(file_name)
+                        scanner_name = self._extract_scanner_name_from_sarif(
+                            file_name
+                        )
                         logger.info(
                             f"Processing SARIF report: {file_path} (scanner: {scanner_name})"
                         )
@@ -357,7 +391,12 @@ class SecurityReportGenerator:
 
         return report
 
-    def save_report(self, report: Dict[str, Any], output_path: str, format_type: str = "json"):
+    def save_report(
+        self,
+        report: Dict[str, Any],
+        output_path: str,
+        format_type: str = "json",
+    ):
         """儲存報告到檔案"""
         output_file = Path(output_path)
         output_file.parent.mkdir(parents=True, exist_ok=True)
@@ -392,7 +431,12 @@ class SecurityReportGenerator:
 
     def _map_sarif_severity(self, level: str) -> str:
         """映射 SARIF 嚴重程度"""
-        mapping = {"error": "HIGH", "warning": "MEDIUM", "note": "LOW", "info": "LOW"}
+        mapping = {
+            "error": "HIGH",
+            "warning": "MEDIUM",
+            "note": "LOW",
+            "info": "LOW",
+        }
         return mapping.get(level.lower(), "UNKNOWN")
 
     def _extract_scanner_name_from_sarif(self, file_name: str) -> str:
@@ -416,7 +460,9 @@ class SecurityReportGenerator:
         high_count = self.summary.get("HIGH", 0)
 
         if critical_count > 0:
-            recommendations.append(f"🚨 立即修復 {critical_count} 個關鍵安全問題")
+            recommendations.append(
+                f"🚨 立即修復 {critical_count} 個關鍵安全問題"
+            )
 
         if high_count > 0:
             recommendations.append(f"⚠️ 優先修復 {high_count} 個高風險安全問題")
@@ -427,7 +473,10 @@ class SecurityReportGenerator:
             scanner = finding["scanner"]
             scanner_counts[scanner] = scanner_counts.get(scanner, 0) + 1
 
-        if scanner_counts.get("trivy_secrets", 0) > 0 or scanner_counts.get("gitleaks", 0) > 0:
+        if (
+            scanner_counts.get("trivy_secrets", 0) > 0
+            or scanner_counts.get("gitleaks", 0) > 0
+        ):
             recommendations.append("🔑 檢查並移除程式碼中的硬編碼密鑰")
 
         if scanner_counts.get("bandit", 0) > 0:
@@ -477,7 +526,11 @@ class SecurityReportGenerator:
             "critical_findings": critical_count,
             "high_findings": high_count,
             "remediation_priority": (
-                "immediate" if critical_count > 0 else "high" if high_count > 0 else "normal"
+                "immediate"
+                if critical_count > 0
+                else "high"
+                if high_count > 0
+                else "normal"
             ),
         }
 
@@ -485,24 +538,24 @@ class SecurityReportGenerator:
         """生成 Markdown 格式報告"""
         markdown = f"""# Security Scan Report
 
-**Generated:** {report['metadata']['generated_at']}  
-**Total Scanners:** {report['metadata']['total_scanners']}  
-**Total Findings:** {report['metadata']['total_findings']}
+**Generated:** {report["metadata"]["generated_at"]}  
+**Total Scanners:** {report["metadata"]["total_scanners"]}  
+**Total Findings:** {report["metadata"]["total_findings"]}
 
 ## Summary
 
 | Severity | Count |
 |----------|-------|
-| Critical | {report['summary']['CRITICAL']} |
-| High     | {report['summary']['HIGH']} |
-| Medium   | {report['summary']['MEDIUM']} |
-| Low      | {report['summary']['LOW']} |
+| Critical | {report["summary"]["CRITICAL"]} |
+| High     | {report["summary"]["HIGH"]} |
+| Medium   | {report["summary"]["MEDIUM"]} |
+| Low      | {report["summary"]["LOW"]} |
 
 ## Risk Assessment
 
-**Risk Level:** {report['risk_assessment']['risk_level']}  
-**Risk Score:** {report['risk_assessment']['risk_score']}/10  
-**Remediation Priority:** {report['risk_assessment']['remediation_priority']}
+**Risk Level:** {report["risk_assessment"]["risk_level"]}  
+**Risk Score:** {report["risk_assessment"]["risk_score"]}/10  
+**Remediation Priority:** {report["risk_assessment"]["remediation_priority"]}
 
 ## Recommendations
 
@@ -514,24 +567,28 @@ class SecurityReportGenerator:
         markdown += "\n## Scanner Results\n\n"
 
         for scanner, result in report["scanner_results"].items():
-            markdown += (
-                f"- **{scanner}**: {result['total_findings']} findings ({result['status']})\n"
-            )
+            markdown += f"- **{scanner}**: {result['total_findings']} findings ({result['status']})\n"
 
         if report["summary"]["CRITICAL"] > 0 or report["summary"]["HIGH"] > 0:
             markdown += "\n## Critical and High Severity Findings\n\n"
 
             for finding in report["findings"]:
                 if finding["severity"] in ["CRITICAL", "HIGH"]:
-                    markdown += f"### {finding['severity']}: {finding['title']}\n\n"
+                    markdown += (
+                        f"### {finding['severity']}: {finding['title']}\n\n"
+                    )
                     markdown += f"**File:** `{finding['file_path']}`  \n"
                     markdown += f"**Line:** {finding['line_number']}  \n"
                     markdown += f"**Scanner:** {finding['scanner']}  \n"
                     markdown += f"**Rule:** {finding['rule_id']}  \n"
-                    markdown += f"**Description:** {finding['description']}  \n"
+                    markdown += (
+                        f"**Description:** {finding['description']}  \n"
+                    )
 
                     if finding["remediation"]:
-                        markdown += f"**Remediation:** {finding['remediation']}  \n"
+                        markdown += (
+                            f"**Remediation:** {finding['remediation']}  \n"
+                        )
 
                     markdown += "\n---\n\n"
 
@@ -539,13 +596,20 @@ class SecurityReportGenerator:
 
 
 def main():
-    parser = argparse.ArgumentParser(description="Generate comprehensive security report")
+    parser = argparse.ArgumentParser(
+        description="Generate comprehensive security report"
+    )
     parser.add_argument(
-        "--input-dir", required=True, help="Directory containing security scan reports"
+        "--input-dir",
+        required=True,
+        help="Directory containing security scan reports",
     )
     parser.add_argument("--output", required=True, help="Output file path")
     parser.add_argument(
-        "--format", choices=["json", "yaml", "markdown"], default="json", help="Output format"
+        "--format",
+        choices=["json", "yaml", "markdown"],
+        default="json",
+        help="Output format",
     )
 
     args = parser.parse_args()
diff --git a/auto_generate_video_fold6/security/security-scanner.py b/auto_generate_video_fold6/security/security-scanner.py
index 5f5ba89..3f4b859 100644
--- a/auto_generate_video_fold6/security/security-scanner.py
+++ b/auto_generate_video_fold6/security/security-scanner.py
@@ -81,15 +81,24 @@ class SecurityScanner:
                 "config": self.config_dir / "bandit-config.yaml",
             },
             "safety": {"image": "pyupio/safety:latest", "config": None},
-            "semgrep": {"image": "returntocorp/semgrep:latest", "config": None},
-            "gitleaks": {"image": "zricethezav/gitleaks:latest", "config": None},
+            "semgrep": {
+                "image": "returntocorp/semgrep:latest",
+                "config": None,
+            },
+            "gitleaks": {
+                "image": "zricethezav/gitleaks:latest",
+                "config": None,
+            },
         }
 
         # 掃描歷史
         self.scan_history = []
 
     async def run_comprehensive_scan(
-        self, target_path: str, scan_types: List[str] = None, docker_images: List[str] = None
+        self,
+        target_path: str,
+        scan_types: List[str] = None,
+        docker_images: List[str] = None,
     ) -> Dict[str, ScanResult]:
         """執行綜合安全掃描"""
         if scan_types is None:
@@ -97,7 +106,9 @@ class SecurityScanner:
 
         results = {}
 
-        self.logger.info(f"Starting comprehensive security scan for {target_path}")
+        self.logger.info(
+            f"Starting comprehensive security scan for {target_path}"
+        )
 
         # 並行執行不同類型的掃描
         tasks = []
@@ -133,7 +144,9 @@ class SecurityScanner:
                         results[scan_result.scanner] = scan_result
 
         # 生成綜合報告
-        comprehensive_report = await self._generate_comprehensive_report(results)
+        comprehensive_report = await self._generate_comprehensive_report(
+            results
+        )
 
         # 發送告警
         await self._send_security_alerts(results)
@@ -170,11 +183,15 @@ class SecurityScanner:
             end_time=end_time,
             status=status,
             findings=findings,
-            metadata={"scan_duration": (end_time - start_time).total_seconds()},
+            metadata={
+                "scan_duration": (end_time - start_time).total_seconds()
+            },
             summary=self._summarize_findings(findings),
         )
 
-    async def _run_bandit_scan(self, target_path: str) -> List[SecurityFinding]:
+    async def _run_bandit_scan(
+        self, target_path: str
+    ) -> List[SecurityFinding]:
         """執行 Bandit 掃描"""
         findings = []
 
@@ -198,7 +215,9 @@ class SecurityScanner:
             ]
 
             # 執行掃描
-            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
+            result = subprocess.run(
+                cmd, capture_output=True, text=True, timeout=300
+            )
 
             if result.returncode in [0, 1]:  # 0=無問題, 1=發現問題
                 if result.stdout:
@@ -207,14 +226,18 @@ class SecurityScanner:
                     for result_item in bandit_data.get("results", []):
                         finding = SecurityFinding(
                             id=f"bandit_{result_item.get('test_id')}_{int(time.time())}",
-                            severity=result_item.get("issue_severity", "UNKNOWN").upper(),
+                            severity=result_item.get(
+                                "issue_severity", "UNKNOWN"
+                            ).upper(),
                             title=result_item.get("issue_text", ""),
                             description=result_item.get("issue_text", ""),
                             file_path=result_item.get("filename", ""),
                             line_number=result_item.get("line_number", 0),
                             scanner="bandit",
                             rule_id=result_item.get("test_id", ""),
-                            confidence=result_item.get("issue_confidence", "UNKNOWN"),
+                            confidence=result_item.get(
+                                "issue_confidence", "UNKNOWN"
+                            ),
                             remediation=result_item.get("more_info", ""),
                             created_at=datetime.now().isoformat(),
                         )
@@ -225,7 +248,9 @@ class SecurityScanner:
 
         return findings
 
-    async def _run_semgrep_scan(self, target_path: str) -> List[SecurityFinding]:
+    async def _run_semgrep_scan(
+        self, target_path: str
+    ) -> List[SecurityFinding]:
         """執行 Semgrep 掃描"""
         findings = []
 
@@ -244,7 +269,9 @@ class SecurityScanner:
             ]
 
             # 執行掃描
-            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
+            result = subprocess.run(
+                cmd, capture_output=True, text=True, timeout=600
+            )
 
             if result.returncode in [0, 1]:
                 if result.stdout:
@@ -252,20 +279,30 @@ class SecurityScanner:
 
                     for result_item in semgrep_data.get("results", []):
                         severity = self._map_semgrep_severity(
-                            result_item.get("extra", {}).get("severity", "INFO")
+                            result_item.get("extra", {}).get(
+                                "severity", "INFO"
+                            )
                         )
 
                         finding = SecurityFinding(
                             id=f"semgrep_{result_item.get('check_id')}_{int(time.time())}",
                             severity=severity,
-                            title=result_item.get("extra", {}).get("message", ""),
-                            description=result_item.get("extra", {}).get("message", ""),
+                            title=result_item.get("extra", {}).get(
+                                "message", ""
+                            ),
+                            description=result_item.get("extra", {}).get(
+                                "message", ""
+                            ),
                             file_path=result_item.get("path", ""),
-                            line_number=result_item.get("start", {}).get("line", 0),
+                            line_number=result_item.get("start", {}).get(
+                                "line", 0
+                            ),
                             scanner="semgrep",
                             rule_id=result_item.get("check_id", ""),
                             confidence="HIGH",
-                            remediation=result_item.get("extra", {}).get("fix", ""),
+                            remediation=result_item.get("extra", {}).get(
+                                "fix", ""
+                            ),
                             created_at=datetime.now().isoformat(),
                         )
                         findings.append(finding)
@@ -305,11 +342,15 @@ class SecurityScanner:
             end_time=end_time,
             status=status,
             findings=findings,
-            metadata={"scan_duration": (end_time - start_time).total_seconds()},
+            metadata={
+                "scan_duration": (end_time - start_time).total_seconds()
+            },
             summary=self._summarize_findings(findings),
         )
 
-    async def _run_safety_scan(self, target_path: str) -> List[SecurityFinding]:
+    async def _run_safety_scan(
+        self, target_path: str
+    ) -> List[SecurityFinding]:
         """執行 Safety 掃描"""
         findings = []
 
@@ -331,7 +372,9 @@ class SecurityScanner:
                     f"/code/{req_file.name}",
                 ]
 
-                result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
+                result = subprocess.run(
+                    cmd, capture_output=True, text=True, timeout=120
+                )
 
                 if result.stdout:
                     safety_data = json.loads(result.stdout)
@@ -382,12 +425,16 @@ class SecurityScanner:
                     "--json",
                 ]
 
-                result = subprocess.run(cmd, capture_output=True, text=True, timeout=180)
+                result = subprocess.run(
+                    cmd, capture_output=True, text=True, timeout=180
+                )
 
                 if result.stdout:
                     audit_data = json.loads(result.stdout)
 
-                    for vuln_id, vuln in audit_data.get("vulnerabilities", {}).items():
+                    for vuln_id, vuln in audit_data.get(
+                        "vulnerabilities", {}
+                    ).items():
                         severity = vuln.get("severity", "unknown").upper()
 
                         finding = SecurityFinding(
@@ -401,7 +448,9 @@ class SecurityScanner:
                             rule_id=vuln_id,
                             confidence="HIGH",
                             remediation=f"Update to version {vuln.get('fixAvailable', {}).get('version', 'latest')}",
-                            cve_id=vuln.get("cves", [None])[0] if vuln.get("cves") else None,
+                            cve_id=vuln.get("cves", [None])[0]
+                            if vuln.get("cves")
+                            else None,
                             created_at=datetime.now().isoformat(),
                         )
                         findings.append(finding)
@@ -441,11 +490,15 @@ class SecurityScanner:
             end_time=end_time,
             status=status,
             findings=findings,
-            metadata={"scan_duration": (end_time - start_time).total_seconds()},
+            metadata={
+                "scan_duration": (end_time - start_time).total_seconds()
+            },
             summary=self._summarize_findings(findings),
         )
 
-    async def _run_trivy_secret_scan(self, target_path: str) -> List[SecurityFinding]:
+    async def _run_trivy_secret_scan(
+        self, target_path: str
+    ) -> List[SecurityFinding]:
         """執行 Trivy 密鑰掃描"""
         findings = []
 
@@ -469,7 +522,9 @@ class SecurityScanner:
                 "/code",
             ]
 
-            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
+            result = subprocess.run(
+                cmd, capture_output=True, text=True, timeout=300
+            )
 
             if result.returncode == 0 and result.stdout:
                 trivy_data = json.loads(result.stdout)
@@ -496,7 +551,9 @@ class SecurityScanner:
 
         return findings
 
-    async def _run_gitleaks_scan(self, target_path: str) -> List[SecurityFinding]:
+    async def _run_gitleaks_scan(
+        self, target_path: str
+    ) -> List[SecurityFinding]:
         """執行 Gitleaks 掃描"""
         findings = []
 
@@ -514,7 +571,9 @@ class SecurityScanner:
                 "--report-path=/tmp/gitleaks.json",
             ]
 
-            result = subprocess.run(cmd, capture_output=True, text=True, timeout=180)
+            result = subprocess.run(
+                cmd, capture_output=True, text=True, timeout=180
+            )
 
             # Gitleaks 在找到密鑰時返回非零狀態碼
             if result.stdout:
@@ -568,7 +627,9 @@ class SecurityScanner:
                 image_name,
             ]
 
-            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
+            result = subprocess.run(
+                cmd, capture_output=True, text=True, timeout=600
+            )
 
             if result.returncode == 0 and result.stdout:
                 trivy_data = json.loads(result.stdout)
@@ -608,7 +669,9 @@ class SecurityScanner:
             end_time=end_time,
             status=status,
             findings=findings,
-            metadata={"scan_duration": (end_time - start_time).total_seconds()},
+            metadata={
+                "scan_duration": (end_time - start_time).total_seconds()
+            },
             summary=self._summarize_findings(findings),
         )
 
@@ -627,7 +690,9 @@ class SecurityScanner:
             findings.extend(k8s_findings)
 
             # 掃描 Docker Compose 配置
-            compose_findings = await self._scan_docker_compose_configs(target_path)
+            compose_findings = await self._scan_docker_compose_configs(
+                target_path
+            )
             findings.extend(compose_findings)
 
             status = "completed"
@@ -646,11 +711,15 @@ class SecurityScanner:
             end_time=end_time,
             status=status,
             findings=findings,
-            metadata={"scan_duration": (end_time - start_time).total_seconds()},
+            metadata={
+                "scan_duration": (end_time - start_time).total_seconds()
+            },
             summary=self._summarize_findings(findings),
         )
 
-    async def _scan_dockerfiles(self, target_path: str) -> List[SecurityFinding]:
+    async def _scan_dockerfiles(
+        self, target_path: str
+    ) -> List[SecurityFinding]:
         """掃描 Dockerfile 安全問題"""
         findings = []
 
@@ -671,20 +740,28 @@ class SecurityScanner:
                     f"/code/{dockerfile.name}",
                 ]
 
-                result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
+                result = subprocess.run(
+                    cmd, capture_output=True, text=True, timeout=60
+                )
 
                 if result.returncode == 0 and result.stdout:
                     trivy_data = json.loads(result.stdout)
 
                     for result_item in trivy_data.get("Results", []):
-                        for misconfig in result_item.get("Misconfigurations", []):
+                        for misconfig in result_item.get(
+                            "Misconfigurations", []
+                        ):
                             finding = SecurityFinding(
                                 id=f"dockerfile_{misconfig.get('ID')}_{int(time.time())}",
-                                severity=misconfig.get("Severity", "UNKNOWN").upper(),
+                                severity=misconfig.get(
+                                    "Severity", "UNKNOWN"
+                                ).upper(),
                                 title=f"Dockerfile issue: {misconfig.get('Title', '')}",
                                 description=misconfig.get("Description", ""),
                                 file_path=str(dockerfile),
-                                line_number=misconfig.get("CauseMetadata", {}).get("StartLine", 0),
+                                line_number=misconfig.get(
+                                    "CauseMetadata", {}
+                                ).get("StartLine", 0),
                                 scanner="trivy_dockerfile",
                                 rule_id=misconfig.get("ID", ""),
                                 confidence="HIGH",
@@ -694,11 +771,15 @@ class SecurityScanner:
                             findings.append(finding)
 
             except Exception as e:
-                self.logger.error(f"Dockerfile scan failed for {dockerfile}: {e}")
+                self.logger.error(
+                    f"Dockerfile scan failed for {dockerfile}: {e}"
+                )
 
         return findings
 
-    async def _scan_kubernetes_configs(self, target_path: str) -> List[SecurityFinding]:
+    async def _scan_kubernetes_configs(
+        self, target_path: str
+    ) -> List[SecurityFinding]:
         """掃描 Kubernetes 配置安全問題"""
         findings = []
 
@@ -727,41 +808,57 @@ class SecurityScanner:
                             f"/code/{k8s_file.name}",
                         ]
 
-                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
+                        result = subprocess.run(
+                            cmd, capture_output=True, text=True, timeout=60
+                        )
 
                         if result.returncode == 0 and result.stdout:
                             trivy_data = json.loads(result.stdout)
 
                             for result_item in trivy_data.get("Results", []):
-                                for misconfig in result_item.get("Misconfigurations", []):
+                                for misconfig in result_item.get(
+                                    "Misconfigurations", []
+                                ):
                                     finding = SecurityFinding(
                                         id=f"k8s_{misconfig.get('ID')}_{int(time.time())}",
-                                        severity=misconfig.get("Severity", "UNKNOWN").upper(),
+                                        severity=misconfig.get(
+                                            "Severity", "UNKNOWN"
+                                        ).upper(),
                                         title=f"K8s config issue: {misconfig.get('Title', '')}",
-                                        description=misconfig.get("Description", ""),
-                                        file_path=str(k8s_file),
-                                        line_number=misconfig.get("CauseMetadata", {}).get(
-                                            "StartLine", 0
+                                        description=misconfig.get(
+                                            "Description", ""
                                         ),
+                                        file_path=str(k8s_file),
+                                        line_number=misconfig.get(
+                                            "CauseMetadata", {}
+                                        ).get("StartLine", 0),
                                         scanner="trivy_k8s",
                                         rule_id=misconfig.get("ID", ""),
                                         confidence="HIGH",
-                                        remediation=misconfig.get("Resolution", ""),
+                                        remediation=misconfig.get(
+                                            "Resolution", ""
+                                        ),
                                         created_at=datetime.now().isoformat(),
                                     )
                                     findings.append(finding)
 
             except Exception as e:
-                self.logger.debug(f"K8s config scan failed for {k8s_file}: {e}")
+                self.logger.debug(
+                    f"K8s config scan failed for {k8s_file}: {e}"
+                )
 
         return findings
 
-    async def _scan_docker_compose_configs(self, target_path: str) -> List[SecurityFinding]:
+    async def _scan_docker_compose_configs(
+        self, target_path: str
+    ) -> List[SecurityFinding]:
         """掃描 Docker Compose 配置安全問題"""
         findings = []
 
         compose_files = list(Path(target_path).rglob("docker-compose*.yml"))
-        compose_files.extend(list(Path(target_path).rglob("docker-compose*.yaml")))
+        compose_files.extend(
+            list(Path(target_path).rglob("docker-compose*.yaml"))
+        )
 
         for compose_file in compose_files:
             try:
@@ -778,20 +875,28 @@ class SecurityScanner:
                     f"/code/{compose_file.name}",
                 ]
 
-                result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
+                result = subprocess.run(
+                    cmd, capture_output=True, text=True, timeout=60
+                )
 
                 if result.returncode == 0 and result.stdout:
                     trivy_data = json.loads(result.stdout)
 
                     for result_item in trivy_data.get("Results", []):
-                        for misconfig in result_item.get("Misconfigurations", []):
+                        for misconfig in result_item.get(
+                            "Misconfigurations", []
+                        ):
                             finding = SecurityFinding(
                                 id=f"compose_{misconfig.get('ID')}_{int(time.time())}",
-                                severity=misconfig.get("Severity", "UNKNOWN").upper(),
+                                severity=misconfig.get(
+                                    "Severity", "UNKNOWN"
+                                ).upper(),
                                 title=f"Docker Compose issue: {misconfig.get('Title', '')}",
                                 description=misconfig.get("Description", ""),
                                 file_path=str(compose_file),
-                                line_number=misconfig.get("CauseMetadata", {}).get("StartLine", 0),
+                                line_number=misconfig.get(
+                                    "CauseMetadata", {}
+                                ).get("StartLine", 0),
                                 scanner="trivy_compose",
                                 rule_id=misconfig.get("ID", ""),
                                 confidence="HIGH",
@@ -801,13 +906,23 @@ class SecurityScanner:
                             findings.append(finding)
 
             except Exception as e:
-                self.logger.error(f"Docker Compose scan failed for {compose_file}: {e}")
+                self.logger.error(
+                    f"Docker Compose scan failed for {compose_file}: {e}"
+                )
 
         return findings
 
-    def _summarize_findings(self, findings: List[SecurityFinding]) -> Dict[str, int]:
+    def _summarize_findings(
+        self, findings: List[SecurityFinding]
+    ) -> Dict[str, int]:
         """統計發現摘要"""
-        summary = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "UNKNOWN": 0}
+        summary = {
+            "CRITICAL": 0,
+            "HIGH": 0,
+            "MEDIUM": 0,
+            "LOW": 0,
+            "UNKNOWN": 0,
+        }
 
         for finding in findings:
             severity = finding.severity.upper()
@@ -830,7 +945,13 @@ class SecurityScanner:
         report = {
             "scan_timestamp": datetime.now().isoformat(),
             "total_scanners": len(results),
-            "summary": {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "UNKNOWN": 0},
+            "summary": {
+                "CRITICAL": 0,
+                "HIGH": 0,
+                "MEDIUM": 0,
+                "LOW": 0,
+                "UNKNOWN": 0,
+            },
             "scanner_results": {},
             "recommendations": [],
         }
@@ -852,16 +973,23 @@ class SecurityScanner:
             all_findings.extend(scan_result.findings)
 
         # 生成建議
-        report["recommendations"] = self._generate_recommendations(all_findings)
+        report["recommendations"] = self._generate_recommendations(
+            all_findings
+        )
 
         # 儲存報告
-        report_file = self.reports_dir / f"comprehensive_security_report_{int(time.time())}.json"
+        report_file = (
+            self.reports_dir
+            / f"comprehensive_security_report_{int(time.time())}.json"
+        )
         with open(report_file, "w") as f:
             json.dump(report, f, indent=2, default=str)
 
         return report
 
-    def _generate_recommendations(self, findings: List[SecurityFinding]) -> List[str]:
+    def _generate_recommendations(
+        self, findings: List[SecurityFinding]
+    ) -> List[str]:
         """生成安全建議"""
         recommendations = []
 
@@ -878,7 +1006,9 @@ class SecurityScanner:
         # 檢查常見問題類型
         scanner_counts = {}
         for finding in findings:
-            scanner_counts[finding.scanner] = scanner_counts.get(finding.scanner, 0) + 1
+            scanner_counts[finding.scanner] = (
+                scanner_counts.get(finding.scanner, 0) + 1
+            )
 
         if scanner_counts.get("trivy_secrets", 0) > 0:
             recommendations.append("檢查並移除程式碼中的硬編碼密鑰")
@@ -896,7 +1026,9 @@ class SecurityScanner:
 
     async def _send_security_alerts(self, results: Dict[str, ScanResult]):
         """發送安全告警"""
-        total_critical = sum(r.summary.get("CRITICAL", 0) for r in results.values())
+        total_critical = sum(
+            r.summary.get("CRITICAL", 0) for r in results.values()
+        )
         total_high = sum(r.summary.get("HIGH", 0) for r in results.values())
 
         if total_critical > 0 or total_high > 5:
@@ -925,7 +1057,10 @@ async def main():
     results = await scanner.run_comprehensive_scan(
         target_path="./",
         scan_types=["code", "dependencies", "secrets"],
-        docker_images=["auto-video/api-gateway:latest", "auto-video/auth-service:latest"],
+        docker_images=[
+            "auto-video/api-gateway:latest",
+            "auto-video/auth-service:latest",
+        ],
     )
 
     # 輸出結果摘要
diff --git a/auto_generate_video_fold6/security/zero-trust-security.py b/auto_generate_video_fold6/security/zero-trust-security.py
index c32a29a..38adac3 100644
--- a/auto_generate_video_fold6/security/zero-trust-security.py
+++ b/auto_generate_video_fold6/security/zero-trust-security.py
@@ -109,7 +109,9 @@ class DeviceFingerprinter:
 
         return device_id
 
-    async def _store_device_info(self, device_id: str, fingerprint_data: Dict[str, Any]):
+    async def _store_device_info(
+        self, device_id: str, fingerprint_data: Dict[str, Any]
+    ):
         """存儲設備資訊"""
         device_info = {
             "fingerprint": fingerprint_data,
@@ -123,9 +125,13 @@ class DeviceFingerprinter:
         if existing_info:
             existing_data = json.loads(existing_info)
             device_info["first_seen"] = existing_data["first_seen"]
-            device_info["trust_score"] = min(existing_data["trust_score"] + 0.1, 1.0)
+            device_info["trust_score"] = min(
+                existing_data["trust_score"] + 0.1, 1.0
+            )
 
-        self.redis_client.setex(f"device:{device_id}", timedelta(days=90), json.dumps(device_info))
+        self.redis_client.setex(
+            f"device:{device_id}", timedelta(days=90), json.dumps(device_info)
+        )
 
     async def get_device_trust_score(self, device_id: str) -> float:
         """獲取設備信任分數"""
@@ -143,27 +149,40 @@ class BehaviorAnalyzer:
         self.redis_client = redis.Redis(host="localhost", port=6379, db=4)
         self.behavior_models = {}
 
-    async def analyze_behavior(self, user_id: str, action: str, context: SecurityContext) -> float:
+    async def analyze_behavior(
+        self, user_id: str, action: str, context: SecurityContext
+    ) -> float:
         """分析用戶行為並返回風險分數"""
 
         # 獲取用戶歷史行為
         behavior_history = await self._get_user_behavior_history(user_id)
 
         # 時間分析
-        time_risk = await self._analyze_time_patterns(user_id, context.timestamp)
+        time_risk = await self._analyze_time_patterns(
+            user_id, context.timestamp
+        )
 
         # 地理位置分析
-        location_risk = await self._analyze_location_patterns(user_id, context.location)
+        location_risk = await self._analyze_location_patterns(
+            user_id, context.location
+        )
 
         # 頻率分析
-        frequency_risk = await self._analyze_frequency_patterns(user_id, action)
+        frequency_risk = await self._analyze_frequency_patterns(
+            user_id, action
+        )
 
         # 設備分析
-        device_risk = await self._analyze_device_patterns(user_id, context.device_id)
+        device_risk = await self._analyze_device_patterns(
+            user_id, context.device_id
+        )
 
         # 綜合風險評估
         total_risk = (
-            time_risk * 0.2 + location_risk * 0.3 + frequency_risk * 0.3 + device_risk * 0.2
+            time_risk * 0.2
+            + location_risk * 0.3
+            + frequency_risk * 0.3
+            + device_risk * 0.2
         )
 
         # 記錄當前行為
@@ -172,14 +191,20 @@ class BehaviorAnalyzer:
         logger.info(f"用戶 {user_id} 行為風險分析: {total_risk:.3f}")
         return min(total_risk, 1.0)
 
-    async def _get_user_behavior_history(self, user_id: str) -> List[Dict[str, Any]]:
+    async def _get_user_behavior_history(
+        self, user_id: str
+    ) -> List[Dict[str, Any]]:
         """獲取用戶行為歷史"""
         history_key = f"behavior_history:{user_id}"
-        history_data = self.redis_client.lrange(history_key, 0, 100)  # 最近100條
+        history_data = self.redis_client.lrange(
+            history_key, 0, 100
+        )  # 最近100條
 
         return [json.loads(item) for item in history_data]
 
-    async def _analyze_time_patterns(self, user_id: str, current_time: datetime) -> float:
+    async def _analyze_time_patterns(
+        self, user_id: str, current_time: datetime
+    ) -> float:
         """分析時間模式異常"""
         # 獲取用戶常用時間段
         history = await self._get_user_behavior_history(user_id)
@@ -224,7 +249,9 @@ class BehaviorAnalyzer:
         else:
             return 0.7  # 新地點，高風險
 
-    async def _analyze_frequency_patterns(self, user_id: str, action: str) -> float:
+    async def _analyze_frequency_patterns(
+        self, user_id: str, action: str
+    ) -> float:
         """分析操作頻率異常"""
         # 檢查最近1小時內的同類操作次數
         recent_actions = []
@@ -250,11 +277,15 @@ class BehaviorAnalyzer:
 
         return min(frequency_risk, 1.0)
 
-    async def _analyze_device_patterns(self, user_id: str, device_id: str) -> float:
+    async def _analyze_device_patterns(
+        self, user_id: str, device_id: str
+    ) -> float:
         """分析設備使用模式"""
         # 檢查用戶是否經常使用此設備
         history = await self._get_user_behavior_history(user_id)
-        device_usage = sum(1 for record in history if record.get("device_id") == device_id)
+        device_usage = sum(
+            1 for record in history if record.get("device_id") == device_id
+        )
 
         if device_usage > 10:
             return 0.1  # 常用設備，低風險
@@ -264,7 +295,11 @@ class BehaviorAnalyzer:
             return 0.6  # 新設備，高風險
 
     async def _record_behavior(
-        self, user_id: str, action: str, context: SecurityContext, risk_score: float
+        self,
+        user_id: str,
+        action: str,
+        context: SecurityContext,
+        risk_score: float,
     ):
         """記錄用戶行為"""
         behavior_record = {
@@ -290,25 +325,36 @@ class RiskEngine:
         self.device_fingerprinter = DeviceFingerprinter()
         self.threat_intelligence = ThreatIntelligence()
 
-    async def assess_risk(self, user_id: str, action: str, context: SecurityContext) -> float:
+    async def assess_risk(
+        self, user_id: str, action: str, context: SecurityContext
+    ) -> float:
         """綜合風險評估"""
 
         # 行為風險
-        behavior_risk = await self.behavior_analyzer.analyze_behavior(user_id, action, context)
+        behavior_risk = await self.behavior_analyzer.analyze_behavior(
+            user_id, action, context
+        )
 
         # 設備風險
-        device_trust = await self.device_fingerprinter.get_device_trust_score(context.device_id)
+        device_trust = await self.device_fingerprinter.get_device_trust_score(
+            context.device_id
+        )
         device_risk = 1.0 - device_trust
 
         # 威脅情報風險
-        threat_risk = await self.threat_intelligence.check_ip_reputation(context.ip_address)
+        threat_risk = await self.threat_intelligence.check_ip_reputation(
+            context.ip_address
+        )
 
         # 會話風險
         session_risk = await self._assess_session_risk(context.session_id)
 
         # 綜合風險計算
         total_risk = (
-            behavior_risk * 0.4 + device_risk * 0.2 + threat_risk * 0.3 + session_risk * 0.1
+            behavior_risk * 0.4
+            + device_risk * 0.2
+            + threat_risk * 0.3
+            + session_risk * 0.1
         )
 
         logger.info(
@@ -366,7 +412,9 @@ class ThreatIntelligence:
         reputation_score = await self._query_threat_intelligence(ip_address)
 
         # 緩存結果
-        self.redis_client.setex(reputation_key, timedelta(hours=1), str(reputation_score))
+        self.redis_client.setex(
+            reputation_key, timedelta(hours=1), str(reputation_score)
+        )
 
         return reputation_score
 
@@ -388,7 +436,9 @@ class ThreatIntelligence:
                         # 模擬 API 調用（實際需要 API 密鑰）
                         # response = await client.get(source.format(ip=ip_address))
                         # 模擬響應
-                        simulated_score = 0.1 if ip_address.startswith("192.168.") else 0.0
+                        simulated_score = (
+                            0.1 if ip_address.startswith("192.168.") else 0.0
+                        )
                         risk_scores.append(simulated_score)
                     except Exception as e:
                         logger.warning(f"威脅情報查詢失敗: {e}")
@@ -439,12 +489,19 @@ class PolicyEngine:
         )
 
     async def evaluate_access(
-        self, user_id: str, resource: str, action: str, context: SecurityContext
+        self,
+        user_id: str,
+        resource: str,
+        action: str,
+        context: SecurityContext,
     ) -> Dict[str, Any]:
         """評估訪問權限"""
 
         if resource not in self.policies:
-            return {"allowed": False, "reason": f"未定義資源 {resource} 的訪問策略"}
+            return {
+                "allowed": False,
+                "reason": f"未定義資源 {resource} 的訪問策略",
+            }
 
         policy = self.policies[resource]
 
@@ -470,9 +527,14 @@ class PolicyEngine:
             }
 
         # 檢查額外條件
-        condition_check = await self._check_policy_conditions(user_id, policy, context)
+        condition_check = await self._check_policy_conditions(
+            user_id, policy, context
+        )
         if not condition_check["passed"]:
-            return {"allowed": False, "reason": f"策略條件檢查失敗: {condition_check['reason']}"}
+            return {
+                "allowed": False,
+                "reason": f"策略條件檢查失敗: {condition_check['reason']}",
+            }
 
         return {
             "allowed": True,
@@ -501,8 +563,13 @@ class PolicyEngine:
                     return {"passed": False, "reason": "需要多因素認證"}
 
             elif condition == "ip_whitelist":
-                if value and not await self._check_ip_whitelist(user_id, context.ip_address):
-                    return {"passed": False, "reason": f"IP {context.ip_address} 不在白名單中"}
+                if value and not await self._check_ip_whitelist(
+                    user_id, context.ip_address
+                ):
+                    return {
+                        "passed": False,
+                        "reason": f"IP {context.ip_address} 不在白名單中",
+                    }
 
         return {"passed": True, "reason": "所有條件檢查通過"}
 
@@ -536,7 +603,11 @@ class ZeroTrustGateway:
         self.audit_logger = AuditLogger()
 
     async def authenticate_and_authorize(
-        self, token: str, resource: str, action: str, request_data: Dict[str, Any]
+        self,
+        token: str,
+        resource: str,
+        action: str,
+        request_data: Dict[str, Any],
     ) -> Dict[str, Any]:
         """零信任認證和授權"""
 
@@ -549,7 +620,9 @@ class ZeroTrustGateway:
             user_id = token_data["user_id"]
 
             # 2. 生成設備指紋
-            device_id = await self.device_fingerprinter.generate_fingerprint(request_data)
+            device_id = await self.device_fingerprinter.generate_fingerprint(
+                request_data
+            )
 
             # 3. 構建安全上下文
             context = SecurityContext(
@@ -558,14 +631,18 @@ class ZeroTrustGateway:
                 ip_address=request_data.get("ip_address", ""),
                 user_agent=request_data.get("user_agent", ""),
                 location=request_data.get("location"),
-                trust_level=await self._calculate_trust_level(user_id, device_id),
+                trust_level=await self._calculate_trust_level(
+                    user_id, device_id
+                ),
                 risk_score=0.0,  # 將在風險評估中計算
                 session_id=token_data["session_id"],
                 timestamp=datetime.utcnow(),
             )
 
             # 4. 風險評估
-            context.risk_score = await self.risk_engine.assess_risk(user_id, action, context)
+            context.risk_score = await self.risk_engine.assess_risk(
+                user_id, action, context
+            )
 
             # 5. 策略評估
             access_decision = await self.policy_engine.evaluate_access(
@@ -593,7 +670,9 @@ class ZeroTrustGateway:
         """驗證 JWT 令牌"""
         try:
             # 實際實現中應該使用適當的密鑰和算法
-            decoded = jwt.decode(token, "your-secret-key", algorithms=["HS256"])
+            decoded = jwt.decode(
+                token, "your-secret-key", algorithms=["HS256"]
+            )
 
             # 檢查令牌是否被撤銷
             if await self._is_token_revoked(token):
@@ -616,14 +695,18 @@ class ZeroTrustGateway:
         revoked_key = f"revoked_token:{token_hash}"
         return self.redis_client.exists(revoked_key)
 
-    async def _calculate_trust_level(self, user_id: str, device_id: str) -> TrustLevel:
+    async def _calculate_trust_level(
+        self, user_id: str, device_id: str
+    ) -> TrustLevel:
         """計算用戶信任等級"""
 
         # 獲取用戶基礎信任分數
         user_trust = await self._get_user_trust_score(user_id)
 
         # 獲取設備信任分數
-        device_trust = await self.device_fingerprinter.get_device_trust_score(device_id)
+        device_trust = await self.device_fingerprinter.get_device_trust_score(
+            device_id
+        )
 
         # 綜合信任分數
         combined_trust = (user_trust + device_trust) / 2
@@ -654,7 +737,12 @@ class AuditLogger:
         self.redis_client = redis.Redis(host="localhost", port=6379, db=6)
 
     async def log_access_attempt(
-        self, user_id: str, resource: str, action: str, context: SecurityContext, success: bool
+        self,
+        user_id: str,
+        resource: str,
+        action: str,
+        context: SecurityContext,
+        success: bool,
     ):
         """記錄訪問嘗試"""
 
@@ -667,7 +755,10 @@ class AuditLogger:
             risk_level=self._determine_risk_level(context.risk_score),
             context=context,
             timestamp=datetime.utcnow(),
-            metadata={"success": success, "trust_level": context.trust_level.name},
+            metadata={
+                "success": success,
+                "trust_level": context.trust_level.name,
+            },
         )
 
         # 記錄到審計日誌
@@ -746,7 +837,10 @@ async def main():
 
     # 零信任認證
     result = await gateway.authenticate_and_authorize(
-        token=token, resource="video_generation", action="create", request_data=request_data
+        token=token,
+        resource="video_generation",
+        action="create",
+        request_data=request_data,
     )
 
     if result["authorized"]:
diff --git a/auto_generate_video_fold6/services/ai-service/app/services/text_generator.py b/auto_generate_video_fold6/services/ai-service/app/services/text_generator.py
index 74e1a3f..17d1912 100644
--- a/auto_generate_video_fold6/services/ai-service/app/services/text_generator.py
+++ b/auto_generate_video_fold6/services/ai-service/app/services/text_generator.py
@@ -305,7 +305,7 @@ REQUIREMENTS:
     approximately {duration_seconds * 2.5} words)
 - Target Audience: {target_audience}
 - Tone: {tone}
-{f'- Include Keywords: {keyword_text}' if keyword_text else ''}
+{f"- Include Keywords: {keyword_text}" if keyword_text else ""}
 
 SCRIPT GUIDELINES:
 1. Start with a strong hook in the first 3 seconds
@@ -343,7 +343,7 @@ SCRIPT CONTENT:
 REQUIREMENTS:
 - Style: {style}
 - Maximum length: {max_length} characters
-{f'- Include keywords: {keyword_text}' if keyword_text else ''}
+{f"- Include keywords: {keyword_text}" if keyword_text else ""}
 
 STYLE CHARACTERISTICS:
 - Catchy: Use power words, numbers, emotional triggers
@@ -381,9 +381,13 @@ OPTIMIZATION TASK:
 OPTIMIZATION GUIDELINES:
 - Maintain the core message and hook
 - Preserve the most engaging elements
-- {'Remove redundant points, combine ideas, use more concise \
-    language' if action == 'shorten' else 'Add supporting details, \
-        examples, or elaboration on key points'}
+- {
+            "Remove redundant points, combine ideas, use more concise \
+    language"
+            if action == "shorten"
+            else "Add supporting details, \
+        examples, or elaboration on key points"
+        }
 - Keep the natural flow and transitions
 - Maintain call-to-action
 
diff --git a/auto_generate_video_fold6/services/ai-service/gemini_client.py b/auto_generate_video_fold6/services/ai-service/gemini_client.py
index beabe70..0cf810b 100644
--- a/auto_generate_video_fold6/services/ai-service/gemini_client.py
+++ b/auto_generate_video_fold6/services/ai-service/gemini_client.py
@@ -153,7 +153,6 @@ class GeminiClient:
                 json=request_data,
                 headers={"Content-Type": "application/json"},
             ) as response:
-
                 duration = time.time() - start_time
 
                 if response.status != 200:
@@ -312,7 +311,6 @@ class GeminiClient:
                 json=request_data,
                 headers={"Content-Type": "application/json"},
             ) as response:
-
                 if response.status == 200:
                     result_data = await response.json()
                     duration = time.time() - start_time
diff --git a/auto_generate_video_fold6/services/ai-service/mlops_pipeline.py b/auto_generate_video_fold6/services/ai-service/mlops_pipeline.py
index 62de7c4..300f083 100644
--- a/auto_generate_video_fold6/services/ai-service/mlops_pipeline.py
+++ b/auto_generate_video_fold6/services/ai-service/mlops_pipeline.py
@@ -348,9 +348,9 @@ class ExperimentTracker:
         duration_hours: int = 24,
     ) -> str:
         """啟動 A/B 測試"""
-        test_id = f"ab_test_{model_a.model_id}_{model_b
-                                                .model_id}_{int \
-                                                    (datetime.utcnow().timestamp())}"
+        test_id = f"ab_test_{model_a.model_id}_{model_b.model_id}_{
+            int(datetime.utcnow().timestamp())
+        }"
 
         ab_test = {
             "id": test_id,
@@ -515,8 +515,9 @@ class MLOpsPipeline:
     ):
         """路由指定百分比的流量到新模型"""
         logger.info(
-            f"路由 {percentage}% 流量到 {model_version
-                                    .model_id}:{model_version.version}"
+            f"路由 {percentage}% 流量到 {model_version.model_id}:{
+                model_version.version
+            }"
         )
         # 實際實現會更新 Istio VirtualService 配置
 
diff --git a/auto_generate_video_fold6/services/ai-service/tests/test_ai_services.py b/auto_generate_video_fold6/services/ai-service/tests/test_ai_services.py
index 592d0cc..1bae30b 100644
--- a/auto_generate_video_fold6/services/ai-service/tests/test_ai_services.py
+++ b/auto_generate_video_fold6/services/ai-service/tests/test_ai_services.py
@@ -70,9 +70,9 @@ class TestAIServices:
         # Setup mock
         mock_response = Mock()
         mock_response.choices = [Mock()]
-        mock_response.choices[0].message.content = (
-            "Generated test script content"
-        )
+        mock_response.choices[
+            0
+        ].message.content = "Generated test script content"
 
         mock_client = AsyncMock()
         mock_client.chat.completions.create.return_value = mock_response
@@ -106,7 +106,6 @@ class TestAIServices:
             patch.object(settings, "stability_api_key", ""),
             patch.object(settings, "openai_api_key", ""),
         ):
-
             with pytest.raises(
                 Exception, match="No image generation service available"
             ):
diff --git a/auto_generate_video_fold6/services/auth-service/app/config.py b/auto_generate_video_fold6/services/auth-service/app/config.py
index a8abaa8..769a399 100644
--- a/auto_generate_video_fold6/services/auth-service/app/config.py
+++ b/auto_generate_video_fold6/services/auth-service/app/config.py
@@ -11,7 +11,9 @@ class Settings(BaseSettings):
     database_pool_size: int = int(os.getenv("DATABASE_POOL_SIZE", "10"))
     database_max_overflow: int = int(os.getenv("DATABASE_MAX_OVERFLOW", "20"))
     database_pool_timeout: int = int(os.getenv("DATABASE_POOL_TIMEOUT", "30"))
-    database_pool_recycle: int = int(os.getenv("DATABASE_POOL_RECYCLE", "3600"))
+    database_pool_recycle: int = int(
+        os.getenv("DATABASE_POOL_RECYCLE", "3600")
+    )
 
     # JWT Configuration
     jwt_secret_key: str = os.getenv("JWT_SECRET_KEY")
diff --git a/auto_generate_video_fold6/services/auth-service/tests/test_routers.py b/auto_generate_video_fold6/services/auth-service/tests/test_routers.py
index 5f0ee05..0c2fd12 100644
--- a/auto_generate_video_fold6/services/auth-service/tests/test_routers.py
+++ b/auto_generate_video_fold6/services/auth-service/tests/test_routers.py
@@ -36,7 +36,6 @@ class TestAuthRouters:
             patch("app.crud.get_user_by_email") as mock_get_email,
             patch("app.crud.get_user_by_username") as mock_get_username,
         ):
-
             mock_get_email.return_value = None
             mock_get_username.return_value = None
             mock_create.return_value = {
@@ -91,7 +90,6 @@ class TestAuthRouters:
             patch("app.security.create_access_token") as mock_token,
             patch("app.security.create_refresh_token") as mock_refresh,
         ):
-
             mock_get_user.return_value = {
                 "id": 1,
                 "email": "testuser@example.com",
@@ -123,7 +121,6 @@ class TestAuthRouters:
             patch("app.crud.get_user_by_email") as mock_get_user,
             patch("app.security.verify_password") as mock_verify,
         ):
-
             mock_get_user.return_value = {
                 "id": 1,
                 "email": "testuser@example.com",
@@ -149,7 +146,6 @@ class TestAuthRouters:
             patch("app.crud.get_user_by_email") as mock_get_user,
             patch("app.security.verify_password") as mock_verify,
         ):
-
             mock_get_user.return_value = {
                 "id": 1,
                 "email": "inactive@example.com",
@@ -172,7 +168,6 @@ class TestAuthRouters:
             patch("app.crud.get_user") as mock_get_user,
             patch("app.security.create_access_token") as mock_token,
         ):
-
             mock_verify.return_value = {"user_id": 1}
             mock_get_user.return_value = {
                 "id": 1,
@@ -239,7 +234,6 @@ class TestAuthRouters:
             patch("app.dependencies.get_current_user") as mock_get_current,
             patch("app.crud.invalidate_user_tokens") as mock_invalidate,
         ):
-
             mock_get_current.return_value = {"id": 1}
             mock_invalidate.return_value = True
 
@@ -262,7 +256,6 @@ class TestAuthRouters:
             patch("app.security.verify_password") as mock_verify,
             patch("app.crud.update_user_password") as mock_update,
         ):
-
             mock_get_current.return_value = {
                 "id": 1,
                 "hashed_password": "hashed_old_password",
@@ -292,7 +285,6 @@ class TestAuthRouters:
             patch("app.dependencies.get_current_user") as mock_get_current,
             patch("app.security.verify_password") as mock_verify,
         ):
-
             mock_get_current.return_value = {
                 "id": 1,
                 "hashed_password": "hashed_old_password",
diff --git a/auto_generate_video_fold6/services/compliance-service/compliance_framework.py b/auto_generate_video_fold6/services/compliance-service/compliance_framework.py
index 5848c0c..5024a79 100644
--- a/auto_generate_video_fold6/services/compliance-service/compliance_framework.py
+++ b/auto_generate_video_fold6/services/compliance-service/compliance_framework.py
@@ -168,9 +168,9 @@ class GDPRCompliance:
 
         if not is_valid:
             logger.warning(
-                f"同意驗證失敗: {consent_record.consent_id}, 失敗項目: {[k for
-                                                               k, v \
-                                                                   in validations.items() if not v]}"
+                f"同意驗證失敗: {consent_record.consent_id}, 失敗項目: {
+                    [k for k, v in validations.items() if not v]
+                }"
             )
 
         return is_valid
@@ -517,7 +517,6 @@ class AuditLogger:
         try:
             alert_config = self.config.get("alerts", {})
             if alert_config.get("enabled", False):
-
                 alert_message = f"""
                 高風險合規事件警報
 
@@ -528,7 +527,7 @@ class AuditLogger:
                 操作: {event.action}
                 風險等級: {event.risk_level}
                 時間: {event.timestamp}
-                合規標準: {', '.join(event.compliance_tags)}
+                合規標準: {", ".join(event.compliance_tags)}
 
                 請立即檢查並採取適當措施。
                 """
diff --git a/auto_generate_video_fold6/services/graphql-gateway/app/middleware.py b/auto_generate_video_fold6/services/graphql-gateway/app/middleware.py
index e61541e..6b0cdf2 100644
--- a/auto_generate_video_fold6/services/graphql-gateway/app/middleware.py
+++ b/auto_generate_video_fold6/services/graphql-gateway/app/middleware.py
@@ -94,7 +94,9 @@ class CacheMiddleware(BaseHTTPMiddleware):
                     response_body += chunk
 
                 await self.cache_client.setex(
-                    cache_key, 300, response_body.decode()  # 5 分鐘 TTL
+                    cache_key,
+                    300,
+                    response_body.decode(),  # 5 分鐘 TTL
                 )
 
                 # 重建回應
diff --git a/auto_generate_video_fold6/services/music-service/suno_client.py b/auto_generate_video_fold6/services/music-service/suno_client.py
index 772794c..7e68566 100644
--- a/auto_generate_video_fold6/services/music-service/suno_client.py
+++ b/auto_generate_video_fold6/services/music-service/suno_client.py
@@ -109,7 +109,6 @@ class SunoClient:
             async with self.session.post(
                 f"{self.base_url}/api/generate", json=data
             ) as response:
-
                 if response.status != 200:
                     error_text = await response.text()
                     logger.error(
diff --git a/auto_generate_video_fold6/services/scheduler-service/app/entrepreneur_scheduler.py b/auto_generate_video_fold6/services/scheduler-service/app/entrepreneur_scheduler.py
index 91a8d90..13b4bfc 100644
--- a/auto_generate_video_fold6/services/scheduler-service/app/entrepreneur_scheduler.py
+++ b/auto_generate_video_fold6/services/scheduler-service/app/entrepreneur_scheduler.py
@@ -214,8 +214,9 @@ class EntrepreneurScheduler:
             if task.retry_count < self.config.retry_attempts:
                 task.retry_count += 1
                 logger.warning(
-                    f"任務執行失敗，準備重試 ({task.retry_count}/{self.config
-                                                       .retry_attempts}): {e}"
+                    f"任務執行失敗，準備重試 ({task.retry_count}/{
+                        self.config.retry_attempts
+                    }): {e}"
                 )
                 # 延遲後重試
                 await asyncio.sleep(self.config.retry_delay_minutes * 60)
@@ -315,9 +316,9 @@ class EntrepreneurScheduler:
             "config": {
                 "daily_video_limit": self.config.daily_video_limit,
                 "daily_budget_limit": self.config.daily_budget_limit,
-                "work_hours": f"{self.config.work_hours_start}-{self
-                                                                 \
-                                                                    .config.work_hours_end}",
+                "work_hours": f"{self.config.work_hours_start}-{
+                    self.config.work_hours_end
+                }",
             },
         }
 
diff --git a/auto_generate_video_fold6/services/scheduler-service/app/entrepreneur_scheduler_refactored.py b/auto_generate_video_fold6/services/scheduler-service/app/entrepreneur_scheduler_refactored.py
index bed39c5..c2aabe2 100644
--- a/auto_generate_video_fold6/services/scheduler-service/app/entrepreneur_scheduler_refactored.py
+++ b/auto_generate_video_fold6/services/scheduler-service/app/entrepreneur_scheduler_refactored.py
@@ -293,9 +293,9 @@ class StatisticsManager:
     def update_stats(self, task: ScheduledTask):
         """更新統計數據"""
         if task.status == TaskStatus.COMPLETED:
-            self.daily_stats[
-                "videos_generated"
-            ] += task.metrics.videos_generated
+            self.daily_stats["videos_generated"] += (
+                task.metrics.videos_generated
+            )
             self.daily_stats["budget_used"] += task.metrics.cost_incurred
             self.daily_stats["tasks_completed"] += 1
             self.daily_stats["total_execution_time"] += (
diff --git a/auto_generate_video_fold6/services/scheduler-service/app/routers/entrepreneur_scheduler_routes.py b/auto_generate_video_fold6/services/scheduler-service/app/routers/entrepreneur_scheduler_routes.py
index 800a21e..8594dcd 100644
--- a/auto_generate_video_fold6/services/scheduler-service/app/routers/entrepreneur_scheduler_routes.py
+++ b/auto_generate_video_fold6/services/scheduler-service/app/routers/entrepreneur_scheduler_routes.py
@@ -316,7 +316,7 @@ async def list_scheduled_tasks(
         # 排序和分頁
         user_tasks.sort(key=lambda x: x["created_at"], reverse=True)
         total = len(user_tasks)
-        tasks = user_tasks[offset: offset + limit]
+        tasks = user_tasks[offset : offset + limit]
 
         return {
             "tasks": tasks,
diff --git a/auto_generate_video_fold6/services/scheduler-service/app/routers/scheduler.py b/auto_generate_video_fold6/services/scheduler-service/app/routers/scheduler.py
index caf871c..108b00a 100644
--- a/auto_generate_video_fold6/services/scheduler-service/app/routers/scheduler.py
+++ b/auto_generate_video_fold6/services/scheduler-service/app/routers/scheduler.py
@@ -44,7 +44,7 @@ async def schedule_post(
                 PlatformAccount.id == request.platform_account_id,
                 PlatformAccount.user_id == current_user["user_id"],
                 PlatformAccount.platform == request.platform,
-                PlatformAccount.is_active  is True,
+                PlatformAccount.is_active is True,
             )
             .first()
         )
@@ -306,7 +306,7 @@ async def get_platform_accounts(
         db.query(PlatformAccount)
         .filter(
             PlatformAccount.user_id == current_user["user_id"],
-            PlatformAccount.is_active  is True,
+            PlatformAccount.is_active is True,
         )
         .all()
     )
diff --git a/auto_generate_video_fold6/services/scheduler-service/app/tasks.py b/auto_generate_video_fold6/services/scheduler-service/app/tasks.py
index 92b7f19..9d0b2f9 100644
--- a/auto_generate_video_fold6/services/scheduler-service/app/tasks.py
+++ b/auto_generate_video_fold6/services/scheduler-service/app/tasks.py
@@ -66,7 +66,7 @@ def publish_post(post_id: int):
             .filter(
                 PlatformAccount.user_id == post.user_id,
                 PlatformAccount.platform == post.platform,
-                PlatformAccount.is_active  is True,
+                PlatformAccount.is_active is True,
             )
             .first()
         )
diff --git a/auto_generate_video_fold6/services/scheduler-service/test_refactored_scheduler.py b/auto_generate_video_fold6/services/scheduler-service/test_refactored_scheduler.py
index 5a55e15..ea6116c 100644
--- a/auto_generate_video_fold6/services/scheduler-service/test_refactored_scheduler.py
+++ b/auto_generate_video_fold6/services/scheduler-service/test_refactored_scheduler.py
@@ -160,7 +160,8 @@ async def test_failure_and_retry():
     # 創建會失敗的 Mock 客戶端
     mock_client = MockVideoServiceClient(should_succeed=False, delay=0.05)
     config = SchedulerConfig(
-        retry_attempts=2, retry_delay_minutes=1  # 最小有效值
+        retry_attempts=2,
+        retry_delay_minutes=1,  # 最小有效值
     )
 
     scheduler = EntrepreneurScheduler(config, mock_client)
@@ -196,7 +197,8 @@ async def test_scheduler_lifecycle():
 
     mock_client = MockVideoServiceClient(should_succeed=True, delay=0.1)
     config = SchedulerConfig(
-        check_interval_minutes=1, health_check_interval_minutes=1  # 最小有效值
+        check_interval_minutes=1,
+        health_check_interval_minutes=1,  # 最小有效值
     )
 
     scheduler = EntrepreneurScheduler(config, mock_client)
diff --git a/auto_generate_video_fold6/services/scheduler-service/test_scheduler_simple.py b/auto_generate_video_fold6/services/scheduler-service/test_scheduler_simple.py
index 72d82a2..c35eb65 100644
--- a/auto_generate_video_fold6/services/scheduler-service/test_scheduler_simple.py
+++ b/auto_generate_video_fold6/services/scheduler-service/test_scheduler_simple.py
@@ -199,7 +199,8 @@ async def test_config_validation():
     # 測試無效限制
     try:
         invalid_config = SchedulerConfig(
-            daily_video_limit=0, daily_budget_limit=-5.0  # 無效限制
+            daily_video_limit=0,
+            daily_budget_limit=-5.0,  # 無效限制
         )
         invalid_config.validate()
         assert False, "應該拋出限制錯誤"
diff --git a/auto_generate_video_fold6/services/scheduler-service/tests/test_scheduler.py b/auto_generate_video_fold6/services/scheduler-service/tests/test_scheduler.py
index b34c139..2d8a211 100644
--- a/auto_generate_video_fold6/services/scheduler-service/tests/test_scheduler.py
+++ b/auto_generate_video_fold6/services/scheduler-service/tests/test_scheduler.py
@@ -141,7 +141,7 @@ def test_connect_platform_account(mock_verify_token, client, auth_headers):
     data = response.json()
     assert data["platform"] == account_data["platform"]
     assert data["platform_user_id"] == account_data["platform_user_id"]
-    assert data["is_active"]  is True
+    assert data["is_active"] is True
 
 
 @patch("app.auth.verify_token")
diff --git a/auto_generate_video_fold6/services/social-service/app/entrepreneur_publisher.py b/auto_generate_video_fold6/services/social-service/app/entrepreneur_publisher.py
index 0c65972..e463043 100644
--- a/auto_generate_video_fold6/services/social-service/app/entrepreneur_publisher.py
+++ b/auto_generate_video_fold6/services/social-service/app/entrepreneur_publisher.py
@@ -164,8 +164,9 @@ class EntrepreneurPublisher:
         """多平台批次發布"""
 
         try:
-            request_id = f"batch_{datetime.utcnow().strftime
-                                  ('%Y%m%d_%H%M%S')}_{request.user_id}"
+            request_id = f"batch_{
+                datetime.utcnow().strftime('%Y%m%d_%H%M%S')
+            }_{request.user_id}"
 
             batch_result = BatchPublishResult(
                 request_id=request_id,
@@ -445,11 +446,9 @@ class EntrepreneurPublisher:
                 return await client.publish_reel(
                     video_url=content["video_url"],
                     access_token=access_token,
-                    caption=f"{
-                        content['title']}\n\n{
-                        content['description']}\n\n{
-                        ' '.join(
-                            content['hashtags'])}",
+                    caption=f"{content['title']}\n\n{
+                        content['description']
+                    }\n\n{' '.join(content['hashtags'])}",
                     allow_comments=content.get("allow_comments", True),
                     allow_sharing=content.get("allow_sharing", True),
                 )
@@ -526,8 +525,9 @@ class EntrepreneurPublisher:
         """排程批次發布"""
 
         try:
-            request_id = f"scheduled_{datetime.utcnow().strftime
-                                      ('%Y%m%d_%H%M%S')}_{request.user_id}"
+            request_id = f"scheduled_{
+                datetime.utcnow().strftime('%Y%m%d_%H%M%S')
+            }_{request.user_id}"
 
             # 為每個平台創建排程任務
             for platform, scheduled_time in publish_times.items():
@@ -601,7 +601,7 @@ class EntrepreneurPublisher:
         # 按時間排序
         user_history.sort(key=lambda x: x.started_at, reverse=True)
 
-        return user_history[offset: offset + limit]
+        return user_history[offset : offset + limit]
 
     def get_active_publications(
         self, user_id: str
diff --git a/auto_generate_video_fold6/services/social-service/app/platforms/youtube.py b/auto_generate_video_fold6/services/social-service/app/platforms/youtube.py
index 8741972..c28d799 100644
--- a/auto_generate_video_fold6/services/social-service/app/platforms/youtube.py
+++ b/auto_generate_video_fold6/services/social-service/app/platforms/youtube.py
@@ -92,7 +92,8 @@ async def publish_video(
 
         # 使用 YouTube Data API v3 上傳影片
         upload_url = f"{
-            settings.YOUTUBE_API_BASE}/videos?uploadType=resumable&part=snippet,status"
+            settings.YOUTUBE_API_BASE
+        }/videos?uploadType=resumable&part=snippet,status"
 
         async with aiohttp.ClientSession() as session:
             # 初始化上傳
diff --git a/auto_generate_video_fold6/services/social-service/tests/test_platforms.py b/auto_generate_video_fold6/services/social-service/tests/test_platforms.py
index 4917538..61110cd 100644
--- a/auto_generate_video_fold6/services/social-service/tests/test_platforms.py
+++ b/auto_generate_video_fold6/services/social-service/tests/test_platforms.py
@@ -126,7 +126,7 @@ async def test_publish_to_tiktok_success(mock_publish):
 
     assert response.status_code == 200
     data = response.json()
-    assert data["success"]  is True
+    assert data["success"] is True
     assert data["post_id"] == "tiktok_post_123"
 
 
@@ -148,7 +148,7 @@ async def test_publish_to_tiktok_failure(mock_publish):
 
     assert response.status_code == 200
     data = response.json()
-    assert data["success"]  is False
+    assert data["success"] is False
     assert "Failed to publish to TikTok" in data["error"]
 
 
@@ -176,7 +176,7 @@ async def test_publish_to_youtube_success(mock_publish):
 
     assert response.status_code == 200
     data = response.json()
-    assert data["success"]  is True
+    assert data["success"] is True
     assert data["post_id"] == "youtube_video_456"
 
 
@@ -204,7 +204,7 @@ async def test_publish_to_instagram_success(mock_publish):
 
     assert response.status_code == 200
     data = response.json()
-    assert data["success"]  is True
+    assert data["success"] is True
     assert data["post_id"] == "instagram_post_789"
 
 
diff --git a/auto_generate_video_fold6/services/storage-service/app/models.py b/auto_generate_video_fold6/services/storage-service/app/models.py
index 8ec4d93..be8d51e 100644
--- a/auto_generate_video_fold6/services/storage-service/app/models.py
+++ b/auto_generate_video_fold6/services/storage-service/app/models.py
@@ -142,9 +142,9 @@ class FileProcessingJob(Base):
     completed_at = Column(DateTime(timezone=True))
 
     def __repr__(self):
-        return f"<FileProcessingJob(id={self.id}, job_type={self
-                                                             \
-                                                                .job_type}, status={self.status})>"
+        return f"<FileProcessingJob(id={self.id}, job_type={
+            self.job_type
+        }, status={self.status})>"
 
 
 class FileDownload(Base):
diff --git a/auto_generate_video_fold6/services/storage-service/app/routers/download.py b/auto_generate_video_fold6/services/storage-service/app/routers/download.py
index 0135da8..b0efb45 100644
--- a/auto_generate_video_fold6/services/storage-service/app/routers/download.py
+++ b/auto_generate_video_fold6/services/storage-service/app/routers/download.py
@@ -199,9 +199,9 @@ async def download_file(
                 yield file_data
 
             headers = {
-                "Content-Disposition": f'attachment; filename="{quote
-                                                                (file \
-                                                                    .original_filename)}"',
+                "Content-Disposition": f'attachment; filename="{
+                    quote(file.original_filename)
+                }"',
                 "Content-Type": file.mime_type,
                 "Content-Length": str(file.file_size),
             }
diff --git a/auto_generate_video_fold6/services/storage-service/app/routers/upload.py b/auto_generate_video_fold6/services/storage-service/app/routers/upload.py
index c865d0d..6a38699 100644
--- a/auto_generate_video_fold6/services/storage-service/app/routers/upload.py
+++ b/auto_generate_video_fold6/services/storage-service/app/routers/upload.py
@@ -199,8 +199,9 @@ async def upload_multiple_files(
         if len(files) > settings.max_upload_files:
             raise HTTPException(
                 status_code=400,
-                detail=f"Too many files. Maximum allowed: {settings
-                                                           .max_upload_files}",
+                detail=f"Too many files. Maximum allowed: {
+                    settings.max_upload_files
+                }",
             )
 
         uploaded_files = []
diff --git a/auto_generate_video_fold6/services/storage-service/app/storage.py b/auto_generate_video_fold6/services/storage-service/app/storage.py
index 3bbe1a6..c98ee45 100644
--- a/auto_generate_video_fold6/services/storage-service/app/storage.py
+++ b/auto_generate_video_fold6/services/storage-service/app/storage.py
@@ -334,9 +334,9 @@ class StorageManager:
 
         now = datetime.utcnow()
 
-        object_key = f"{user_id}/{file_type}/{now.year:04d}/{now
-                                                              \
-                                                                 .month:02d}/{safe_filename}"
+        object_key = f"{user_id}/{file_type}/{now.year:04d}/{now.month:02d}/{
+            safe_filename
+        }"
         return object_key
 
     def calculate_file_hash(self, file_data: bytes) -> str:
diff --git a/auto_generate_video_fold6/services/training-worker/main.py b/auto_generate_video_fold6/services/training-worker/main.py
index ee94101..548bcd3 100644
--- a/auto_generate_video_fold6/services/training-worker/main.py
+++ b/auto_generate_video_fold6/services/training-worker/main.py
@@ -205,8 +205,9 @@ def train_voice_model(self, task_data: Dict[str, Any]):
 
     except Exception as e:
         logger.error(
-            f"Training failed for task {task_data.get('task_id',
-                                                      'unknown')}: {str(e)}"
+            f"Training failed for task {task_data.get('task_id', 'unknown')}: {
+                str(e)
+            }"
         )
 
         task.status = TrainingStatus.FAILED
diff --git a/auto_generate_video_fold6/services/training-worker/tests/test_worker.py b/auto_generate_video_fold6/services/training-worker/tests/test_worker.py
index 9fe9338..a9ff864 100644
--- a/auto_generate_video_fold6/services/training-worker/tests/test_worker.py
+++ b/auto_generate_video_fold6/services/training-worker/tests/test_worker.py
@@ -43,10 +43,10 @@ def test_data_path_validation(mock_exists):
     def validate_data_path(path):
         return os.path.exists(path)
 
-    assert validate_data_path("/valid/path")  is True
+    assert validate_data_path("/valid/path") is True
 
     mock_exists.return_value = False
-    assert validate_data_path("/invalid/path")  is False
+    assert validate_data_path("/invalid/path") is False
 
 
 def test_training_config_validation():
@@ -63,7 +63,7 @@ def test_training_config_validation():
         required_keys = ["model_type", "epochs", "batch_size", "learning_rate"]
         return all(key in config for key in required_keys)
 
-    assert validate_config(valid_config)  is True
+    assert validate_config(valid_config) is True
 
     invalid_config = {"model_type": "voice_cloning"}
-    assert validate_config(invalid_config)  is False
+    assert validate_config(invalid_config) is False
diff --git a/auto_generate_video_fold6/services/video-service/ai/gemini_client.py b/auto_generate_video_fold6/services/video-service/ai/gemini_client.py
index 806ecb3..390cf91 100644
--- a/auto_generate_video_fold6/services/video-service/ai/gemini_client.py
+++ b/auto_generate_video_fold6/services/video-service/ai/gemini_client.py
@@ -302,7 +302,9 @@ Make sure the total duration of all scenes equals {duration} seconds.
             scene_type = (
                 "intro"
                 if i == 0
-                else "outro" if i == scene_count - 1 else "main"
+                else "outro"
+                if i == scene_count - 1
+                else "main"
             )
 
             scenes.append(
@@ -361,7 +363,7 @@ Please provide only the JSON array of caption segments.
                 # Fallback: split narration into chunks
                 words = narration.split()
                 return [
-                    " ".join(words[i: i + 5]) for i in range(0, len(words), 5)
+                    " ".join(words[i : i + 5]) for i in range(0, len(words), 5)
                 ]
 
         except Exception as e:
@@ -369,7 +371,7 @@ Please provide only the JSON array of caption segments.
             # Fallback: simple word chunking
             words = narration.split()
             return [
-                " ".join(words[i: i + 5]) for i in range(0, len(words), 5)
+                " ".join(words[i : i + 5]) for i in range(0, len(words), 5)
             ]
 
     async def close(self):
diff --git a/auto_generate_video_fold6/services/video-service/ai/stable_diffusion_client.py b/auto_generate_video_fold6/services/video-service/ai/stable_diffusion_client.py
index 2d0591a..1b5e402 100644
--- a/auto_generate_video_fold6/services/video-service/ai/stable_diffusion_client.py
+++ b/auto_generate_video_fold6/services/video-service/ai/stable_diffusion_client.py
@@ -173,12 +173,12 @@ class StableDiffusionClient:
                 f"{self.base_url}/generation/stable-diffusion-xl-1024-v1-0/text-to-image",
                 json=payload,
             ) as response:
-
                 if response.status != 200:
                     error_text = await response.text()
                     raise Exception(
-                        f"Stable Diffusion API error: {response
-                                                       .status} - {error_text}"
+                        f"Stable Diffusion API error: {response.status} - {
+                            error_text
+                        }"
                     )
 
                 result = await response.json()
@@ -229,7 +229,7 @@ class StableDiffusionClient:
         # Execute all tasks concurrently with some delay to avoid rate limits
         results = []
         for i in range(0, len(tasks), 3):  # Process 3 at a time
-            batch = tasks[i: i + 3]
+            batch = tasks[i : i + 3]
             batch_results = await asyncio.gather(
                 *batch, return_exceptions=True
             )
@@ -350,7 +350,6 @@ class StableDiffusionClient:
                 f"{self.base_url}/generation/esrgan-v1-x2plus/image-to-image/upscale",
                 json=payload,
             ) as response:
-
                 if response.status != 200:
                     error_text = await response.text()
                     raise Exception(
diff --git a/auto_generate_video_fold6/services/video-service/ai/suno_client.py b/auto_generate_video_fold6/services/video-service/ai/suno_client.py
index 90d0a6a..8bf6ec1 100644
--- a/auto_generate_video_fold6/services/video-service/ai/suno_client.py
+++ b/auto_generate_video_fold6/services/video-service/ai/suno_client.py
@@ -172,9 +172,9 @@ class SunoAIClient:
                         )
                     elif status == "failed":
                         raise Exception(
-                            f"Voice generation failed: {result.get
-                                                        ('error', \
-                                                            'Unknown error')}"
+                            f"Voice generation failed: {
+                                result.get('error', 'Unknown error')
+                            }"
                         )
                     elif status in ["queued", "processing"]:
                         # Check timeout
diff --git a/auto_generate_video_fold6/services/video-service/auth.py b/auto_generate_video_fold6/services/video-service/auth.py
index f5ec850..0937185 100644
--- a/auto_generate_video_fold6/services/video-service/auth.py
+++ b/auto_generate_video_fold6/services/video-service/auth.py
@@ -103,7 +103,6 @@ async def verify_token_remote(
                 headers=headers,
                 timeout=aiohttp.ClientTimeout(total=10),
             ) as response:
-
                 if response.status == 200:
                     result = await response.json()
                     user_id = result.get("user_id")
@@ -158,7 +157,6 @@ async def get_user_info(token: str) -> Optional[Dict[str, Any]]:
                 headers=headers,
                 timeout=aiohttp.ClientTimeout(total=10),
             ) as response:
-
                 if response.status == 200:
                     user_info = await response.json()
                     logger.debug(
@@ -249,7 +247,6 @@ async def check_user_permissions(
                 json=payload,
                 timeout=aiohttp.ClientTimeout(total=10),
             ) as response:
-
                 if response.status == 200:
                     result = await response.json()
                     has_permission = result.get("allowed", False)
diff --git a/auto_generate_video_fold6/services/video-service/routers/entrepreneur_workflows.py b/auto_generate_video_fold6/services/video-service/routers/entrepreneur_workflows.py
index 7ce7743..475f60c 100644
--- a/auto_generate_video_fold6/services/video-service/routers/entrepreneur_workflows.py
+++ b/auto_generate_video_fold6/services/video-service/routers/entrepreneur_workflows.py
@@ -398,7 +398,7 @@ async def list_user_workflows(
 
         # 分頁
         total = len(user_workflows)
-        workflows = user_workflows[offset: offset + limit]
+        workflows = user_workflows[offset : offset + limit]
 
         return {
             "workflows": workflows,
diff --git a/auto_generate_video_fold6/services/video-service/routers/social_media.py b/auto_generate_video_fold6/services/video-service/routers/social_media.py
index 2c4f09b..64466be 100644
--- a/auto_generate_video_fold6/services/video-service/routers/social_media.py
+++ b/auto_generate_video_fold6/services/video-service/routers/social_media.py
@@ -160,8 +160,7 @@ async def publish_to_social_media(
 
             return SocialPublishResponse(
                 success=successful > 0,
-                message=f"Published to {successful}/{len(request
-                                                         .platforms)} \
+                message=f"Published to {successful}/{len(request.platforms)} \
                                                              platforms successfully",
                 results=formatted_results,
                 total_platforms=len(request.platforms),
diff --git a/auto_generate_video_fold6/services/video-service/social/platforms.py b/auto_generate_video_fold6/services/video-service/social/platforms.py
index 782e00a..f4b0db7 100644
--- a/auto_generate_video_fold6/services/video-service/social/platforms.py
+++ b/auto_generate_video_fold6/services/video-service/social/platforms.py
@@ -155,7 +155,6 @@ class TikTokClient(SocialPlatform):
         async with session.post(
             f"{self.upload_url}/video/upload", data=data, headers=headers
         ) as response:
-
             if response.status != 200:
                 error_text = await response.text()
                 raise Exception(
@@ -201,7 +200,6 @@ class TikTokClient(SocialPlatform):
         async with session.post(
             f"{self.base_url}/video/publish", json=payload, headers=headers
         ) as response:
-
             if response.status != 200:
                 error_text = await response.text()
                 raise Exception(
@@ -237,7 +235,6 @@ class TikTokClient(SocialPlatform):
                 params={"video_id": platform_id},
                 headers=headers,
             ) as response:
-
                 if response.status != 200:
                     return {"error": f"API error: {response.status}"}
 
@@ -276,7 +273,6 @@ class TikTokClient(SocialPlatform):
                 params={"video_id": platform_id},
                 headers=headers,
             ) as response:
-
                 return response.status == 200
 
         except Exception as e:
@@ -383,7 +379,6 @@ class YouTubeClient(SocialPlatform):
             data=body,
             headers=headers,
         ) as response:
-
             if response.status != 200:
                 error_text = await response.text()
                 raise Exception(
@@ -454,7 +449,6 @@ class YouTubeClient(SocialPlatform):
                 params={"id": platform_id},
                 headers=headers,
             ) as response:
-
                 return response.status == 204
 
         except Exception as e:
@@ -524,12 +518,12 @@ class InstagramClient(SocialPlatform):
         async with session.post(
             f"{self.base_url}/{self.business_account_id}/media", params=params
         ) as response:
-
             if response.status != 200:
                 error_text = await response.text()
                 raise Exception(
-                    f"Instagram media creation error: {response
-                                                       .status} - {error_text}"
+                    f"Instagram media creation error: {response.status} - {
+                        error_text
+                    }"
                 )
 
             result = await response.json()
@@ -552,7 +546,6 @@ class InstagramClient(SocialPlatform):
             f"{self.base_url}/{self.business_account_id}/media_publish",
             params=params,
         ) as response:
-
             if response.status != 200:
                 error_text = await response.text()
                 raise Exception(
@@ -584,7 +577,6 @@ class InstagramClient(SocialPlatform):
             async with session.get(
                 f"{self.base_url}/{media_id}", params=params
             ) as response:
-
                 if response.status == 200:
                     result = await response.json()
                     return result.get("permalink")
@@ -610,7 +602,6 @@ class InstagramClient(SocialPlatform):
             async with session.get(
                 f"{self.base_url}/{platform_id}", params=params
             ) as response:
-
                 if response.status != 200:
                     return {"error": f"API error: {response.status}"}
 
@@ -648,7 +639,6 @@ class InstagramClient(SocialPlatform):
             async with session.delete(
                 f"{self.base_url}/{platform_id}", params=params
             ) as response:
-
                 return response.status == 200
 
         except Exception as e:
diff --git a/auto_generate_video_fold6/services/video-service/test_docker_validation.py b/auto_generate_video_fold6/services/video-service/test_docker_validation.py
index 994a209..d8863e4 100644
--- a/auto_generate_video_fold6/services/video-service/test_docker_validation.py
+++ b/auto_generate_video_fold6/services/video-service/test_docker_validation.py
@@ -122,9 +122,9 @@ def test_dockerfile_exists():
 
         # 基本 Dockerfile 驗證
         assert "FROM" in content, "Dockerfile should contain FROM instruction"
-        assert (
-            "WORKDIR" in content or "RUN" in content
-        ), "Dockerfile should contain basic instructions"
+        assert "WORKDIR" in content or "RUN" in content, (
+            "Dockerfile should contain basic instructions"
+        )
 
         print(f"✅ Dockerfile 存在於: {dockerfile_path}")
     else:
diff --git a/auto_generate_video_fold6/services/video-service/test_tdd_refactor.py b/auto_generate_video_fold6/services/video-service/test_tdd_refactor.py
index dba8be6..ccd37e3 100644
--- a/auto_generate_video_fold6/services/video-service/test_tdd_refactor.py
+++ b/auto_generate_video_fold6/services/video-service/test_tdd_refactor.py
@@ -55,9 +55,9 @@ class RefactorTest:
             pass  # 正確拋出異常
         except Exception as e:
             raise AssertionError(
-                f"Expected {exception_type.__name__}, but got {type(e
-                                                                    ) \
-                                                                        .__name__}: {e}"
+                f"Expected {exception_type.__name__}, but got {
+                    type(e).__name__
+                }: {e}"
             )
 
     def run_test(self, test_func, test_name):
diff --git a/auto_generate_video_fold6/services/video-service/tests/test_video_service.py b/auto_generate_video_fold6/services/video-service/tests/test_video_service.py
index 69e335a..4fd4082 100644
--- a/auto_generate_video_fold6/services/video-service/tests/test_video_service.py
+++ b/auto_generate_video_fold6/services/video-service/tests/test_video_service.py
@@ -195,9 +195,7 @@ class TestAIIntegration:
         with patch.object(client, "_get_session") as mock_session:
             mock_response = AsyncMock()
             mock_response.status = 200
-            mock_session.return_value.get.return_value.__aenter__.return_value = (
-                mock_response
-            )
+            mock_session.return_value.get.return_value.__aenter__.return_value = mock_response
 
             health = await client.health_check()
             assert health["status"] == "healthy"
@@ -255,9 +253,7 @@ class TestAIIntegration:
                     }
                 ]
             }
-            mock_session.return_value.post.return_value.__aenter__.return_value = (
-                mock_response
-            )
+            mock_session.return_value.post.return_value.__aenter__.return_value = mock_response
 
             with patch.object(
                 client,
@@ -306,7 +302,6 @@ class TestVideoComposition:
                     "_upload_media",
                     return_value="http://test.com/preview.mp4",
                 ):
-
                     result = await composer.create_video(
                         script_scenes=sample_script_response.scenes,
                         voice_url="http://test.com/voice.mp3",
@@ -361,7 +356,7 @@ class TestSocialMediaIntegration:
 
             result = await manager.publish_to_platform("tiktok", request)
 
-            assert result.success  is True
+            assert result.success is True
             assert result.platform == "tiktok"
             assert result.platform_id == "tiktok123"
 
diff --git a/auto_generate_video_fold6/services/video-service/video/composer.py b/auto_generate_video_fold6/services/video-service/video/composer.py
index 02df01e..91523f1 100644
--- a/auto_generate_video_fold6/services/video-service/video/composer.py
+++ b/auto_generate_video_fold6/services/video-service/video/composer.py
@@ -564,9 +564,9 @@ class VideoComposer:
         return {
             "duration": float(format_info.get("duration", 0)),
             "file_size": int(format_info.get("size", 0)),
-            "resolution": f"{video_stream.get('width', 0
-                                              )}x{video_stream.get \
-                                                  ('height', 0)}",
+            "resolution": f"{video_stream.get('width', 0)}x{
+                video_stream.get('height', 0)
+            }",
             "format": format_info.get("format_name", "mp4").split(",")[0],
         }
 
diff --git a/auto_generate_video_fold6/services/voice-enhancement/app/routers/cloning.py b/auto_generate_video_fold6/services/voice-enhancement/app/routers/cloning.py
index 8e7f8ae..f4032ba 100644
--- a/auto_generate_video_fold6/services/voice-enhancement/app/routers/cloning.py
+++ b/auto_generate_video_fold6/services/voice-enhancement/app/routers/cloning.py
@@ -107,7 +107,9 @@ async def create_voice_profile(
             # 讀取音訊數據
             audio_data = await audio_file.read()
             if len(audio_data) == 0:
-                raise HTTPException(status_code=400, detail=f"文件 {i + 1} 為空")
+                raise HTTPException(
+                    status_code=400, detail=f"文件 {i + 1} 為空"
+                )
 
             audio_samples.append(audio_data)
 
diff --git a/auto_generate_video_fold6/shared/api/standard_responses.py b/auto_generate_video_fold6/shared/api/standard_responses.py
index 4301f45..9256047 100644
--- a/auto_generate_video_fold6/shared/api/standard_responses.py
+++ b/auto_generate_video_fold6/shared/api/standard_responses.py
@@ -13,11 +13,12 @@ from dataclasses import dataclass
 import json
 
 
-T = TypeVar('T')
+T = TypeVar("T")
 
 
 class ResponseStatus(Enum):
     """回應狀態"""
+
     SUCCESS = "success"
     ERROR = "error"
     WARNING = "warning"
@@ -26,15 +27,16 @@ class ResponseStatus(Enum):
 
 class PaginationInfo(BaseModel):
     """分頁信息"""
+
     page: int = Field(ge=1, description="當前頁碼")
     size: int = Field(ge=1, le=100, description="每頁大小")
     total: int = Field(ge=0, description="總記錄數")
     pages: int = Field(ge=0, description="總頁數")
     has_next: bool = Field(description="是否有下一頁")
     has_prev: bool = Field(description="是否有上一頁")
-    
+
     @classmethod
-    def create(cls, page: int, size: int, total: int) -> 'PaginationInfo':
+    def create(cls, page: int, size: int, total: int) -> "PaginationInfo":
         """創建分頁信息"""
         pages = (total + size - 1) // size  # 向上取整
         return cls(
@@ -43,12 +45,13 @@ class PaginationInfo(BaseModel):
             total=total,
             pages=pages,
             has_next=page < pages,
-            has_prev=page > 1
+            has_prev=page > 1,
         )
 
 
 class APIMetadata(BaseModel):
     """API 元數據"""
+
     timestamp: str = Field(default_factory=lambda: datetime.now().isoformat())
     request_id: Optional[str] = None
     version: str = "v1"
@@ -61,22 +64,28 @@ class APIMetadata(BaseModel):
 
 class StandardResponse(BaseModel, Generic[T]):
     """標準 API 回應格式"""
-    
+
     status: ResponseStatus = Field(description="回應狀態")
     message: str = Field(description="回應消息")
     data: Optional[T] = Field(default=None, description="回應數據")
-    errors: Optional[List[Dict[str, Any]]] = Field(default=None, description="錯誤詳情")
+    errors: Optional[List[Dict[str, Any]]] = Field(
+        default=None, description="錯誤詳情"
+    )
     warnings: Optional[List[str]] = Field(default=None, description="警告信息")
-    pagination: Optional[PaginationInfo] = Field(default=None, description="分頁信息")
-    metadata: APIMetadata = Field(default_factory=APIMetadata, description="元數據")
-    
+    pagination: Optional[PaginationInfo] = Field(
+        default=None, description="分頁信息"
+    )
+    metadata: APIMetadata = Field(
+        default_factory=APIMetadata, description="元數據"
+    )
+
     class Config:
         use_enum_values = True
-        
+
     def to_dict(self) -> Dict[str, Any]:
         """轉換為字典"""
         return self.dict(exclude_none=True)
-    
+
     def to_json(self) -> str:
         """轉換為 JSON"""
         return json.dumps(self.to_dict(), ensure_ascii=False, default=str)
@@ -84,96 +93,97 @@ class StandardResponse(BaseModel, Generic[T]):
 
 class PaginatedResponse(StandardResponse[List[T]]):
     """分頁回應格式"""
+
     pagination: PaginationInfo = Field(description="分頁信息")
 
 
 class ResponseBuilder:
     """回應建構器"""
-    
+
     def __init__(self):
-        self.response_data = {
-            "metadata": APIMetadata()
-        }
-    
-    def status(self, status: ResponseStatus) -> 'ResponseBuilder':
+        self.response_data = {"metadata": APIMetadata()}
+
+    def status(self, status: ResponseStatus) -> "ResponseBuilder":
         """設置狀態"""
         self.response_data["status"] = status
         return self
-    
-    def message(self, message: str) -> 'ResponseBuilder':
+
+    def message(self, message: str) -> "ResponseBuilder":
         """設置消息"""
         self.response_data["message"] = message
         return self
-    
-    def data(self, data: Any) -> 'ResponseBuilder':
+
+    def data(self, data: Any) -> "ResponseBuilder":
         """設置數據"""
         self.response_data["data"] = data
         return self
-    
-    def errors(self, errors: List[Dict[str, Any]]) -> 'ResponseBuilder':
+
+    def errors(self, errors: List[Dict[str, Any]]) -> "ResponseBuilder":
         """設置錯誤"""
         self.response_data["errors"] = errors
         return self
-    
-    def add_error(self, code: str, message: str, field: str = None) -> 'ResponseBuilder':
+
+    def add_error(
+        self, code: str, message: str, field: str = None
+    ) -> "ResponseBuilder":
         """添加錯誤"""
         if "errors" not in self.response_data:
             self.response_data["errors"] = []
-        
+
         error = {"code": code, "message": message}
         if field:
             error["field"] = field
-        
+
         self.response_data["errors"].append(error)
         return self
-    
-    def warnings(self, warnings: List[str]) -> 'ResponseBuilder':
+
+    def warnings(self, warnings: List[str]) -> "ResponseBuilder":
         """設置警告"""
         self.response_data["warnings"] = warnings
         return self
-    
-    def add_warning(self, warning: str) -> 'ResponseBuilder':
+
+    def add_warning(self, warning: str) -> "ResponseBuilder":
         """添加警告"""
         if "warnings" not in self.response_data:
             self.response_data["warnings"] = []
         self.response_data["warnings"].append(warning)
         return self
-    
-    def pagination(self, pagination: PaginationInfo) -> 'ResponseBuilder':
+
+    def pagination(self, pagination: PaginationInfo) -> "ResponseBuilder":
         """設置分頁"""
         self.response_data["pagination"] = pagination
         return self
-    
-    def request_id(self, request_id: str) -> 'ResponseBuilder':
+
+    def request_id(self, request_id: str) -> "ResponseBuilder":
         """設置請求 ID"""
         self.response_data["metadata"].request_id = request_id
         return self
-    
-    def service(self, service: str) -> 'ResponseBuilder':
+
+    def service(self, service: str) -> "ResponseBuilder":
         """設置服務名稱"""
         self.response_data["metadata"].service = service
         return self
-    
-    def method(self, method: str) -> 'ResponseBuilder':
+
+    def method(self, method: str) -> "ResponseBuilder":
         """設置方法"""
         self.response_data["metadata"].method = method
         return self
-    
-    def path(self, path: str) -> 'ResponseBuilder':
+
+    def path(self, path: str) -> "ResponseBuilder":
         """設置路徑"""
         self.response_data["metadata"].path = path
         return self
-    
-    def execution_time(self, time_ms: float) -> 'ResponseBuilder':
+
+    def execution_time(self, time_ms: float) -> "ResponseBuilder":
         """設置執行時間"""
         self.response_data["metadata"].execution_time_ms = time_ms
         return self
-    
-    def user_id(self, user_id: str) -> 'ResponseBuilder':
+
+    def user_id(self, user_id: str) -> "ResponseBuilder":
         """設置用戶 ID"""
         self.response_data["metadata"].user_id = user_id
         return self
-    
+
     def build(self) -> StandardResponse:
         """建構回應"""
         return StandardResponse(**self.response_data)
@@ -181,19 +191,17 @@ class ResponseBuilder:
 
 # 快捷回應函數
 def success_response(
-    message: str = "操作成功",
-    data: Any = None,
-    request_id: str = None
+    message: str = "操作成功", data: Any = None, request_id: str = None
 ) -> StandardResponse:
     """成功回應"""
     builder = ResponseBuilder().status(ResponseStatus.SUCCESS).message(message)
-    
+
     if data is not None:
         builder.data(data)
-    
+
     if request_id:
         builder.request_id(request_id)
-    
+
     return builder.build()
 
 
@@ -201,70 +209,69 @@ def error_response(
     message: str,
     errors: List[Dict[str, Any]] = None,
     status_code: int = status.HTTP_400_BAD_REQUEST,
-    request_id: str = None
+    request_id: str = None,
 ) -> StandardResponse:
     """錯誤回應"""
     builder = ResponseBuilder().status(ResponseStatus.ERROR).message(message)
-    
+
     if errors:
         builder.errors(errors)
-    
+
     if request_id:
         builder.request_id(request_id)
-    
+
     return builder.build()
 
 
 def validation_error_response(
     field_errors: Dict[str, str],
     message: str = "輸入驗證失敗",
-    request_id: str = None
+    request_id: str = None,
 ) -> StandardResponse:
     """驗證錯誤回應"""
     errors = [
         {"code": "VALIDATION_ERROR", "field": field, "message": msg}
         for field, msg in field_errors.items()
     ]
-    
-    return error_response(message, errors, status.HTTP_422_UNPROCESSABLE_ENTITY, request_id)
+
+    return error_response(
+        message, errors, status.HTTP_422_UNPROCESSABLE_ENTITY, request_id
+    )
 
 
 def not_found_response(
-    resource: str = "資源",
-    request_id: str = None
+    resource: str = "資源", request_id: str = None
 ) -> StandardResponse:
     """未找到回應"""
     return error_response(
         f"{resource}未找到",
         [{"code": "NOT_FOUND", "message": f"請求的{resource}不存在"}],
         status.HTTP_404_NOT_FOUND,
-        request_id
+        request_id,
     )
 
 
 def unauthorized_response(
-    message: str = "未授權訪問",
-    request_id: str = None
+    message: str = "未授權訪問", request_id: str = None
 ) -> StandardResponse:
     """未授權回應"""
     return error_response(
         message,
         [{"code": "UNAUTHORIZED", "message": message}],
         status.HTTP_401_UNAUTHORIZED,
-        request_id
+        request_id,
     )
 
 
 def forbidden_response(
-    message: str = "權限不足",
-    request_id: str = None
+    message: str = "權限不足", request_id: str = None
 ) -> StandardResponse:
     """禁止訪問回應"""
     return error_response(
         message,
         [{"code": "FORBIDDEN", "message": message}],
         status.HTTP_403_FORBIDDEN,
-        request_id
+        request_id,
     )
 
 
@@ -272,58 +279,74 @@ def paginated_response(
     data: List[Any],
     pagination: PaginationInfo,
     message: str = "查詢成功",
-    request_id: str = None
+    request_id: str = None,
 ) -> PaginatedResponse:
     """分頁回應"""
-    builder = ResponseBuilder().status(ResponseStatus.SUCCESS).message(message).data(data).pagination(pagination)
-    
+    builder = (
+        ResponseBuilder()
+        .status(ResponseStatus.SUCCESS)
+        .message(message)
+        .data(data)
+        .pagination(pagination)
+    )
+
     if request_id:
         builder.request_id(request_id)
-    
+
     response_data = builder.build().dict()
     return PaginatedResponse(**response_data)
 
 
 def internal_error_response(
-    message: str = "內部服務錯誤",
-    request_id: str = None
+    message: str = "內部服務錯誤", request_id: str = None
 ) -> StandardResponse:
     """內部錯誤回應"""
     return error_response(
         message,
         [{"code": "INTERNAL_ERROR", "message": "服務暫時不可用，請稍後重試"}],
         status.HTTP_500_INTERNAL_SERVER_ERROR,
-        request_id
+        request_id,
     )
 
 
 def rate_limit_response(
     message: str = "請求頻率超出限制",
     retry_after: int = 60,
-    request_id: str = None
+    request_id: str = None,
 ) -> StandardResponse:
     """限流回應"""
     return error_response(
         message,
-        [{"code": "RATE_LIMIT_EXCEEDED", "message": f"請在 {retry_after} 秒後重試"}],
+        [
+            {
+                "code": "RATE_LIMIT_EXCEEDED",
+                "message": f"請在 {retry_after} 秒後重試",
+            }
+        ],
         status.HTTP_429_TOO_MANY_REQUESTS,
-        request_id
+        request_id,
     )
 
 
 # 資料模型標準化
 class StandardListQuery(BaseModel):
     """標準列表查詢參數"""
+
     page: int = Field(1, ge=1, description="頁碼")
     size: int = Field(20, ge=1, le=100, description="每頁大小")
     sort: Optional[str] = Field(None, description="排序字段")
-    order: Optional[str] = Field("asc", regex="^(asc|desc)$", description="排序方向")
-    search: Optional[str] = Field(None, min_length=1, max_length=100, description="搜索關鍵字")
+    order: Optional[str] = Field(
+        "asc", regex="^(asc|desc)$", description="排序方向"
+    )
+    search: Optional[str] = Field(
+        None, min_length=1, max_length=100, description="搜索關鍵字"
+    )
     filters: Optional[Dict[str, Any]] = Field(None, description="篩選條件")
 
 
 class StandardCreateResponse(BaseModel):
     """標準創建回應"""
+
     id: Union[str, int] = Field(description="創建的資源 ID")
     created_at: datetime = Field(description="創建時間")
     message: str = Field(default="創建成功", description="操作消息")
@@ -331,6 +354,7 @@ class StandardCreateResponse(BaseModel):
 
 class StandardUpdateResponse(BaseModel):
     """標準更新回應"""
+
     id: Union[str, int] = Field(description="更新的資源 ID")
     updated_at: datetime = Field(description="更新時間")
     message: str = Field(default="更新成功", description="操作消息")
@@ -338,6 +362,7 @@ class StandardUpdateResponse(BaseModel):
 
 class StandardDeleteResponse(BaseModel):
     """標準刪除回應"""
+
     id: Union[str, int] = Field(description="刪除的資源 ID")
     deleted_at: datetime = Field(description="刪除時間")
     message: str = Field(default="刪除成功", description="操作消息")
@@ -347,6 +372,7 @@ class StandardDeleteResponse(BaseModel):
 @dataclass
 class APIEndpointDoc:
     """API 端點文檔"""
+
     path: str
     method: str
     summary: str
@@ -356,7 +382,7 @@ class APIEndpointDoc:
     response_model: Optional[BaseModel] = None
     status_codes: Dict[int, str] = None
     examples: Dict[str, Any] = None
-    
+
     def __post_init__(self):
         if self.status_codes is None:
             self.status_codes = {
@@ -365,22 +391,22 @@ class APIEndpointDoc:
                 401: "未授權訪問",
                 403: "權限不足",
                 404: "資源未找到",
-                500: "內部服務錯誤"
+                500: "內部服務錯誤",
             }
 
 
 class APIDocumentationGenerator:
     """API 文檔生成器"""
-    
+
     def __init__(self, service_name: str, version: str = "v1"):
         self.service_name = service_name
         self.version = version
         self.endpoints = []
-    
+
     def add_endpoint(self, endpoint: APIEndpointDoc):
         """添加端點"""
         self.endpoints.append(endpoint)
-    
+
     def generate_openapi_spec(self) -> Dict[str, Any]:
         """生成 OpenAPI 規範"""
         spec = {
@@ -388,11 +414,17 @@ class APIDocumentationGenerator:
             "info": {
                 "title": f"{self.service_name} API",
                 "version": self.version,
-                "description": f"{self.service_name} 微服務 API 文檔"
+                "description": f"{self.service_name} 微服務 API 文檔",
             },
             "servers": [
-                {"url": f"http://localhost:8000/api/{self.version}", "description": "開發環境"},
-                {"url": f"https://api.autovideo.com/{self.version}", "description": "生產環境"}
+                {
+                    "url": f"http://localhost:8000/api/{self.version}",
+                    "description": "開發環境",
+                },
+                {
+                    "url": f"https://api.autovideo.com/{self.version}",
+                    "description": "生產環境",
+                },
             ],
             "paths": {},
             "components": {
@@ -400,22 +432,33 @@ class APIDocumentationGenerator:
                     "StandardResponse": {
                         "type": "object",
                         "properties": {
-                            "status": {"type": "string", "enum": ["success", "error", "warning", "info"]},
+                            "status": {
+                                "type": "string",
+                                "enum": [
+                                    "success",
+                                    "error",
+                                    "warning",
+                                    "info",
+                                ],
+                            },
                             "message": {"type": "string"},
                             "data": {"type": "object"},
-                            "errors": {"type": "array", "items": {"type": "object"}},
-                            "metadata": {"type": "object"}
-                        }
+                            "errors": {
+                                "type": "array",
+                                "items": {"type": "object"},
+                            },
+                            "metadata": {"type": "object"},
+                        },
                     }
                 }
-            }
+            },
         }
-        
+
         # 添加端點文檔
         for endpoint in self.endpoints:
             if endpoint.path not in spec["paths"]:
                 spec["paths"][endpoint.path] = {}
-            
+
             spec["paths"][endpoint.path][endpoint.method.lower()] = {
                 "summary": endpoint.summary,
                 "description": endpoint.description,
@@ -423,21 +466,21 @@ class APIDocumentationGenerator:
                 "responses": {
                     str(code): {"description": desc}
                     for code, desc in endpoint.status_codes.items()
-                }
+                },
             }
-        
+
         return spec
-    
+
     def save_documentation(self, output_file: str = None) -> str:
         """保存文檔"""
         if output_file is None:
             output_file = f"{self.service_name.lower()}_api_docs.json"
-        
+
         spec = self.generate_openapi_spec()
-        
-        with open(output_file, 'w', encoding='utf-8') as f:
+
+        with open(output_file, "w", encoding="utf-8") as f:
             json.dump(spec, f, indent=2, ensure_ascii=False)
-        
+
         return output_file
 
 
@@ -446,52 +489,51 @@ def monitor_response_time(func):
     """響應時間監控裝飾器"""
     import time
     from functools import wraps
-    
+
     @wraps(func)
     async def wrapper(*args, **kwargs):
         start_time = time.time()
         try:
             result = await func(*args, **kwargs)
             execution_time = (time.time() - start_time) * 1000
-            
+
             # 如果結果是 StandardResponse，更新執行時間
             if isinstance(result, StandardResponse):
                 result.metadata.execution_time_ms = execution_time
-            
+
             return result
         except Exception as e:
             execution_time = (time.time() - start_time) * 1000
             # 記錄錯誤和執行時間
             raise e
-    
+
     return wrapper
 
 
 if __name__ == "__main__":
     # 測試標準回應格式
     print("=== 標準 API 回應格式測試 ===")
-    
+
     # 成功回應
     success = success_response("用戶查詢成功", {"id": 1, "name": "測試用戶"})
     print("成功回應:")
     print(success.to_json())
-    
+
     # 錯誤回應
     error = validation_error_response(
         {"username": "用戶名不能為空", "email": "郵箱格式錯誤"}
     )
     print("\n驗證錯誤回應:")
     print(error.to_json())
-    
+
     # 分頁回應
     pagination = PaginationInfo.create(page=1, size=10, total=100)
     paginated = paginated_response(
-        [{"id": i, "name": f"用戶{i}"} for i in range(1, 11)],
-        pagination
+        [{"id": i, "name": f"用戶{i}"} for i in range(1, 11)], pagination
     )
     print("\n分頁回應:")
     print(paginated.to_json())
-    
+
     # API 文檔生成
     doc_gen = APIDocumentationGenerator("Auth Service")
     endpoint = APIEndpointDoc(
@@ -499,9 +541,9 @@ if __name__ == "__main__":
         method="GET",
         summary="獲取用戶列表",
         description="獲取系統中的用戶列表，支持分頁和搜索",
-        tags=["用戶管理"]
+        tags=["用戶管理"],
     )
     doc_gen.add_endpoint(endpoint)
-    
+
     docs_file = doc_gen.save_documentation()
-    print(f"\nAPI 文檔已生成: {docs_file}")
\ No newline at end of file
+    print(f"\nAPI 文檔已生成: {docs_file}")
diff --git a/auto_generate_video_fold6/shared/error_handling/unified_errors.py b/auto_generate_video_fold6/shared/error_handling/unified_errors.py
index 1943402..a8e2bd8 100644
--- a/auto_generate_video_fold6/shared/error_handling/unified_errors.py
+++ b/auto_generate_video_fold6/shared/error_handling/unified_errors.py
@@ -16,7 +16,7 @@ from pydantic import BaseModel
 
 class ErrorCode(Enum):
     """標準錯誤代碼"""
-    
+
     # 通用錯誤 (1000-1999)
     UNKNOWN_ERROR = "ERR_1000"
     VALIDATION_ERROR = "ERR_1001"
@@ -26,41 +26,41 @@ class ErrorCode(Enum):
     CONFLICT = "ERR_1005"
     RATE_LIMIT_EXCEEDED = "ERR_1006"
     SERVICE_UNAVAILABLE = "ERR_1007"
-    
+
     # 用戶相關錯誤 (2000-2999)
     USER_NOT_FOUND = "ERR_2001"
     USER_ALREADY_EXISTS = "ERR_2002"
     INVALID_CREDENTIALS = "ERR_2003"
     EMAIL_NOT_VERIFIED = "ERR_2004"
     PASSWORD_TOO_WEAK = "ERR_2005"
-    
+
     # 影片處理錯誤 (3000-3999)
     VIDEO_PROCESSING_FAILED = "ERR_3001"
     INVALID_VIDEO_FORMAT = "ERR_3002"
     VIDEO_TOO_LARGE = "ERR_3003"
     INSUFFICIENT_STORAGE = "ERR_3004"
     RENDERING_TIMEOUT = "ERR_3005"
-    
+
     # AI 服務錯誤 (4000-4999)
     AI_SERVICE_ERROR = "ERR_4001"
     MODEL_NOT_AVAILABLE = "ERR_4002"
     GENERATION_FAILED = "ERR_4003"
     QUOTA_EXCEEDED = "ERR_4004"
     INVALID_PROMPT = "ERR_4005"
-    
+
     # 社群媒體錯誤 (5000-5999)
     PLATFORM_API_ERROR = "ERR_5001"
     INVALID_API_KEY = "ERR_5002"
     UPLOAD_FAILED = "ERR_5003"
     PLATFORM_RATE_LIMIT = "ERR_5004"
     CONTENT_POLICY_VIOLATION = "ERR_5005"
-    
+
     # 資料庫錯誤 (6000-6999)
     DATABASE_CONNECTION_ERROR = "ERR_6001"
     DATABASE_TRANSACTION_ERROR = "ERR_6002"
     DATA_INTEGRITY_ERROR = "ERR_6003"
     MIGRATION_ERROR = "ERR_6004"
-    
+
     # 外部服務錯誤 (7000-7999)
     EXTERNAL_API_ERROR = "ERR_7001"
     NETWORK_TIMEOUT = "ERR_7002"
@@ -70,6 +70,7 @@ class ErrorCode(Enum):
 
 class ErrorSeverity(Enum):
     """錯誤嚴重程度"""
+
     LOW = "low"
     MEDIUM = "medium"
     HIGH = "high"
@@ -78,6 +79,7 @@ class ErrorSeverity(Enum):
 
 class ErrorCategory(Enum):
     """錯誤分類"""
+
     USER_ERROR = "user_error"
     SYSTEM_ERROR = "system_error"
     EXTERNAL_ERROR = "external_error"
@@ -86,6 +88,7 @@ class ErrorCategory(Enum):
 
 class ErrorDetail(BaseModel):
     """錯誤詳情"""
+
     field: Optional[str] = None
     message: str
     code: Optional[str] = None
@@ -93,7 +96,7 @@ class ErrorDetail(BaseModel):
 
 class UnifiedError(BaseModel):
     """統一錯誤格式"""
-    
+
     code: str
     message: str
     details: Optional[List[ErrorDetail]] = None
@@ -107,11 +110,11 @@ class UnifiedError(BaseModel):
     path: Optional[str] = None
     stack_trace: Optional[str] = None
     context: Optional[Dict[str, Any]] = None
-    
+
     def to_dict(self) -> Dict[str, Any]:
         """轉換為字典格式"""
         return self.dict(exclude_none=True)
-    
+
     def to_json(self) -> str:
         """轉換為 JSON 格式"""
         return json.dumps(self.to_dict(), ensure_ascii=False, indent=2)
@@ -119,93 +122,95 @@ class UnifiedError(BaseModel):
 
 class ErrorBuilder:
     """錯誤建構器"""
-    
+
     def __init__(self):
         self.error_data = {
             "timestamp": datetime.now().isoformat(),
             "severity": ErrorSeverity.MEDIUM.value,
-            "category": ErrorCategory.SYSTEM_ERROR.value
+            "category": ErrorCategory.SYSTEM_ERROR.value,
         }
-    
-    def code(self, error_code: Union[ErrorCode, str]) -> 'ErrorBuilder':
+
+    def code(self, error_code: Union[ErrorCode, str]) -> "ErrorBuilder":
         """設置錯誤代碼"""
         if isinstance(error_code, ErrorCode):
             self.error_data["code"] = error_code.value
         else:
             self.error_data["code"] = error_code
         return self
-    
-    def message(self, message: str) -> 'ErrorBuilder':
+
+    def message(self, message: str) -> "ErrorBuilder":
         """設置錯誤消息"""
         self.error_data["message"] = message
         return self
-    
-    def details(self, details: List[ErrorDetail]) -> 'ErrorBuilder':
+
+    def details(self, details: List[ErrorDetail]) -> "ErrorBuilder":
         """設置錯誤詳情"""
         self.error_data["details"] = details
         return self
-    
-    def add_detail(self, field: str = None, message: str = "", code: str = None) -> 'ErrorBuilder':
+
+    def add_detail(
+        self, field: str = None, message: str = "", code: str = None
+    ) -> "ErrorBuilder":
         """添加錯誤詳情"""
         if "details" not in self.error_data:
             self.error_data["details"] = []
-        
+
         detail = ErrorDetail(field=field, message=message, code=code)
         self.error_data["details"].append(detail)
         return self
-    
-    def severity(self, severity: ErrorSeverity) -> 'ErrorBuilder':
+
+    def severity(self, severity: ErrorSeverity) -> "ErrorBuilder":
         """設置嚴重程度"""
         self.error_data["severity"] = severity.value
         return self
-    
-    def category(self, category: ErrorCategory) -> 'ErrorBuilder':
+
+    def category(self, category: ErrorCategory) -> "ErrorBuilder":
         """設置錯誤分類"""
         self.error_data["category"] = category.value
         return self
-    
-    def request_id(self, request_id: str) -> 'ErrorBuilder':
+
+    def request_id(self, request_id: str) -> "ErrorBuilder":
         """設置請求 ID"""
         self.error_data["request_id"] = request_id
         return self
-    
-    def user_id(self, user_id: str) -> 'ErrorBuilder':
+
+    def user_id(self, user_id: str) -> "ErrorBuilder":
         """設置用戶 ID"""
         self.error_data["user_id"] = user_id
         return self
-    
-    def service(self, service: str) -> 'ErrorBuilder':
+
+    def service(self, service: str) -> "ErrorBuilder":
         """設置服務名稱"""
         self.error_data["service"] = service
         return self
-    
-    def method(self, method: str) -> 'ErrorBuilder':
+
+    def method(self, method: str) -> "ErrorBuilder":
         """設置方法名稱"""
         self.error_data["method"] = method
         return self
-    
-    def path(self, path: str) -> 'ErrorBuilder':
+
+    def path(self, path: str) -> "ErrorBuilder":
         """設置請求路徑"""
         self.error_data["path"] = path
         return self
-    
-    def context(self, context: Dict[str, Any]) -> 'ErrorBuilder':
+
+    def context(self, context: Dict[str, Any]) -> "ErrorBuilder":
         """設置上下文信息"""
         self.error_data["context"] = context
         return self
-    
-    def add_context(self, key: str, value: Any) -> 'ErrorBuilder':
+
+    def add_context(self, key: str, value: Any) -> "ErrorBuilder":
         """添加上下文信息"""
         if "context" not in self.error_data:
             self.error_data["context"] = {}
         self.error_data["context"][key] = value
         return self
-    
-    def with_stack_trace(self) -> 'ErrorBuilder':
+
+    def with_stack_trace(self) -> "ErrorBuilder":
         """添加堆疊追蹤"""
         self.error_data["stack_trace"] = traceback.format_exc()
         return self
-    
+
     def build(self) -> UnifiedError:
         """建構錯誤對象"""
         return UnifiedError(**self.error_data)
@@ -213,79 +218,99 @@ class ErrorBuilder:
 
 class ErrorHandler:
     """錯誤處理器"""
-    
+
     def __init__(self, service_name: str, logger: logging.Logger = None):
         self.service_name = service_name
         self.logger = logger or logging.getLogger(__name__)
-    
-    def handle_error(self, error: Exception, request_id: str = None, 
-                    user_id: str = None, context: Dict[str, Any] = None) -> UnifiedError:
+
+    def handle_error(
+        self,
+        error: Exception,
+        request_id: str = None,
+        user_id: str = None,
+        context: Dict[str, Any] = None,
+    ) -> UnifiedError:
         """處理異常並轉換為統一錯誤格式"""
-        
+
         builder = ErrorBuilder().service(self.service_name)
-        
+
         if request_id:
             builder.request_id(request_id)
-        
+
         if user_id:
             builder.user_id(user_id)
-        
+
         if context:
             builder.context(context)
-        
+
         # 根據異常類型設置錯誤信息
         if isinstance(error, ValueError):
-            builder.code(ErrorCode.VALIDATION_ERROR).message(str(error)).category(ErrorCategory.USER_ERROR)
+            builder.code(ErrorCode.VALIDATION_ERROR).message(
+                str(error)
+            ).category(ErrorCategory.USER_ERROR)
         elif isinstance(error, FileNotFoundError):
-            builder.code(ErrorCode.NOT_FOUND).message("資源未找到").category(ErrorCategory.USER_ERROR)
+            builder.code(ErrorCode.NOT_FOUND).message("資源未找到").category(
+                ErrorCategory.USER_ERROR
+            )
         elif isinstance(error, PermissionError):
-            builder.code(ErrorCode.AUTHORIZATION_ERROR).message("權限不足").category(ErrorCategory.USER_ERROR)
+            builder.code(ErrorCode.AUTHORIZATION_ERROR).message(
+                "權限不足"
+            ).category(ErrorCategory.USER_ERROR)
         elif isinstance(error, ConnectionError):
-            builder.code(ErrorCode.EXTERNAL_API_ERROR).message("外部服務連接失敗").category(ErrorCategory.EXTERNAL_ERROR).severity(ErrorSeverity.HIGH)
+            builder.code(ErrorCode.EXTERNAL_API_ERROR).message(
+                "外部服務連接失敗"
+            ).category(ErrorCategory.EXTERNAL_ERROR).severity(
+                ErrorSeverity.HIGH
+            )
         elif isinstance(error, TimeoutError):
-            builder.code(ErrorCode.SERVICE_TIMEOUT).message("服務超時").category(ErrorCategory.SYSTEM_ERROR).severity(ErrorSeverity.HIGH)
+            builder.code(ErrorCode.SERVICE_TIMEOUT).message(
+                "服務超時"
+            ).category(ErrorCategory.SYSTEM_ERROR).severity(ErrorSeverity.HIGH)
         else:
-            builder.code(ErrorCode.UNKNOWN_ERROR).message(f"未知錯誤: {str(error)}").severity(ErrorSeverity.HIGH)
-        
+            builder.code(ErrorCode.UNKNOWN_ERROR).message(
+                f"未知錯誤: {str(error)}"
+            ).severity(ErrorSeverity.HIGH)
+
         # 在開發模式下添加堆疊追蹤
         import os
+
         if os.getenv("DEBUG", "false").lower() == "true":
             builder.with_stack_trace()
-        
+
         unified_error = builder.build()
-        
+
         # 記錄錯誤
         self._log_error(unified_error)
-        
+
         return unified_error
-    
+
     def _log_error(self, error: UnifiedError):
         """記錄錯誤"""
         log_level = self._get_log_level(error.severity)
-        
+
         log_message = f"[{error.code}] {error.message}"
-        
+
         extra_data = {
             "error_code": error.code,
             "severity": error.severity,
             "category": error.category,
             "service": error.service,
             "request_id": error.request_id,
-            "user_id": error.user_id
+            "user_id": error.user_id,
         }
-        
+
         self.logger.log(log_level, log_message, extra=extra_data)
-    
+
     def _get_log_level(self, severity: str) -> int:
         """根據嚴重程度獲取日誌級別"""
         mapping = {
             ErrorSeverity.LOW.value: logging.INFO,
             ErrorSeverity.MEDIUM.value: logging.WARNING,
             ErrorSeverity.HIGH.value: logging.ERROR,
-            ErrorSeverity.CRITICAL.value: logging.CRITICAL
+            ErrorSeverity.CRITICAL.value: logging.CRITICAL,
         }
         return mapping.get(severity, logging.ERROR)
-    
+
     def to_http_exception(self, error: UnifiedError) -> HTTPException:
         """轉換為 FastAPI HTTP 異常"""
         status_code_mapping = {
@@ -297,14 +322,13 @@ class ErrorHandler:
             ErrorCode.RATE_LIMIT_EXCEEDED.value: status.HTTP_429_TOO_MANY_REQUESTS,
             ErrorCode.SERVICE_UNAVAILABLE.value: status.HTTP_503_SERVICE_UNAVAILABLE,
         }
-        
-        status_code = status_code_mapping.get(error.code, status.HTTP_500_INTERNAL_SERVER_ERROR)
-        
-        return HTTPException(
-            status_code=status_code,
-            detail=error.to_dict()
+
+        status_code = status_code_mapping.get(
+            error.code, status.HTTP_500_INTERNAL_SERVER_ERROR
         )
 
+        return HTTPException(status_code=status_code, detail=error.to_dict())
+
 
 # 全域錯誤處理器實例
 _global_handlers: Dict[str, ErrorHandler] = {}
@@ -328,7 +352,9 @@ def create_error(error_code: ErrorCode, message: str = None) -> ErrorBuilder:
 # 常用錯誤快捷函數
 def validation_error(message: str, field: str = None) -> UnifiedError:
     """創建驗證錯誤"""
-    builder = create_error(ErrorCode.VALIDATION_ERROR, message).category(ErrorCategory.USER_ERROR)
+    builder = create_error(ErrorCode.VALIDATION_ERROR, message).category(
+        ErrorCategory.USER_ERROR
+    )
     if field:
         builder.add_detail(field=field, message=message)
     return builder.build()
@@ -336,71 +362,79 @@ def validation_error(message: str, field: str = None) -> UnifiedError:
 
 def not_found_error(resource: str) -> UnifiedError:
     """創建資源未找到錯誤"""
-    return create_error(
-        ErrorCode.NOT_FOUND, 
-        f"{resource} 未找到"
-    ).category(ErrorCategory.USER_ERROR).build()
+    return (
+        create_error(ErrorCode.NOT_FOUND, f"{resource} 未找到")
+        .category(ErrorCategory.USER_ERROR)
+        .build()
+    )
 
 
 def unauthorized_error(message: str = "未授權訪問") -> UnifiedError:
     """創建未授權錯誤"""
-    return create_error(
-        ErrorCode.AUTHORIZATION_ERROR, 
-        message
-    ).category(ErrorCategory.USER_ERROR).build()
+    return (
+        create_error(ErrorCode.AUTHORIZATION_ERROR, message)
+        .category(ErrorCategory.USER_ERROR)
+        .build()
+    )
 
 
 def internal_error(message: str = "內部服務錯誤") -> UnifiedError:
     """創建內部錯誤"""
-    return create_error(
-        ErrorCode.UNKNOWN_ERROR, 
-        message
-    ).severity(ErrorSeverity.HIGH).build()
+    return (
+        create_error(ErrorCode.UNKNOWN_ERROR, message)
+        .severity(ErrorSeverity.HIGH)
+        .build()
+    )
 
 
 def external_service_error(service: str, message: str = None) -> UnifiedError:
     """創建外部服務錯誤"""
     if message is None:
         message = f"{service} 服務暫時不可用"
-    
-    return create_error(
-        ErrorCode.EXTERNAL_API_ERROR, 
-        message
-    ).category(ErrorCategory.EXTERNAL_ERROR).severity(ErrorSeverity.HIGH).add_context("external_service", service).build()
+
+    return (
+        create_error(ErrorCode.EXTERNAL_API_ERROR, message)
+        .category(ErrorCategory.EXTERNAL_ERROR)
+        .severity(ErrorSeverity.HIGH)
+        .add_context("external_service", service)
+        .build()
+    )
 
 
 # 錯誤統計和監控
 class ErrorMetrics:
     """錯誤指標收集"""
-    
+
     def __init__(self):
         self.error_counts = {}
         self.error_history = []
-    
+
     def record_error(self, error: UnifiedError):
         """記錄錯誤"""
         # 統計錯誤計數
         key = f"{error.service}:{error.code}"
         self.error_counts[key] = self.error_counts.get(key, 0) + 1
-        
+
         # 保存錯誤歷史 (最近1000條)
-        self.error_history.append({
-            "timestamp": error.timestamp,
-            "service": error.service,
-            "code": error.code,
-            "severity": error.severity,
-            "category": error.category
-        })
-        
+        self.error_history.append(
+            {
+                "timestamp": error.timestamp,
+                "service": error.service,
+                "code": error.code,
+                "severity": error.severity,
+                "category": error.category,
+            }
+        )
+
         if len(self.error_history) > 1000:
             self.error_history = self.error_history[-1000:]
-    
+
     def get_error_stats(self) -> Dict[str, Any]:
         """獲取錯誤統計"""
         return {
             "total_errors": len(self.error_history),
             "error_counts": self.error_counts,
-            "recent_errors": self.error_history[-10:]  # 最近10條
+            "recent_errors": self.error_history[-10:],  # 最近10條
         }
 
 
@@ -411,30 +445,36 @@ error_metrics = ErrorMetrics()
 if __name__ == "__main__":
     # 測試錯誤處理系統
     print("=== 統一錯誤處理系統測試 ===")
-    
+
     # 測試錯誤建構器
-    error = create_error(ErrorCode.VALIDATION_ERROR, "用戶名不能為空").add_detail(
-        field="username", message="用戶名是必填欄位"
-    ).severity(ErrorSeverity.MEDIUM).category(ErrorCategory.USER_ERROR).build()
-    
+    error = (
+        create_error(ErrorCode.VALIDATION_ERROR, "用戶名不能為空")
+        .add_detail(field="username", message="用戶名是必填欄位")
+        .severity(ErrorSeverity.MEDIUM)
+        .category(ErrorCategory.USER_ERROR)
+        .build()
+    )
+
     print("建構的錯誤:")
     print(error.to_json())
-    
+
     # 測試錯誤處理器
     handler = ErrorHandler("test-service")
-    
+
     try:
         raise ValueError("測試錯誤")
     except Exception as e:
-        handled_error = handler.handle_error(e, request_id="req-123", user_id="user-456")
+        handled_error = handler.handle_error(
+            e, request_id="req-123", user_id="user-456"
+        )
         print("\n處理後的錯誤:")
         print(handled_error.to_json())
-    
+
     # 測試快捷函數
     validation_err = validation_error("密碼太短", "password")
     print("\n驗證錯誤:")
     print(validation_err.to_json())
-    
+
     not_found_err = not_found_error("用戶")
     print("\n未找到錯誤:")
-    print(not_found_err.to_json())
\ No newline at end of file
+    print(not_found_err.to_json())
diff --git a/auto_generate_video_fold6/test_docker_containerization.py b/auto_generate_video_fold6/test_docker_containerization.py
index 9b62c93..384a825 100644
--- a/auto_generate_video_fold6/test_docker_containerization.py
+++ b/auto_generate_video_fold6/test_docker_containerization.py
@@ -19,17 +19,14 @@ import logging
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
+
 class DockerContainerizationTest:
     """Docker 容器化 TDD 測試套件"""
-    
+
     def __init__(self):
         self.project_root = Path(__file__).parent
-        self.results = {
-            "tests_passed": 0,
-            "tests_failed": 0,
-            "errors": []
-        }
-    
+        self.results = {"tests_passed": 0, "tests_failed": 0, "errors": []}
+
     def _record_result(self, test_name: str, success: bool, error: str = None):
         """記錄測試結果"""
         if success:
@@ -39,145 +36,205 @@ class DockerContainerizationTest:
             self.results["tests_failed"] += 1
             self.results["errors"].append(f"{test_name}: {error}")
             logger.error(f"❌ {test_name} 失敗: {error}")
-    
+
     def test_dockerfile_exists_and_multistage(self):
         """測試 Dockerfile 存在且為多階段構建"""
         try:
             # 檢查各服務的 Dockerfile
             expected_dockerfiles = [
                 "services/trend-service/Dockerfile",
-                "services/video-service/Dockerfile", 
+                "services/video-service/Dockerfile",
                 "services/social-service/Dockerfile",
                 "services/scheduler-service/Dockerfile",
-                "frontend/Dockerfile"
+                "frontend/Dockerfile",
             ]
-            
+
             for dockerfile_path in expected_dockerfiles:
                 full_path = self.project_root / dockerfile_path
-                assert full_path.exists(), f"Dockerfile 不存在: {dockerfile_path}"
-                
+                assert full_path.exists(), (
+                    f"Dockerfile 不存在: {dockerfile_path}"
+                )
+
                 # 讀取 Dockerfile 內容
                 content = full_path.read_text()
-                
+
                 # 檢查多階段構建標記
                 stages = content.count("FROM ")
-                assert stages >= 2, f"Dockerfile {dockerfile_path} 不是多階段構建 (只有 {stages} 個 FROM)"
-                
+                assert stages >= 2, (
+                    f"Dockerfile {dockerfile_path} 不是多階段構建 (只有 {stages} 個 FROM)"
+                )
+
                 # 檢查必要的構建階段（不區分大小寫）
                 content_lower = content.lower()
-                assert "as builder" in content_lower or "as build" in content_lower, f"缺少 builder 階段: {dockerfile_path}"
-                assert "as runtime" in content_lower or "as production" in content_lower, f"缺少 runtime 階段: {dockerfile_path}"
-            
+                assert (
+                    "as builder" in content_lower
+                    or "as build" in content_lower
+                ), f"缺少 builder 階段: {dockerfile_path}"
+                assert (
+                    "as runtime" in content_lower
+                    or "as production" in content_lower
+                ), f"缺少 runtime 階段: {dockerfile_path}"
+
             self._record_result("dockerfile_multistage_structure", True)
-            
+
         except Exception as e:
-            self._record_result("dockerfile_multistage_structure", False, str(e))
-    
+            self._record_result(
+                "dockerfile_multistage_structure", False, str(e)
+            )
+
     def test_docker_compose_production_config(self):
         """測試生產級 Docker Compose 配置"""
         try:
             compose_files = [
                 "docker-compose.yml",
                 "docker-compose.prod.yml",
-                "docker-compose.dev.yml"
+                "docker-compose.dev.yml",
             ]
-            
+
             for compose_file in compose_files:
                 full_path = self.project_root / compose_file
-                assert full_path.exists(), f"Docker Compose 文件不存在: {compose_file}"
-                
+                assert full_path.exists(), (
+                    f"Docker Compose 文件不存在: {compose_file}"
+                )
+
                 # 解析 YAML 配置
-                with open(full_path, 'r') as f:
+                with open(full_path, "r") as f:
                     config = yaml.safe_load(f)
-                
+
                 # 檢查服務定義
-                assert "services" in config, f"缺少 services 定義: {compose_file}"
-                
+                assert "services" in config, (
+                    f"缺少 services 定義: {compose_file}"
+                )
+
                 expected_services = [
-                    "trend-service", "video-service", "social-service", 
-                    "scheduler-service", "frontend", "postgres", "redis"
+                    "trend-service",
+                    "video-service",
+                    "social-service",
+                    "scheduler-service",
+                    "frontend",
+                    "postgres",
+                    "redis",
                 ]
-                
+
                 for service in expected_services:
-                    assert service in config["services"], f"缺少服務定義: {service} in {compose_file}"
-                
+                    assert service in config["services"], (
+                        f"缺少服務定義: {service} in {compose_file}"
+                    )
+
                 # 檢查生產配置特定要求
                 if "prod" in compose_file:
                     # 檢查資源限制
-                    for service_name, service_config in config["services"].items():
-                        if service_name in ["trend-service", "video-service", "social-service", "scheduler-service"]:
-                            assert "deploy" in service_config, f"生產服務缺少 deploy 配置: {service_name}"
-                            assert "resources" in service_config["deploy"], f"缺少資源限制: {service_name}"
-            
+                    for service_name, service_config in config[
+                        "services"
+                    ].items():
+                        if service_name in [
+                            "trend-service",
+                            "video-service",
+                            "social-service",
+                            "scheduler-service",
+                        ]:
+                            assert "deploy" in service_config, (
+                                f"生產服務缺少 deploy 配置: {service_name}"
+                            )
+                            assert "resources" in service_config["deploy"], (
+                                f"缺少資源限制: {service_name}"
+                            )
+
             self._record_result("docker_compose_production_config", True)
-            
+
         except Exception as e:
-            self._record_result("docker_compose_production_config", False, str(e))
-    
+            self._record_result(
+                "docker_compose_production_config", False, str(e)
+            )
+
     def test_dockerfile_optimization_practices(self):
         """測試 Dockerfile 優化實踐"""
         try:
             dockerfile_paths = [
                 "services/trend-service/Dockerfile",
-                "services/video-service/Dockerfile"
+                "services/video-service/Dockerfile",
             ]
-            
+
             for dockerfile_path in dockerfile_paths:
                 full_path = self.project_root / dockerfile_path
                 if not full_path.exists():
                     continue
-                    
+
                 content = full_path.read_text()
-                
+
                 # 檢查優化實踐
                 optimizations = {
                     "使用 .dockerignore": True,  # 將在後續檢查
-                    "多階段構建減少映像大小": "FROM python:3.11-slim" in content,
-                    "合併 RUN 指令": content.count("RUN") <= 5,  # 限制 RUN 指令數量
-                    "清理快取": "rm -rf" in content or "apt-get clean" in content,
+                    "多階段構建減少映像大小": "FROM python:3.11-slim"
+                    in content,
+                    "合併 RUN 指令": content.count("RUN")
+                    <= 5,  # 限制 RUN 指令數量
+                    "清理快取": "rm -rf" in content
+                    or "apt-get clean" in content,
                     "非 root 用戶": "USER " in content,
-                    "健康檢查": "HEALTHCHECK" in content
+                    "健康檢查": "HEALTHCHECK" in content,
                 }
-                
+
                 for optimization, passed in optimizations.items():
                     if optimization == "使用 .dockerignore":
                         dockerignore_path = full_path.parent / ".dockerignore"
                         passed = dockerignore_path.exists()
-                    
+
                     if not passed:
-                        logger.warning(f"優化建議: {dockerfile_path} - {optimization}")
-            
+                        logger.warning(
+                            f"優化建議: {dockerfile_path} - {optimization}"
+                        )
+
             self._record_result("dockerfile_optimization_practices", True)
-            
+
         except Exception as e:
-            self._record_result("dockerfile_optimization_practices", False, str(e))
-    
+            self._record_result(
+                "dockerfile_optimization_practices", False, str(e)
+            )
+
     def test_container_security_practices(self):
         """測試容器安全實踐"""
         try:
             security_checks = []
-            
+
             # 檢查 .dockerignore 文件
-            for service_dir in ["services/trend-service", "services/video-service", "frontend"]:
-                dockerignore_path = self.project_root / service_dir / ".dockerignore"
+            for service_dir in [
+                "services/trend-service",
+                "services/video-service",
+                "frontend",
+            ]:
+                dockerignore_path = (
+                    self.project_root / service_dir / ".dockerignore"
+                )
                 if dockerignore_path.exists():
                     content = dockerignore_path.read_text()
-                    
+
                     # 檢查敏感文件排除
-                    sensitive_patterns = [".env", "*.key", "*.pem", ".git", "node_modules", "__pycache__"]
+                    sensitive_patterns = [
+                        ".env",
+                        "*.key",
+                        "*.pem",
+                        ".git",
+                        "node_modules",
+                        "__pycache__",
+                    ]
                     for pattern in sensitive_patterns:
                         if pattern not in content:
-                            security_checks.append(f"缺少排除模式: {pattern} in {dockerignore_path}")
-            
+                            security_checks.append(
+                                f"缺少排除模式: {pattern} in {dockerignore_path}"
+                            )
+
             # 檢查環境變數安全
             compose_path = self.project_root / "docker-compose.prod.yml"
             if compose_path.exists():
-                with open(compose_path, 'r') as f:
+                with open(compose_path, "r") as f:
                     config = yaml.safe_load(f)
-                
-                for service_name, service_config in config.get("services", {}).items():
+
+                for service_name, service_config in config.get(
+                    "services", {}
+                ).items():
                     env_vars = service_config.get("environment", {})
-                    
+
                     # 處理環境變數格式（可能是字典或列表）
                     if isinstance(env_vars, list):
                         # 如果是列表格式，跳過詳細檢查
@@ -187,229 +244,305 @@ class DockerContainerizationTest:
                         sensitive_vars = ["PASSWORD", "SECRET", "KEY", "TOKEN"]
                         for var_name, var_value in env_vars.items():
                             for sensitive in sensitive_vars:
-                                if sensitive in var_name.upper() and not str(var_value).startswith("${"):
-                                    security_checks.append(f"硬編碼敏感變數: {var_name} in {service_name}")
-            
+                                if sensitive in var_name.upper() and not str(
+                                    var_value
+                                ).startswith("${"):
+                                    security_checks.append(
+                                        f"硬編碼敏感變數: {var_name} in {service_name}"
+                                    )
+
             # 如果有安全問題，記錄但不失敗（因為這是初始測試）
             if security_checks:
                 logger.warning(f"安全建議: {security_checks}")
-            
+
             self._record_result("container_security_practices", True)
-            
+
         except Exception as e:
             self._record_result("container_security_practices", False, str(e))
-    
+
     def test_build_and_run_simulation(self):
         """測試構建和運行模擬（不實際構建）"""
         try:
             # 模擬構建過程檢查
             build_requirements = {
                 "Python 後端服務": {
-                    "requirements_files": ["requirements.txt", "requirements-prod.txt"],
+                    "requirements_files": [
+                        "requirements.txt",
+                        "requirements-prod.txt",
+                    ],
                     "app_files": ["main.py", "app.py"],
-                    "config_files": ["config/", "settings.py"]
+                    "config_files": ["config/", "settings.py"],
                 },
                 "前端服務": {
                     "package_files": ["package.json", "package-lock.json"],
                     "build_files": ["vite.config.js", "tailwind.config.js"],
-                    "source_files": ["src/", "public/"]
-                }
+                    "source_files": ["src/", "public/"],
+                },
             }
-            
+
             # 檢查構建所需文件
             missing_files = []
-            
+
             # 檢查後端服務文件
-            for service_dir in ["services/trend-service", "services/video-service"]:
+            for service_dir in [
+                "services/trend-service",
+                "services/video-service",
+            ]:
                 service_path = self.project_root / service_dir
                 if service_path.exists():
-                    for req_file in build_requirements["Python 後端服務"]["requirements_files"]:
+                    for req_file in build_requirements["Python 後端服務"][
+                        "requirements_files"
+                    ]:
                         if not (service_path / req_file).exists():
                             missing_files.append(f"{service_dir}/{req_file}")
-            
+
             # 檢查前端文件
             frontend_path = self.project_root / "frontend"
             if frontend_path.exists():
-                for req_file in build_requirements["前端服務"]["package_files"]:
+                for req_file in build_requirements["前端服務"][
+                    "package_files"
+                ]:
                     if not (frontend_path / req_file).exists():
                         missing_files.append(f"frontend/{req_file}")
-            
+
             # 記錄缺少的文件（不會導致測試失敗，因為這是 Red 階段）
             if missing_files:
                 logger.info(f"待創建的構建文件: {missing_files}")
-            
+
             self._record_result("build_requirements_check", True)
-            
+
         except Exception as e:
             self._record_result("build_requirements_check", False, str(e))
-    
+
     def test_service_discovery_and_networking(self):
         """測試服務發現和網路配置"""
         try:
             compose_path = self.project_root / "docker-compose.yml"
-            
+
             # 如果文件不存在，記錄為預期失敗
             if not compose_path.exists():
-                self._record_result("service_networking_config", False, "docker-compose.yml 不存在（預期失敗）")
+                self._record_result(
+                    "service_networking_config",
+                    False,
+                    "docker-compose.yml 不存在（預期失敗）",
+                )
                 return
-            
-            with open(compose_path, 'r') as f:
+
+            with open(compose_path, "r") as f:
                 config = yaml.safe_load(f)
-            
+
             # 檢查網路配置
             networks = config.get("networks", {})
             assert "app-network" in networks, "缺少應用網路定義"
-            
+
             # 檢查服務網路連接
-            for service_name, service_config in config.get("services", {}).items():
-                if service_name not in ["postgres", "redis"]:  # 排除基礎設施服務
+            for service_name, service_config in config.get(
+                "services", {}
+            ).items():
+                if service_name not in [
+                    "postgres",
+                    "redis",
+                ]:  # 排除基礎設施服務
                     networks_config = service_config.get("networks", [])
-                    assert "app-network" in networks_config, f"服務 {service_name} 未加入應用網路"
-            
+                    assert "app-network" in networks_config, (
+                        f"服務 {service_name} 未加入應用網路"
+                    )
+
             # 檢查端口暴露配置
             exposed_services = ["frontend", "trend-service", "video-service"]
             for service in exposed_services:
                 if service in config["services"]:
                     ports = config["services"][service].get("ports", [])
                     assert len(ports) > 0, f"服務 {service} 未暴露端口"
-            
+
             self._record_result("service_networking_config", True)
-            
+
         except Exception as e:
             self._record_result("service_networking_config", False, str(e))
-    
+
     def test_health_checks_and_monitoring(self):
         """測試健康檢查和監控配置"""
         try:
             compose_path = self.project_root / "docker-compose.yml"
-            
+
             if not compose_path.exists():
-                self._record_result("health_monitoring_config", False, "docker-compose.yml 不存在（預期失敗）")
+                self._record_result(
+                    "health_monitoring_config",
+                    False,
+                    "docker-compose.yml 不存在（預期失敗）",
+                )
                 return
-            
-            with open(compose_path, 'r') as f:
+
+            with open(compose_path, "r") as f:
                 config = yaml.safe_load(f)
-            
+
             # 檢查健康檢查配置
-            app_services = ["trend-service", "video-service", "social-service", "scheduler-service"]
-            
+            app_services = [
+                "trend-service",
+                "video-service",
+                "social-service",
+                "scheduler-service",
+            ]
+
             for service in app_services:
                 if service in config["services"]:
                     service_config = config["services"][service]
                     healthcheck = service_config.get("healthcheck", {})
-                    
+
                     # 檢查健康檢查配置
                     if not healthcheck:
                         logger.warning(f"服務 {service} 缺少健康檢查配置")
                         continue
-                    
+
                     # 檢查健康檢查參數
-                    required_params = ["test", "interval", "timeout", "retries"]
+                    required_params = [
+                        "test",
+                        "interval",
+                        "timeout",
+                        "retries",
+                    ]
                     for param in required_params:
                         if param not in healthcheck:
-                            logger.warning(f"服務 {service} 健康檢查缺少參數: {param}")
-            
+                            logger.warning(
+                                f"服務 {service} 健康檢查缺少參數: {param}"
+                            )
+
             # 檢查監控服務配置（如果存在）
             monitoring_services = ["prometheus", "grafana", "jaeger"]
             for monitor_service in monitoring_services:
                 if monitor_service in config.get("services", {}):
                     logger.info(f"發現監控服務: {monitor_service}")
-            
+
             self._record_result("health_monitoring_config", True)
-            
+
         except Exception as e:
             self._record_result("health_monitoring_config", False, str(e))
-    
+
     def test_environment_configuration(self):
         """測試環境配置管理"""
         try:
             # 檢查環境配置文件
-            env_files = [".env.example", ".env.prod.example", ".env.dev.example"]
+            env_files = [
+                ".env.example",
+                ".env.prod.example",
+                ".env.dev.example",
+            ]
             existing_env_files = []
-            
+
             for env_file in env_files:
                 env_path = self.project_root / env_file
                 if env_path.exists():
                     existing_env_files.append(env_file)
-                    
+
                     # 讀取並檢查環境變數
                     content = env_path.read_text()
-                    
+
                     # 檢查必要的環境變數
                     required_vars = [
-                        "DATABASE_URL", "REDIS_URL", "JWT_SECRET",
-                        "API_BASE_URL", "OPENAI_API_KEY"
+                        "DATABASE_URL",
+                        "REDIS_URL",
+                        "JWT_SECRET",
+                        "API_BASE_URL",
+                        "OPENAI_API_KEY",
                     ]
-                    
+
                     for var in required_vars:
                         if var not in content:
-                            logger.warning(f"環境文件 {env_file} 缺少變數: {var}")
-            
+                            logger.warning(
+                                f"環境文件 {env_file} 缺少變數: {var}"
+                            )
+
             # 檢查 Docker Compose 環境變數使用
             compose_files = ["docker-compose.yml", "docker-compose.prod.yml"]
             for compose_file in compose_files:
                 compose_path = self.project_root / compose_file
                 if compose_path.exists():
-                    with open(compose_path, 'r') as f:
+                    with open(compose_path, "r") as f:
                         config = yaml.safe_load(f)
-                    
+
                     # 檢查環境變數引用格式
-                    for service_name, service_config in config.get("services", {}).items():
+                    for service_name, service_config in config.get(
+                        "services", {}
+                    ).items():
                         env_vars = service_config.get("environment", {})
-                        
+
                         # 處理不同的環境變數格式
                         if isinstance(env_vars, dict):
                             for var_name, var_value in env_vars.items():
-                                if isinstance(var_value, str) and var_value.startswith("$"):
-                                    logger.info(f"發現環境變數引用: {var_name}={var_value} in {service_name}")
+                                if isinstance(
+                                    var_value, str
+                                ) and var_value.startswith("$"):
+                                    logger.info(
+                                        f"發現環境變數引用: {var_name}={var_value} in {service_name}"
+                                    )
                         elif isinstance(env_vars, list):
                             for env_item in env_vars:
-                                if isinstance(env_item, str) and "=" in env_item:
-                                    var_name, var_value = env_item.split("=", 1)
+                                if (
+                                    isinstance(env_item, str)
+                                    and "=" in env_item
+                                ):
+                                    var_name, var_value = env_item.split(
+                                        "=", 1
+                                    )
                                     if var_value.startswith("$"):
-                                        logger.info(f"發現環境變數引用: {var_name}={var_value} in {service_name}")
-            
+                                        logger.info(
+                                            f"發現環境變數引用: {var_name}={var_value} in {service_name}"
+                                        )
+
             # 記錄結果（允許部分缺失，因為這是 Red 階段）
             self._record_result("environment_configuration", True)
-            
+
         except Exception as e:
             self._record_result("environment_configuration", False, str(e))
-    
+
     def print_results(self):
         """打印測試結果"""
-        total_tests = self.results["tests_passed"] + self.results["tests_failed"]
-        success_rate = (self.results["tests_passed"] / total_tests * 100) if total_tests > 0 else 0
-        
+        total_tests = (
+            self.results["tests_passed"] + self.results["tests_failed"]
+        )
+        success_rate = (
+            (self.results["tests_passed"] / total_tests * 100)
+            if total_tests > 0
+            else 0
+        )
+
         logger.info("=" * 60)
         logger.info("🔴 TDD Red 階段: Docker 容器化測試結果")
         logger.info("=" * 60)
         logger.info(f"✅ 通過測試: {self.results['tests_passed']}")
         logger.info(f"❌ 失敗測試: {self.results['tests_failed']}")
         logger.info(f"📈 當前完成率: {success_rate:.1f}%")
-        
+
         if self.results["errors"]:
             logger.info("\n🎯 需要實作的功能:")
             for error in self.results["errors"]:
                 logger.info(f"  - {error}")
-        
+
         # Red 階段評估
         if success_rate < 30:
-            logger.info("\n🔴 TDD Red 階段狀態: 完美 - 大部分測試失敗，定義了清晰的目標")
+            logger.info(
+                "\n🔴 TDD Red 階段狀態: 完美 - 大部分測試失敗，定義了清晰的目標"
+            )
         elif success_rate < 60:
-            logger.info("\n🟡 TDD Red 階段狀態: 良好 - 有些基礎已存在，需要更多實作")
+            logger.info(
+                "\n🟡 TDD Red 階段狀態: 良好 - 有些基礎已存在，需要更多實作"
+            )
         else:
-            logger.info("\n🟢 TDD Red 階段狀態: 意外 - 很多功能已存在，可能需要調整測試")
-        
+            logger.info(
+                "\n🟢 TDD Red 階段狀態: 意外 - 很多功能已存在，可能需要調整測試"
+            )
+
         return success_rate < 50  # Red 階段期望低成功率
 
+
 def main():
     """執行 Docker 容器化 TDD Red 階段測試"""
     logger.info("🔴 開始 TDD Red 階段: Docker 容器化測試")
     logger.info("目標: 定義生產級 Docker 多階段構建的期望行為")
     logger.info("=" * 60)
-    
+
     test_suite = DockerContainerizationTest()
-    
+
     try:
         # 執行所有測試
         test_suite.test_dockerfile_exists_and_multistage()
@@ -420,10 +553,10 @@ def main():
         test_suite.test_service_discovery_and_networking()
         test_suite.test_health_checks_and_monitoring()
         test_suite.test_environment_configuration()
-        
+
         # 打印結果
         is_proper_red = test_suite.print_results()
-        
+
         if is_proper_red:
             logger.info("\n🎉 TDD Red 階段成功！")
             logger.info("✨ 已定義完整的 Docker 容器化需求")
@@ -431,19 +564,20 @@ def main():
         else:
             logger.info("\n🤔 TDD Red 階段意外通過較多測試")
             logger.info("🔧 可能需要調整測試或檢查現有實作")
-        
+
         return is_proper_red
-        
+
     except Exception as e:
         logger.error(f"❌ Red 階段測試執行異常: {e}")
         return False
 
+
 if __name__ == "__main__":
     success = main()
-    
+
     if success:
         logger.info("🏁 TDD Red 階段完成 - Docker 容器化需求已定義")
         exit(0)
     else:
         logger.error("🛑 TDD Red 階段需要調整")
-        exit(1)
\ No newline at end of file
+        exit(1)
diff --git a/auto_generate_video_fold6/test_e2e_entrepreneur_workflow.py b/auto_generate_video_fold6/test_e2e_entrepreneur_workflow.py
index 75b58b2..3ebf8ea 100644
--- a/auto_generate_video_fold6/test_e2e_entrepreneur_workflow.py
+++ b/auto_generate_video_fold6/test_e2e_entrepreneur_workflow.py
@@ -30,9 +30,9 @@ logger = logging.getLogger(__name__)
 # 服務端點配置
 SERVICES = {
     "trend_service": "http://localhost:8001",
-    "video_service": "http://localhost:8003", 
+    "video_service": "http://localhost:8003",
     "social_service": "http://localhost:8004",
-    "scheduler_service": "http://localhost:8008"
+    "scheduler_service": "http://localhost:8008",
 }
 
 # 測試配置
@@ -48,22 +48,23 @@ TEST_CONFIG = {
         "check_interval_minutes": 1,
         "categories": ["technology", "ai"],
         "platforms": ["tiktok", "youtube-shorts"],
-        "auto_publish": True
+        "auto_publish": True,
     },
     "expected_workflow_steps": [
         "trend_analysis",
-        "keyword_extraction", 
+        "keyword_extraction",
         "script_generation",
         "image_generation",
         "voice_synthesis",
         "video_composition",
-        "platform_publishing"
-    ]
+        "platform_publishing",
+    ],
 }
 
+
 class E2ETestResult:
     """E2E 測試結果追蹤"""
-    
+
     def __init__(self):
         self.start_time = datetime.utcnow()
         self.service_health_checks: Dict[str, bool] = {}
@@ -71,257 +72,315 @@ class E2ETestResult:
         self.errors: List[str] = []
         self.success_rate = 0.0
         self.total_execution_time = 0.0
-        
+
     def add_error(self, error: str):
         self.errors.append(f"[{datetime.utcnow().isoformat()}] {error}")
         logger.error(error)
-        
-    def add_step_result(self, step: str, success: bool, duration: float, details: Dict = None):
+
+    def add_step_result(
+        self, step: str, success: bool, duration: float, details: Dict = None
+    ):
         self.workflow_steps[step] = {
             "success": success,
             "duration": duration,
             "timestamp": datetime.utcnow().isoformat(),
-            "details": details or {}
+            "details": details or {},
         }
-        
+
     def finalize(self):
-        self.total_execution_time = (datetime.utcnow() - self.start_time).total_seconds()
-        successful_steps = sum(1 for step in self.workflow_steps.values() if step["success"])
-        self.success_rate = (successful_steps / len(self.workflow_steps)) * 100 if self.workflow_steps else 0
+        self.total_execution_time = (
+            datetime.utcnow() - self.start_time
+        ).total_seconds()
+        successful_steps = sum(
+            1 for step in self.workflow_steps.values() if step["success"]
+        )
+        self.success_rate = (
+            (successful_steps / len(self.workflow_steps)) * 100
+            if self.workflow_steps
+            else 0
+        )
 
 
 class E2ETestRunner:
     """端對端測試執行器"""
-    
+
     def __init__(self):
         self.session: Optional[aiohttp.ClientSession] = None
         self.result = E2ETestResult()
-        
+
     async def __aenter__(self):
         self.session = aiohttp.ClientSession(
             timeout=aiohttp.ClientTimeout(total=300)  # 5分鐘超時
         )
         return self
-        
+
     async def __aexit__(self, exc_type, exc_val, exc_tb):
         if self.session:
             await self.session.close()
-            
+
     async def health_check_services(self) -> bool:
         """檢查所有服務健康狀態"""
         logger.info("🏥 開始服務健康檢查...")
-        
+
         all_healthy = True
         for service_name, base_url in SERVICES.items():
             try:
                 async with self.session.get(f"{base_url}/health") as response:
                     is_healthy = response.status == 200
-                    self.result.service_health_checks[service_name] = is_healthy
-                    
+                    self.result.service_health_checks[service_name] = (
+                        is_healthy
+                    )
+
                     if is_healthy:
                         logger.info(f"✅ {service_name} 健康狀態正常")
                     else:
-                        logger.error(f"❌ {service_name} 健康檢查失敗 (HTTP {response.status})")
+                        logger.error(
+                            f"❌ {service_name} 健康檢查失敗 (HTTP {response.status})"
+                        )
                         all_healthy = False
-                        
+
             except Exception as e:
                 self.result.service_health_checks[service_name] = False
                 self.result.add_error(f"{service_name} 連接失敗: {str(e)}")
                 all_healthy = False
-                
+
         return all_healthy
-        
+
     async def test_trend_analysis_flow(self) -> Dict[str, Any]:
         """測試趨勢分析流程"""
         logger.info("📈 測試趨勢分析流程...")
         start_time = time.time()
-        
+
         try:
             # 1. 觸發趨勢抓取
-            trend_url = f"{SERVICES['trend_service']}/api/v1/entrepreneur/fetch-trends"
+            trend_url = (
+                f"{SERVICES['trend_service']}/api/v1/entrepreneur/fetch-trends"
+            )
             trend_payload = {
                 "categories": TEST_CONFIG["entrepreneur_config"]["categories"],
                 "platforms": ["tiktok", "youtube"],
                 "hours_back": 24,
-                "min_engagement": 1000
+                "min_engagement": 1000,
             }
-            
-            async with self.session.post(trend_url, json=trend_payload) as response:
+
+            async with self.session.post(
+                trend_url, json=trend_payload
+            ) as response:
                 if response.status != 200:
                     raise Exception(f"趨勢抓取失敗: HTTP {response.status}")
-                    
+
                 trend_data = await response.json()
-                
+
             # 2. 驗證趨勢數據格式
             required_fields = ["trends", "total_count", "categories_analyzed"]
             for field in required_fields:
                 if field not in trend_data:
                     raise Exception(f"趨勢數據缺少必要欄位: {field}")
-                    
+
             # 3. 檢查趨勢品質
             trends = trend_data.get("trends", [])
             if len(trends) < 3:
                 raise Exception(f"趨勢數量不足，僅獲得 {len(trends)} 個趨勢")
-                
+
             high_quality_trends = [
-                t for t in trends 
-                if t.get("engagement_score", 0) >= 0.7
+                t for t in trends if t.get("engagement_score", 0) >= 0.7
             ]
-            
+
             duration = time.time() - start_time
-            self.result.add_step_result("trend_analysis", True, duration, {
-                "trends_found": len(trends),
-                "high_quality_trends": len(high_quality_trends),
-                "categories": trend_data.get("categories_analyzed", [])
-            })
-            
+            self.result.add_step_result(
+                "trend_analysis",
+                True,
+                duration,
+                {
+                    "trends_found": len(trends),
+                    "high_quality_trends": len(high_quality_trends),
+                    "categories": trend_data.get("categories_analyzed", []),
+                },
+            )
+
             return trend_data
-            
+
         except Exception as e:
             duration = time.time() - start_time
             self.result.add_step_result("trend_analysis", False, duration)
             self.result.add_error(f"趨勢分析失敗: {str(e)}")
             raise
-            
+
     async def test_scheduler_configuration(self) -> str:
         """測試排程器配置"""
         logger.info("⚙️ 測試排程器配置...")
         start_time = time.time()
-        
+
         try:
             # 配置排程器
             config_url = f"{SERVICES['scheduler_service']}/api/v1/entrepreneur-scheduler/configure"
             config_payload = TEST_CONFIG["entrepreneur_config"]
-            
+
             # 添加測試用戶認證頭 (在實際環境中會從認證服務獲取)
             headers = {
                 "Authorization": "Bearer test_token_e2e",
-                "Content-Type": "application/json"
+                "Content-Type": "application/json",
             }
-            
-            async with self.session.post(config_url, json=config_payload, headers=headers) as response:
+
+            async with self.session.post(
+                config_url, json=config_payload, headers=headers
+            ) as response:
                 if response.status != 200:
                     raise Exception(f"排程器配置失敗: HTTP {response.status}")
-                    
+
                 config_result = await response.json()
-                
+
             # 啟動排程器
             start_url = f"{SERVICES['scheduler_service']}/api/v1/entrepreneur-scheduler/start"
-            async with self.session.post(start_url, headers=headers) as response:
+            async with self.session.post(
+                start_url, headers=headers
+            ) as response:
                 if response.status != 200:
                     raise Exception(f"排程器啟動失敗: HTTP {response.status}")
-                    
+
                 start_result = await response.json()
-                
+
             duration = time.time() - start_time
-            self.result.add_step_result("scheduler_config", True, duration, {
-                "config_status": config_result.get("status"),
-                "scheduler_status": start_result.get("status")
-            })
-            
+            self.result.add_step_result(
+                "scheduler_config",
+                True,
+                duration,
+                {
+                    "config_status": config_result.get("status"),
+                    "scheduler_status": start_result.get("status"),
+                },
+            )
+
             return start_result.get("message", "排程器已啟動")
-            
+
         except Exception as e:
             duration = time.time() - start_time
             self.result.add_step_result("scheduler_config", False, duration)
             self.result.add_error(f"排程器配置失敗: {str(e)}")
             raise
-            
-    async def test_video_workflow_execution(self, trend_data: Dict[str, Any]) -> Dict[str, Any]:
+
+    async def test_video_workflow_execution(
+        self, trend_data: Dict[str, Any]
+    ) -> Dict[str, Any]:
         """測試影片工作流程執行"""
         logger.info("🎬 測試影片工作流程執行...")
         start_time = time.time()
-        
+
         try:
             # 選擇最高分趨勢
             trends = trend_data.get("trends", [])
             if not trends:
                 raise Exception("沒有可用的趨勢數據")
-                
-            best_trend = max(trends, key=lambda t: t.get("engagement_score", 0))
-            
+
+            best_trend = max(
+                trends, key=lambda t: t.get("engagement_score", 0)
+            )
+
             # 創建影片工作流程
-            workflow_url = f"{SERVICES['video_service']}/api/v1/entrepreneur/create"
+            workflow_url = (
+                f"{SERVICES['video_service']}/api/v1/entrepreneur/create"
+            )
             workflow_payload = {
                 "user_id": TEST_CONFIG["user_id"],
                 "trend_keywords": best_trend.get("keywords", []),
                 "video_count": 1,
                 "categories": TEST_CONFIG["entrepreneur_config"]["categories"],
                 "platforms": TEST_CONFIG["entrepreneur_config"]["platforms"],
-                "quality_threshold": 0.8
+                "quality_threshold": 0.8,
             }
-            
+
             headers = {
                 "Authorization": "Bearer test_token_e2e",
-                "Content-Type": "application/json"
+                "Content-Type": "application/json",
             }
-            
-            async with self.session.post(workflow_url, json=workflow_payload, headers=headers) as response:
+
+            async with self.session.post(
+                workflow_url, json=workflow_payload, headers=headers
+            ) as response:
                 if response.status != 200:
                     error_text = await response.text()
-                    raise Exception(f"影片工作流程創建失敗: HTTP {response.status}, 錯誤: {error_text}")
-                    
+                    raise Exception(
+                        f"影片工作流程創建失敗: HTTP {response.status}, 錯誤: {error_text}"
+                    )
+
                 workflow_result = await response.json()
-                
+
             workflow_id = workflow_result.get("workflow_id")
             if not workflow_id:
                 raise Exception("工作流程ID未返回")
-                
+
             # 監控工作流程進度
             progress_url = f"{SERVICES['video_service']}/api/v1/entrepreneur/status/{workflow_id}"
             max_wait_time = 300  # 5分鐘最大等待時間
             start_wait = time.time()
-            
+
             final_status = None
             while time.time() - start_wait < max_wait_time:
-                async with self.session.get(progress_url, headers=headers) as response:
+                async with self.session.get(
+                    progress_url, headers=headers
+                ) as response:
                     if response.status == 200:
                         status_data = await response.json()
                         current_status = status_data.get("status")
-                        
-                        logger.info(f"工作流程 {workflow_id} 狀態: {current_status}")
-                        
+
+                        logger.info(
+                            f"工作流程 {workflow_id} 狀態: {current_status}"
+                        )
+
                         if current_status in ["completed", "failed"]:
                             final_status = status_data
                             break
-                            
+
                 await asyncio.sleep(10)  # 每10秒檢查一次
-                
+
             if not final_status:
                 raise Exception("工作流程執行超時")
-                
+
             if final_status.get("status") != "completed":
-                raise Exception(f"工作流程執行失敗: {final_status.get('error')}")
-                
+                raise Exception(
+                    f"工作流程執行失敗: {final_status.get('error')}"
+                )
+
             duration = time.time() - start_time
-            self.result.add_step_result("video_workflow", True, duration, {
-                "workflow_id": workflow_id,
-                "videos_generated": final_status.get("videos_generated", 0),
-                "total_steps": len(final_status.get("step_results", {}))
-            })
-            
+            self.result.add_step_result(
+                "video_workflow",
+                True,
+                duration,
+                {
+                    "workflow_id": workflow_id,
+                    "videos_generated": final_status.get(
+                        "videos_generated", 0
+                    ),
+                    "total_steps": len(final_status.get("step_results", {})),
+                },
+            )
+
             return final_status
-            
+
         except Exception as e:
             duration = time.time() - start_time
             self.result.add_step_result("video_workflow", False, duration)
             self.result.add_error(f"影片工作流程失敗: {str(e)}")
             raise
-            
-    async def test_publishing_workflow(self, video_data: Dict[str, Any]) -> Dict[str, Any]:
+
+    async def test_publishing_workflow(
+        self, video_data: Dict[str, Any]
+    ) -> Dict[str, Any]:
         """測試發布工作流程"""
         logger.info("📢 測試發布工作流程...")
         start_time = time.time()
-        
+
         try:
             videos = video_data.get("generated_videos", [])
             if not videos:
                 raise Exception("沒有可發布的影片")
-                
+
             video = videos[0]  # 取第一個影片
-            
+
             # 發布到各個平台
-            publish_url = f"{SERVICES['social_service']}/api/v1/entrepreneur/publish"
+            publish_url = (
+                f"{SERVICES['social_service']}/api/v1/entrepreneur/publish"
+            )
             publish_payload = {
                 "user_id": TEST_CONFIG["user_id"],
                 "video_id": video.get("video_id"),
@@ -330,115 +389,137 @@ class E2ETestRunner:
                 "metadata": {
                     "title": video.get("title"),
                     "description": video.get("description"),
-                    "tags": video.get("tags", [])
-                }
+                    "tags": video.get("tags", []),
+                },
             }
-            
+
             headers = {
                 "Authorization": "Bearer test_token_e2e",
-                "Content-Type": "application/json"
+                "Content-Type": "application/json",
             }
-            
-            async with self.session.post(publish_url, json=publish_payload, headers=headers) as response:
+
+            async with self.session.post(
+                publish_url, json=publish_payload, headers=headers
+            ) as response:
                 if response.status != 200:
                     raise Exception(f"發布請求失敗: HTTP {response.status}")
-                    
+
                 publish_result = await response.json()
-                
+
             publish_id = publish_result.get("publish_id")
-            
+
             # 監控發布狀態
             status_url = f"{SERVICES['social_service']}/api/v1/entrepreneur/publish-status/{publish_id}"
             max_wait_time = 120  # 2分鐘等待發布完成
             start_wait = time.time()
-            
+
             final_publish_status = None
             while time.time() - start_wait < max_wait_time:
-                async with self.session.get(status_url, headers=headers) as response:
+                async with self.session.get(
+                    status_url, headers=headers
+                ) as response:
                     if response.status == 200:
                         status_data = await response.json()
-                        
+
                         if status_data.get("all_completed", False):
                             final_publish_status = status_data
                             break
-                            
+
                 await asyncio.sleep(5)  # 每5秒檢查一次
-                
+
             if not final_publish_status:
                 raise Exception("發布流程監控超時")
-                
+
             successful_platforms = [
-                p for p in final_publish_status.get("platform_results", {}).values()
+                p
+                for p in final_publish_status.get(
+                    "platform_results", {}
+                ).values()
                 if p.get("status") == "success"
             ]
-            
+
             if len(successful_platforms) == 0:
                 raise Exception("所有平台發布都失敗")
-                
+
             duration = time.time() - start_time
-            self.result.add_step_result("publishing_workflow", True, duration, {
-                "publish_id": publish_id,
-                "successful_platforms": len(successful_platforms),
-                "total_platforms": len(TEST_CONFIG["entrepreneur_config"]["platforms"])
-            })
-            
+            self.result.add_step_result(
+                "publishing_workflow",
+                True,
+                duration,
+                {
+                    "publish_id": publish_id,
+                    "successful_platforms": len(successful_platforms),
+                    "total_platforms": len(
+                        TEST_CONFIG["entrepreneur_config"]["platforms"]
+                    ),
+                },
+            )
+
             return final_publish_status
-            
+
         except Exception as e:
             duration = time.time() - start_time
             self.result.add_step_result("publishing_workflow", False, duration)
             self.result.add_error(f"發布工作流程失敗: {str(e)}")
             raise
-            
+
     async def test_error_recovery(self) -> bool:
         """測試錯誤恢復機制"""
         logger.info("🔄 測試錯誤恢復機制...")
         start_time = time.time()
-        
+
         try:
             # 創建一個預期會失敗的任務
-            workflow_url = f"{SERVICES['video_service']}/api/v1/entrepreneur/create"
+            workflow_url = (
+                f"{SERVICES['video_service']}/api/v1/entrepreneur/create"
+            )
             invalid_payload = {
                 "user_id": TEST_CONFIG["user_id"],
                 "trend_keywords": [],  # 空關鍵字應該導致失敗
-                "video_count": 0,      # 無效數量
+                "video_count": 0,  # 無效數量
                 "categories": [],
-                "platforms": []
+                "platforms": [],
             }
-            
+
             headers = {
                 "Authorization": "Bearer test_token_e2e",
-                "Content-Type": "application/json"
+                "Content-Type": "application/json",
             }
-            
-            async with self.session.post(workflow_url, json=invalid_payload, headers=headers) as response:
+
+            async with self.session.post(
+                workflow_url, json=invalid_payload, headers=headers
+            ) as response:
                 error_response = await response.json()
-                
+
                 # 驗證系統正確返回錯誤
                 if response.status == 200:
                     raise Exception("系統應該拒絕無效請求但沒有")
-                    
+
                 if response.status not in [400, 422]:
                     raise Exception(f"錯誤狀態碼不正確: {response.status}")
-                    
+
             # 測試排程器對失敗任務的處理
             status_url = f"{SERVICES['scheduler_service']}/api/v1/entrepreneur-scheduler/status"
-            async with self.session.get(status_url, headers=headers) as response:
+            async with self.session.get(
+                status_url, headers=headers
+            ) as response:
                 if response.status == 200:
                     scheduler_status = await response.json()
-                    
+
                     # 驗證排程器仍在正常運行
                     if not scheduler_status.get("is_running", False):
                         raise Exception("排程器因錯誤停止運行")
-                        
+
             duration = time.time() - start_time
-            self.result.add_step_result("error_recovery", True, duration, {
-                "error_handled": True,
-                "scheduler_stable": True
-            })
-            
+            self.result.add_step_result(
+                "error_recovery",
+                True,
+                duration,
+                {"error_handled": True, "scheduler_stable": True},
+            )
+
             return True
-            
+
         except Exception as e:
             duration = time.time() - start_time
             self.result.add_step_result("error_recovery", False, duration)
@@ -450,55 +531,57 @@ async def run_e2e_tests():
     """執行完整的端對端測試"""
     logger.info("🚀 開始創業者模式端對端整合測試")
     logger.info("=" * 60)
-    
+
     async with E2ETestRunner() as runner:
         try:
             # 1. 服務健康檢查
             if not await runner.health_check_services():
                 logger.error("❌ 服務健康檢查失敗，停止測試")
                 return False
-                
+
             logger.info("✅ 所有服務健康檢查通過")
-            
+
             # 2. 趨勢分析流程測試
             trend_data = await runner.test_trend_analysis_flow()
             logger.info("✅ 趨勢分析流程測試通過")
-            
+
             # 3. 排程器配置測試
             await runner.test_scheduler_configuration()
             logger.info("✅ 排程器配置測試通過")
-            
+
             # 4. 影片工作流程測試
             video_data = await runner.test_video_workflow_execution(trend_data)
             logger.info("✅ 影片工作流程測試通過")
-            
+
             # 5. 發布工作流程測試
             publish_data = await runner.test_publishing_workflow(video_data)
             logger.info("✅ 發布工作流程測試通過")
-            
+
             # 6. 錯誤恢復測試
             await runner.test_error_recovery()
             logger.info("✅ 錯誤恢復機制測試通過")
-            
+
             # 完成測試並生成報告
             runner.result.finalize()
-            
+
             logger.info("=" * 60)
             logger.info("🎉 端對端整合測試完成！")
             logger.info(f"📊 測試成功率: {runner.result.success_rate:.1f}%")
-            logger.info(f"⏱️  總執行時間: {runner.result.total_execution_time:.2f}秒")
-            
+            logger.info(
+                f"⏱️  總執行時間: {runner.result.total_execution_time:.2f}秒"
+            )
+
             if runner.result.errors:
                 logger.info("⚠️  發現的問題:")
                 for error in runner.result.errors:
                     logger.info(f"   - {error}")
-                    
+
             return runner.result.success_rate >= 80.0  # 80%成功率算通過
-            
+
         except Exception as e:
             runner.result.add_error(f"E2E測試執行異常: {str(e)}")
             runner.result.finalize()
-            
+
             logger.error("❌ 端對端整合測試失敗")
             logger.error(f"錯誤詳情: {str(e)}")
             return False
@@ -507,10 +590,10 @@ async def run_e2e_tests():
 if __name__ == "__main__":
     # 執行端對端測試
     success = asyncio.run(run_e2e_tests())
-    
+
     if success:
         logger.info("🎯 E2E測試通過 - 系統準備就緒！")
         sys.exit(0)
     else:
         logger.error("💥 E2E測試失敗 - 需要修復問題")
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/auto_generate_video_fold6/test_e2e_simple.py b/auto_generate_video_fold6/test_e2e_simple.py
index c681128..4a0dadc 100644
--- a/auto_generate_video_fold6/test_e2e_simple.py
+++ b/auto_generate_video_fold6/test_e2e_simple.py
@@ -15,48 +15,49 @@ from typing import Dict, Any
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
+
 class SimpleE2ERunner:
     """簡化版 E2E 測試執行器"""
-    
+
     def __init__(self):
         self.session = None
-        self.results = {
-            "tests_passed": 0,
-            "tests_failed": 0,
-            "errors": []
-        }
-    
+        self.results = {"tests_passed": 0, "tests_failed": 0, "errors": []}
+
     async def __aenter__(self):
         self.session = aiohttp.ClientSession(
             timeout=aiohttp.ClientTimeout(total=30)
         )
         return self
-    
+
     async def __aexit__(self, exc_type, exc_val, exc_tb):
         if self.session:
             await self.session.close()
-    
+
     async def test_service_connectivity(self):
         """測試服務連通性"""
         logger.info("🔗 測試服務連通性...")
-        
+
         services = {
             "trend_service": "http://localhost:8001/health",
-            "video_service": "http://localhost:8003/health", 
+            "video_service": "http://localhost:8003/health",
             "social_service": "http://localhost:8004/health",
-            "scheduler_service": "http://localhost:8008/health"
+            "scheduler_service": "http://localhost:8008/health",
         }
-        
+
         all_healthy = True
         for service_name, health_url in services.items():
             try:
                 async with self.session.get(health_url) as response:
                     if response.status == 200:
                         data = await response.json()
-                        logger.info(f"✅ {service_name}: {data.get('status', 'unknown')}")
+                        logger.info(
+                            f"✅ {service_name}: {data.get('status', 'unknown')}"
+                        )
                         self.results["tests_passed"] += 1
                     else:
-                        logger.error(f"❌ {service_name}: HTTP {response.status}")
+                        logger.error(
+                            f"❌ {service_name}: HTTP {response.status}"
+                        )
                         self.results["tests_failed"] += 1
                         all_healthy = False
             except Exception as e:
@@ -64,22 +65,24 @@ class SimpleE2ERunner:
                 self.results["tests_failed"] += 1
                 self.results["errors"].append(f"{service_name}: {str(e)}")
                 all_healthy = False
-        
+
         return all_healthy
-    
+
     async def test_trend_analysis(self):
         """測試趨勢分析"""
         logger.info("📈 測試趨勢分析...")
-        
+
         try:
-            trend_url = "http://localhost:8001/api/v1/entrepreneur/fetch-trends"
+            trend_url = (
+                "http://localhost:8001/api/v1/entrepreneur/fetch-trends"
+            )
             payload = {
                 "categories": ["technology", "ai"],
                 "platforms": ["tiktok", "youtube"],
                 "hours_back": 24,
-                "min_engagement": 1000
+                "min_engagement": 1000,
             }
-            
+
             async with self.session.post(trend_url, json=payload) as response:
                 if response.status == 200:
                     data = await response.json()
@@ -90,45 +93,47 @@ class SimpleE2ERunner:
                 else:
                     error_text = await response.text()
                     raise Exception(f"HTTP {response.status}: {error_text}")
-                    
+
         except Exception as e:
             logger.error(f"❌ 趨勢分析失敗: {e}")
             self.results["tests_failed"] += 1
             self.results["errors"].append(f"趨勢分析: {str(e)}")
             return None
-    
+
     async def test_video_workflow(self, trend_data):
         """測試影片工作流程"""
         logger.info("🎬 測試影片工作流程...")
-        
+
         if not trend_data or not trend_data.get("trends"):
             logger.error("❌ 無趨勢數據可用於影片工作流程")
             self.results["tests_failed"] += 1
             return None
-        
+
         try:
             workflow_url = "http://localhost:8003/api/v1/entrepreneur/create"
             best_trend = trend_data["trends"][0]
-            
+
             payload = {
                 "user_id": "e2e_test_user",
                 "trend_keywords": [best_trend.get("keyword", "AI technology")],
                 "video_count": 1,
                 "categories": ["technology"],
-                "platforms": ["tiktok"]
+                "platforms": ["tiktok"],
             }
-            
+
             # 創建工作流程
-            async with self.session.post(workflow_url, json=payload) as response:
+            async with self.session.post(
+                workflow_url, json=payload
+            ) as response:
                 if response.status == 200:
                     data = await response.json()
                     workflow_id = data.get("workflow_id")
                     logger.info(f"✅ 工作流程創建成功: {workflow_id}")
                     self.results["tests_passed"] += 1
-                    
+
                     # 等待工作流程完成（簡化版）
                     await asyncio.sleep(5)
-                    
+
                     # 檢查工作流程狀態
                     status_url = f"http://localhost:8003/api/v1/entrepreneur/status/{workflow_id}"
                     async with self.session.get(status_url) as status_response:
@@ -139,39 +144,43 @@ class SimpleE2ERunner:
                             self.results["tests_passed"] += 1
                             return status_data
                         else:
-                            raise Exception(f"狀態查詢失敗: HTTP {status_response.status}")
+                            raise Exception(
+                                f"狀態查詢失敗: HTTP {status_response.status}"
+                            )
                 else:
                     error_text = await response.text()
                     raise Exception(f"HTTP {response.status}: {error_text}")
-                    
+
         except Exception as e:
             logger.error(f"❌ 影片工作流程失敗: {e}")
             self.results["tests_failed"] += 1
             self.results["errors"].append(f"影片工作流程: {str(e)}")
             return None
-    
+
     async def test_scheduler_operations(self):
         """測試排程器操作"""
         logger.info("⚙️ 測試排程器操作...")
-        
+
         try:
             base_url = "http://localhost:8008/api/v1/entrepreneur-scheduler"
-            
+
             # 配置排程器
             config_payload = {
                 "enabled": True,
                 "daily_video_limit": 5,
                 "daily_budget_limit": 20.0,
-                "max_concurrent_tasks": 2
+                "max_concurrent_tasks": 2,
             }
-            
-            async with self.session.post(f"{base_url}/configure", json=config_payload) as response:
+
+            async with self.session.post(
+                f"{base_url}/configure", json=config_payload
+            ) as response:
                 if response.status == 200:
                     logger.info("✅ 排程器配置成功")
                     self.results["tests_passed"] += 1
                 else:
                     raise Exception(f"配置失敗: HTTP {response.status}")
-            
+
             # 啟動排程器
             async with self.session.post(f"{base_url}/start") as response:
                 if response.status == 200:
@@ -179,28 +188,30 @@ class SimpleE2ERunner:
                     self.results["tests_passed"] += 1
                 else:
                     raise Exception(f"啟動失敗: HTTP {response.status}")
-            
+
             # 檢查狀態
             async with self.session.get(f"{base_url}/status") as response:
                 if response.status == 200:
                     data = await response.json()
                     is_running = data.get("is_running", False)
-                    logger.info(f"✅ 排程器狀態: {'運行中' if is_running else '已停止'}")
+                    logger.info(
+                        f"✅ 排程器狀態: {'運行中' if is_running else '已停止'}"
+                    )
                     self.results["tests_passed"] += 1
                     return True
                 else:
                     raise Exception(f"狀態查詢失敗: HTTP {response.status}")
-                    
+
         except Exception as e:
             logger.error(f"❌ 排程器操作失敗: {e}")
             self.results["tests_failed"] += 1
             self.results["errors"].append(f"排程器操作: {str(e)}")
             return False
-    
+
     async def test_basic_publishing(self):
         """測試基本發布功能"""
         logger.info("📢 測試基本發布功能...")
-        
+
         try:
             publish_url = "http://localhost:8004/api/v1/entrepreneur/publish"
             payload = {
@@ -209,11 +220,13 @@ class SimpleE2ERunner:
                 "platforms": ["tiktok"],
                 "metadata": {
                     "title": "測試影片",
-                    "description": "E2E 測試影片"
-                }
+                    "description": "E2E 測試影片",
+                },
             }
-            
-            async with self.session.post(publish_url, json=payload) as response:
+
+            async with self.session.post(
+                publish_url, json=payload
+            ) as response:
                 if response.status == 200:
                     data = await response.json()
                     publish_id = data.get("publish_id")
@@ -223,78 +236,86 @@ class SimpleE2ERunner:
                 else:
                     error_text = await response.text()
                     raise Exception(f"HTTP {response.status}: {error_text}")
-                    
+
         except Exception as e:
             logger.error(f"❌ 發布功能失敗: {e}")
             self.results["tests_failed"] += 1
             self.results["errors"].append(f"發布功能: {str(e)}")
             return False
-    
+
     def print_results(self):
         """打印測試結果"""
-        total_tests = self.results["tests_passed"] + self.results["tests_failed"]
-        success_rate = (self.results["tests_passed"] / total_tests * 100) if total_tests > 0 else 0
-        
+        total_tests = (
+            self.results["tests_passed"] + self.results["tests_failed"]
+        )
+        success_rate = (
+            (self.results["tests_passed"] / total_tests * 100)
+            if total_tests > 0
+            else 0
+        )
+
         logger.info("=" * 50)
         logger.info("📊 E2E 測試結果摘要")
         logger.info("=" * 50)
         logger.info(f"✅ 通過測試: {self.results['tests_passed']}")
         logger.info(f"❌ 失敗測試: {self.results['tests_failed']}")
         logger.info(f"📈 成功率: {success_rate:.1f}%")
-        
+
         if self.results["errors"]:
             logger.info("\n🚨 錯誤列表:")
             for error in self.results["errors"]:
                 logger.info(f"  - {error}")
-        
+
         return success_rate >= 70.0  # 70% 成功率算通過
 
+
 async def main():
     """執行簡化版 E2E 測試"""
     logger.info("🚀 開始簡化版創業者模式 E2E 測試")
     logger.info("=" * 50)
-    
+
     async with SimpleE2ERunner() as runner:
         # 1. 服務連通性測試
         connectivity_ok = await runner.test_service_connectivity()
-        
+
         if not connectivity_ok:
             logger.error("❌ 服務連通性測試失敗，跳過後續測試")
             return False
-        
+
         # 2. 趨勢分析測試
         trend_data = await runner.test_trend_analysis()
-        
+
         # 3. 影片工作流程測試
         workflow_data = await runner.test_video_workflow(trend_data)
-        
+
         # 4. 排程器操作測試
         scheduler_ok = await runner.test_scheduler_operations()
-        
+
         # 5. 基本發布測試
         publish_ok = await runner.test_basic_publishing()
-        
+
         # 打印結果
         success = runner.print_results()
-        
+
         if success:
             logger.info("🎉 E2E 測試通過！創業者模式核心功能驗證成功")
         else:
             logger.error("💥 E2E 測試失敗！需要修復問題")
-        
+
         return success
 
+
 if __name__ == "__main__":
     # 給模擬服務時間啟動
     logger.info("⏳ 等待服務啟動...")
     time.sleep(2)
-    
+
     # 執行測試
     success = asyncio.run(main())
-    
+
     if success:
         logger.info("🎯 TDD Green 階段通過 - 準備進入 Refactor 階段")
         exit(0)
     else:
         logger.error("🔴 TDD Green 階段失敗 - 需要修復實作")
-        exit(1)
\ No newline at end of file
+        exit(1)
diff --git a/auto_generate_video_fold6/test_monitoring_logging_system.py b/auto_generate_video_fold6/test_monitoring_logging_system.py
index 0d77e95..cf86abc 100644
--- a/auto_generate_video_fold6/test_monitoring_logging_system.py
+++ b/auto_generate_video_fold6/test_monitoring_logging_system.py
@@ -37,32 +37,35 @@ except ImportError:
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
+
 class MonitoringLoggingSystemTest:
     """監控和日誌系統 TDD 測試套件"""
-    
+
     def __init__(self):
         self.project_root = Path(__file__).parent
-        self.results = {
-            "tests_passed": 0,
-            "tests_failed": 0,
-            "errors": []
-        }
-        
+        self.results = {"tests_passed": 0, "tests_failed": 0, "errors": []}
+
         # Test configuration
         self.services = [
-            "frontend", "api-gateway", "trend-service", 
-            "video-service", "social-service", "scheduler-service",
-            "postgres", "redis", "minio"
+            "frontend",
+            "api-gateway",
+            "trend-service",
+            "video-service",
+            "social-service",
+            "scheduler-service",
+            "postgres",
+            "redis",
+            "minio",
         ]
-        
+
         # Expected monitoring endpoints
         self.monitoring_endpoints = {
             "prometheus": "http://localhost:9090",
-            "grafana": "http://localhost:3001", 
+            "grafana": "http://localhost:3001",
             "alertmanager": "http://localhost:9093",
-            "jaeger": "http://localhost:16686"
+            "jaeger": "http://localhost:16686",
         }
-    
+
     def _record_result(self, test_name: str, success: bool, error: str = None):
         """記錄測試結果"""
         if success:
@@ -79,78 +82,105 @@ class MonitoringLoggingSystemTest:
             # 檢查日誌配置文件
             log_config_files = [
                 "monitoring/logging/structured_logger.py",
-                "monitoring/logging/log_config.json",  
+                "monitoring/logging/log_config.json",
                 "monitoring/fluentd/fluent.conf",
-                "monitoring/logstash/pipeline/logstash.conf"
+                "monitoring/logstash/pipeline/logstash.conf",
             ]
-            
+
             for config_file in log_config_files:
                 config_path = self.project_root / config_file
-                assert config_path.exists(), f"日誌配置文件不存在: {config_file}"
-                
+                assert config_path.exists(), (
+                    f"日誌配置文件不存在: {config_file}"
+                )
+
                 # 檢查配置文件內容
-                if config_file.endswith('.py'):
+                if config_file.endswith(".py"):
                     content = config_path.read_text()
-                    assert "StructuredLogger" in content, f"缺少 StructuredLogger 類別: {config_file}"
-                    assert "correlation_id" in content, f"缺少關聯ID支援: {config_file}"
-                    assert "json" in content.lower(), f"缺少JSON格式支援: {config_file}"
-                
-                elif config_file.endswith('.json'):
-                    with open(config_path, 'r') as f:
+                    assert "StructuredLogger" in content, (
+                        f"缺少 StructuredLogger 類別: {config_file}"
+                    )
+                    assert "correlation_id" in content, (
+                        f"缺少關聯ID支援: {config_file}"
+                    )
+                    assert "json" in content.lower(), (
+                        f"缺少JSON格式支援: {config_file}"
+                    )
+
+                elif config_file.endswith(".json"):
+                    with open(config_path, "r") as f:
                         config = json.load(f)
-                    assert "formatters" in config, f"缺少格式化器配置: {config_file}"
-                    assert "handlers" in config, f"缺少處理器配置: {config_file}"
-                    
-                elif config_file.endswith('.conf'):
+                    assert "formatters" in config, (
+                        f"缺少格式化器配置: {config_file}"
+                    )
+                    assert "handlers" in config, (
+                        f"缺少處理器配置: {config_file}"
+                    )
+
+                elif config_file.endswith(".conf"):
                     content = config_path.read_text()
-                    assert "source" in content, f"缺少輸入源配置: {config_file}"
+                    assert "source" in content, (
+                        f"缺少輸入源配置: {config_file}"
+                    )
                     assert "match" in content, f"缺少匹配規則: {config_file}"
-            
+
             self._record_result("structured_logging_configuration", True)
-            
+
         except Exception as e:
-            self._record_result("structured_logging_configuration", False, str(e))
+            self._record_result(
+                "structured_logging_configuration", False, str(e)
+            )
 
     def test_prometheus_metrics_collection(self):
         """測試 Prometheus 指標收集配置"""
         try:
             # 檢查 Prometheus 配置
-            prometheus_config = self.project_root / "monitoring/prometheus/prometheus.yml"
+            prometheus_config = (
+                self.project_root / "monitoring/prometheus/prometheus.yml"
+            )
             assert prometheus_config.exists(), "Prometheus 配置文件不存在"
-            
+
             if yaml:
-                with open(prometheus_config, 'r') as f:
+                with open(prometheus_config, "r") as f:
                     config = yaml.safe_load(f)
             else:
                 # 簡單文本檢查如果沒有 yaml
                 config_text = prometheus_config.read_text()
-                config = {"scrape_configs": [{"job_name": "prometheus"}]}  # 模擬基本結構
-            
+                config = {
+                    "scrape_configs": [{"job_name": "prometheus"}]
+                }  # 模擬基本結構
+
             # 檢查基本配置
             assert "global" in config, "缺少全局配置"
             assert "scrape_configs" in config, "缺少抓取配置"
-            
+
             # 檢查服務發現配置
-            scrape_jobs = {job['job_name'] for job in config['scrape_configs']}
+            scrape_jobs = {job["job_name"] for job in config["scrape_configs"]}
             expected_jobs = {
-                'prometheus', 'node-exporter', 'postgres-exporter', 
-                'redis-exporter', 'docker-exporter', 'application-metrics'
+                "prometheus",
+                "node-exporter",
+                "postgres-exporter",
+                "redis-exporter",
+                "docker-exporter",
+                "application-metrics",
             }
-            
+
             missing_jobs = expected_jobs - scrape_jobs
             assert not missing_jobs, f"缺少監控作業: {missing_jobs}"
-            
+
             # 檢查指標中間件文件
-            metrics_middleware = self.project_root / "monitoring/middleware/prometheus_middleware.py"
+            metrics_middleware = (
+                self.project_root
+                / "monitoring/middleware/prometheus_middleware.py"
+            )
             assert metrics_middleware.exists(), "缺少 Prometheus 中間件"
-            
+
             middleware_content = metrics_middleware.read_text()
             assert "Counter" in middleware_content, "缺少計數器指標"
             assert "Histogram" in middleware_content, "缺少直方圖指標"
             assert "Gauge" in middleware_content, "缺少測量指標"
-            
+
             self._record_result("prometheus_metrics_collection", True)
-            
+
         except Exception as e:
             self._record_result("prometheus_metrics_collection", False, str(e))
 
@@ -160,107 +190,136 @@ class MonitoringLoggingSystemTest:
             # 檢查 Grafana 配置目錄
             grafana_dir = self.project_root / "monitoring/grafana"
             assert grafana_dir.exists(), "Grafana 配置目錄不存在"
-            
+
             # 檢查數據源配置
-            datasources_dir = grafana_dir / "provisioning/datasources"  
+            datasources_dir = grafana_dir / "provisioning/datasources"
             assert datasources_dir.exists(), "數據源配置目錄不存在"
-            
+
             prometheus_datasource = datasources_dir / "prometheus.yml"
-            assert prometheus_datasource.exists(), "Prometheus 數據源配置不存在"
-            
+            assert prometheus_datasource.exists(), (
+                "Prometheus 數據源配置不存在"
+            )
+
             if yaml:
-                with open(prometheus_datasource, 'r') as f:
+                with open(prometheus_datasource, "r") as f:
                     datasource_config = yaml.safe_load(f)
             else:
                 datasource_config = {"datasources": [{"type": "prometheus"}]}
-            
+
             assert "datasources" in datasource_config, "缺少數據源定義"
-            prometheus_ds = datasource_config['datasources'][0]
-            assert prometheus_ds['type'] == 'prometheus', "數據源類型不正確"
-            
+            prometheus_ds = datasource_config["datasources"][0]
+            assert prometheus_ds["type"] == "prometheus", "數據源類型不正確"
+
             # 檢查儀表板配置
             dashboards_dir = grafana_dir / "dashboards"
             assert dashboards_dir.exists(), "儀表板目錄不存在"
-            
+
             expected_dashboards = [
                 "system-overview.json",
-                "application-performance.json", 
+                "application-performance.json",
                 "docker-containers.json",
                 "business-metrics.json",
-                "error-tracking.json"
+                "error-tracking.json",
             ]
-            
+
             for dashboard in expected_dashboards:
                 dashboard_path = dashboards_dir / dashboard
                 assert dashboard_path.exists(), f"儀表板不存在: {dashboard}"
-                
-                with open(dashboard_path, 'r') as f:
+
+                with open(dashboard_path, "r") as f:
                     dashboard_config = json.load(f)
-                
-                assert "dashboard" in dashboard_config, f"儀表板配置格式錯誤: {dashboard}"
-                assert "panels" in dashboard_config['dashboard'], f"缺少面板配置: {dashboard}"
-            
+
+                assert "dashboard" in dashboard_config, (
+                    f"儀表板配置格式錯誤: {dashboard}"
+                )
+                assert "panels" in dashboard_config["dashboard"], (
+                    f"缺少面板配置: {dashboard}"
+                )
+
             self._record_result("grafana_dashboard_configuration", True)
-            
+
         except Exception as e:
-            self._record_result("grafana_dashboard_configuration", False, str(e))
+            self._record_result(
+                "grafana_dashboard_configuration", False, str(e)
+            )
 
     def test_alerting_system_configuration(self):
         """測試警報系統配置"""
         try:
             # 檢查 Alertmanager 配置
-            alertmanager_config = self.project_root / "monitoring/alertmanager/alertmanager.yml"
+            alertmanager_config = (
+                self.project_root / "monitoring/alertmanager/alertmanager.yml"
+            )
             assert alertmanager_config.exists(), "Alertmanager 配置文件不存在"
-            
+
             if yaml:
-                with open(alertmanager_config, 'r') as f:
+                with open(alertmanager_config, "r") as f:
                     config = yaml.safe_load(f)
             else:
                 config = {"global": {}, "route": {}, "receivers": []}
-            
+
             assert "global" in config, "缺少全局警報配置"
             assert "route" in config, "缺少路由配置"
             assert "receivers" in config, "缺少接收器配置"
-            
+
             # 檢查警報規則
             alert_rules = self.project_root / "monitoring/prometheus/rules"
             assert alert_rules.exists(), "警報規則目錄不存在"
-            
+
             expected_rule_files = [
                 "system-alerts.yml",
                 "application-alerts.yml",
-                "business-alerts.yml"
+                "business-alerts.yml",
             ]
-            
+
             for rule_file in expected_rule_files:
                 rule_path = alert_rules / rule_file
                 assert rule_path.exists(), f"警報規則文件不存在: {rule_file}"
-                
+
                 if yaml:
-                    with open(rule_path, 'r') as f:
+                    with open(rule_path, "r") as f:
                         rules = yaml.safe_load(f)
                 else:
-                    rules = {"groups": [{"name": "test", "rules": [{"alert": "test", "expr": "up", "for": "1m"}]}]}
-                
+                    rules = {
+                        "groups": [
+                            {
+                                "name": "test",
+                                "rules": [
+                                    {
+                                        "alert": "test",
+                                        "expr": "up",
+                                        "for": "1m",
+                                    }
+                                ],
+                            }
+                        ]
+                    }
+
                 assert "groups" in rules, f"缺少警報組: {rule_file}"
-                
-                for group in rules['groups']:
+
+                for group in rules["groups"]:
                     assert "rules" in group, f"警報組缺少規則: {group['name']}"
-                    
-                    for rule in group['rules']:
+
+                    for rule in group["rules"]:
                         assert "alert" in rule, f"規則缺少警報名稱: {rule}"
-                        assert "expr" in rule, f"規則缺少表達式: {rule['alert']}"
-                        assert "for" in rule, f"規則缺少持續時間: {rule['alert']}"
-            
+                        assert "expr" in rule, (
+                            f"規則缺少表達式: {rule['alert']}"
+                        )
+                        assert "for" in rule, (
+                            f"規則缺少持續時間: {rule['alert']}"
+                        )
+
             # 檢查通知範本
-            templates_dir = self.project_root / "monitoring/alertmanager/templates"
+            templates_dir = (
+                self.project_root / "monitoring/alertmanager/templates"
+            )
             assert templates_dir.exists(), "警報範本目錄不存在"
-            
+
             email_template = templates_dir / "email.tmpl"
             assert email_template.exists(), "電子郵件範本不存在"
-            
+
             self._record_result("alerting_system_configuration", True)
-            
+
         except Exception as e:
             self._record_result("alerting_system_configuration", False, str(e))
 
@@ -270,35 +329,42 @@ class MonitoringLoggingSystemTest:
             # 檢查 Jaeger 配置
             jaeger_config = self.project_root / "monitoring/jaeger"
             assert jaeger_config.exists(), "Jaeger 配置目錄不存在"
-            
+
             jaeger_config_file = jaeger_config / "jaeger-config.yml"
             assert jaeger_config_file.exists(), "Jaeger 配置文件不存在"
-            
+
             # 檢查 OpenTelemetry 中間件
-            otel_middleware = self.project_root / "monitoring/tracing/opentelemetry_middleware.py"
+            otel_middleware = (
+                self.project_root
+                / "monitoring/tracing/opentelemetry_middleware.py"
+            )
             assert otel_middleware.exists(), "OpenTelemetry 中間件不存在"
-            
+
             middleware_content = otel_middleware.read_text()
             assert "tracer" in middleware_content.lower(), "缺少追蹤器配置"
             assert "span" in middleware_content.lower(), "缺少跨度處理"
-            assert "correlation" in middleware_content.lower(), "缺少關聯ID處理"
-            
+            assert "correlation" in middleware_content.lower(), (
+                "缺少關聯ID處理"
+            )
+
             # 檢查追蹤配置檔案
             tracing_configs = [
                 "services/api-gateway/tracing_config.py",
-                "services/trend-service/tracing_config.py", 
-                "services/video-service/tracing_config.py"
+                "services/trend-service/tracing_config.py",
+                "services/video-service/tracing_config.py",
             ]
-            
+
             for config_file in tracing_configs:
                 config_path = self.project_root / config_file
                 # 允許文件不存在，因為這是 Red 階段
                 if config_path.exists():
                     content = config_path.read_text()
-                    assert "opentelemetry" in content.lower(), f"缺少 OpenTelemetry 配置: {config_file}"
-            
+                    assert "opentelemetry" in content.lower(), (
+                        f"缺少 OpenTelemetry 配置: {config_file}"
+                    )
+
             self._record_result("distributed_tracing_setup", True)
-            
+
         except Exception as e:
             self._record_result("distributed_tracing_setup", False, str(e))
 
@@ -308,30 +374,34 @@ class MonitoringLoggingSystemTest:
             # 檢查 ELK Stack 配置
             logstash_config = self.project_root / "monitoring/logstash"
             assert logstash_config.exists(), "Logstash 配置目錄不存在"
-            
+
             pipeline_config = logstash_config / "pipeline/logstash.conf"
             assert pipeline_config.exists(), "Logstash 管道配置不存在"
-            
+
             pipeline_content = pipeline_config.read_text()
             assert "input" in pipeline_content, "缺少輸入配置"
             assert "filter" in pipeline_content, "缺少過濾器配置"
             assert "output" in pipeline_content, "缺少輸出配置"
-            
+
             # 檢查 Fluent Bit 配置
-            fluent_config = self.project_root / "monitoring/logging/fluent-bit.conf"
+            fluent_config = (
+                self.project_root / "monitoring/logging/fluent-bit.conf"
+            )
             assert fluent_config.exists(), "Fluent Bit 配置不存在"
-            
+
             fluent_content = fluent_config.read_text()
             assert "[INPUT]" in fluent_content, "缺少輸入配置"
             assert "[OUTPUT]" in fluent_content, "缺少輸出配置"
             assert "[FILTER]" in fluent_content, "缺少過濾配置"
-            
+
             # 檢查解析器配置
-            parsers_config = self.project_root / "monitoring/logging/parsers.conf"
+            parsers_config = (
+                self.project_root / "monitoring/logging/parsers.conf"
+            )
             assert parsers_config.exists(), "解析器配置不存在"
-            
+
             self._record_result("log_aggregation_pipeline", True)
-            
+
         except Exception as e:
             self._record_result("log_aggregation_pipeline", False, str(e))
 
@@ -341,81 +411,99 @@ class MonitoringLoggingSystemTest:
             # 檢查應用程式監控中間件
             monitoring_middleware = self.project_root / "monitoring/middleware"
             assert monitoring_middleware.exists(), "監控中間件目錄不存在"
-            
+
             expected_middleware = [
                 "performance_middleware.py",
                 "health_check_middleware.py",
-                "correlation_middleware.py"
+                "correlation_middleware.py",
             ]
-            
+
             for middleware in expected_middleware:
                 middleware_path = monitoring_middleware / middleware
                 assert middleware_path.exists(), f"中間件不存在: {middleware}"
-                
+
                 content = middleware_path.read_text()
-                assert "async def" in content or "def " in content, f"中間件缺少函數定義: {middleware}"
-                
+                assert "async def" in content or "def " in content, (
+                    f"中間件缺少函數定義: {middleware}"
+                )
+
                 if "performance" in middleware:
-                    assert "response_time" in content.lower(), f"缺少回應時間監控: {middleware}"
-                    assert "request_count" in content.lower(), f"缺少請求計數: {middleware}"
-                
+                    assert "response_time" in content.lower(), (
+                        f"缺少回應時間監控: {middleware}"
+                    )
+                    assert "request_count" in content.lower(), (
+                        f"缺少請求計數: {middleware}"
+                    )
+
                 elif "health" in middleware:
-                    assert "health" in content.lower(), f"缺少健康檢查: {middleware}"
-                    assert "status" in content.lower(), f"缺少狀態檢查: {middleware}"
-            
+                    assert "health" in content.lower(), (
+                        f"缺少健康檢查: {middleware}"
+                    )
+                    assert "status" in content.lower(), (
+                        f"缺少狀態檢查: {middleware}"
+                    )
+
             # 檢查資料庫監控配置
             db_monitoring = self.project_root / "monitoring/database"
             if db_monitoring.exists():
                 pg_exporter_config = db_monitoring / "postgres_exporter.yml"
                 if pg_exporter_config.exists():
                     if yaml:
-                        with open(pg_exporter_config, 'r') as f:
+                        with open(pg_exporter_config, "r") as f:
                             config = yaml.safe_load(f)
                         assert "queries" in config, "缺少資料庫查詢配置"
                     else:
                         logger.info("跳過 YAML 配置檢查 (yaml 模組未安裝)")
-            
+
             self._record_result("performance_monitoring_integration", True)
-            
+
         except Exception as e:
-            self._record_result("performance_monitoring_integration", False, str(e))
+            self._record_result(
+                "performance_monitoring_integration", False, str(e)
+            )
 
     def test_business_metrics_tracking(self):
         """測試業務指標追蹤"""
         try:
             # 檢查業務指標定義
-            business_metrics = self.project_root / "monitoring/business_metrics"
+            business_metrics = (
+                self.project_root / "monitoring/business_metrics"
+            )
             assert business_metrics.exists(), "業務指標目錄不存在"
-            
+
             metrics_config = business_metrics / "metrics_definition.json"
             assert metrics_config.exists(), "業務指標定義不存在"
-            
-            with open(metrics_config, 'r') as f:
+
+            with open(metrics_config, "r") as f:
                 metrics = json.load(f)
-            
+
             # 檢查關鍵業務指標
             expected_metrics = [
                 "video_generation_count",
-                "user_engagement_rate", 
+                "user_engagement_rate",
                 "platform_publish_success_rate",
                 "trend_analysis_accuracy",
-                "system_availability"
+                "system_availability",
             ]
-            
+
             defined_metrics = set(metrics.keys())
             missing_metrics = set(expected_metrics) - defined_metrics
             assert not missing_metrics, f"缺少業務指標: {missing_metrics}"
-            
+
             # 檢查指標收集器
-            metrics_collector = business_metrics / "business_metrics_collector.py"
+            metrics_collector = (
+                business_metrics / "business_metrics_collector.py"
+            )
             assert metrics_collector.exists(), "業務指標收集器不存在"
-            
+
             collector_content = metrics_collector.read_text()
-            assert "BusinessMetricsCollector" in collector_content, "缺少業務指標收集器類別"
+            assert "BusinessMetricsCollector" in collector_content, (
+                "缺少業務指標收集器類別"
+            )
             assert "collect_metrics" in collector_content, "缺少指標收集方法"
-            
+
             self._record_result("business_metrics_tracking", True)
-            
+
         except Exception as e:
             self._record_result("business_metrics_tracking", False, str(e))
 
@@ -423,42 +511,61 @@ class MonitoringLoggingSystemTest:
         """測試監控系統 Docker Compose 整合"""
         try:
             # 檢查監控 Docker Compose 文件
-            monitoring_compose = self.project_root / "docker-compose.monitoring.yml"
-            assert monitoring_compose.exists(), "監控 Docker Compose 文件不存在"
-            
+            monitoring_compose = (
+                self.project_root / "docker-compose.monitoring.yml"
+            )
+            assert monitoring_compose.exists(), (
+                "監控 Docker Compose 文件不存在"
+            )
+
             if yaml:
-                with open(monitoring_compose, 'r') as f:
+                with open(monitoring_compose, "r") as f:
                     compose_config = yaml.safe_load(f)
             else:
-                compose_config = {"services": {"prometheus": {"image": "prom/prometheus"}}}
-            
+                compose_config = {
+                    "services": {"prometheus": {"image": "prom/prometheus"}}
+                }
+
             assert "services" in compose_config, "缺少服務定義"
-            
+
             # 檢查必要的監控服務
             expected_services = [
-                "prometheus", "grafana", "alertmanager", 
-                "jaeger", "logstash", "elasticsearch", "kibana"
+                "prometheus",
+                "grafana",
+                "alertmanager",
+                "jaeger",
+                "logstash",
+                "elasticsearch",
+                "kibana",
             ]
-            
-            defined_services = set(compose_config['services'].keys())
+
+            defined_services = set(compose_config["services"].keys())
             missing_services = set(expected_services) - defined_services
-            
+
             # 允許部分服務缺失（Red 階段期望失敗）
             if missing_services:
                 logger.warning(f"缺少監控服務: {missing_services}")
-            
+
             # 檢查服務配置
-            for service_name, service_config in compose_config['services'].items():
+            for service_name, service_config in compose_config[
+                "services"
+            ].items():
                 if service_name in expected_services:
-                    assert "image" in service_config or "build" in service_config, f"服務缺少映像配置: {service_name}"
-                    
+                    assert (
+                        "image" in service_config or "build" in service_config
+                    ), f"服務缺少映像配置: {service_name}"
+
                     if "ports" in service_config:
-                        assert len(service_config['ports']) > 0, f"服務未暴露端口: {service_name}"
-            
+                        assert len(service_config["ports"]) > 0, (
+                            f"服務未暴露端口: {service_name}"
+                        )
+
             self._record_result("monitoring_docker_compose_integration", True)
-            
+
         except Exception as e:
-            self._record_result("monitoring_docker_compose_integration", False, str(e))
+            self._record_result(
+                "monitoring_docker_compose_integration", False, str(e)
+            )
 
     def test_health_check_endpoints(self):
         """測試健康檢查端點"""
@@ -466,16 +573,20 @@ class MonitoringLoggingSystemTest:
             # 檢查健康檢查實作
             health_check_files = [
                 "monitoring/health-check/health_monitor.py",
-                "shared/health/health_checker.py"
+                "shared/health/health_checker.py",
             ]
-            
+
             for health_file in health_check_files:
                 health_path = self.project_root / health_file
                 if health_path.exists():  # 允許文件不存在
                     content = health_path.read_text()
-                    assert "health" in content.lower(), f"缺少健康檢查實作: {health_file}"
-                    assert "status" in content.lower(), f"缺少狀態檢查: {health_file}"
-            
+                    assert "health" in content.lower(), (
+                        f"缺少健康檢查實作: {health_file}"
+                    )
+                    assert "status" in content.lower(), (
+                        f"缺少狀態檢查: {health_file}"
+                    )
+
             # 檢查各服務的健康檢查端點定義
             for service in self.services[:3]:  # 只檢查前3個服務
                 service_path = self.project_root / f"services/{service}"
@@ -485,11 +596,13 @@ class MonitoringLoggingSystemTest:
                         if py_file.name in ["main.py", "app.py", "health.py"]:
                             content = py_file.read_text()
                             if "/health" in content:
-                                assert "health" in content.lower(), f"健康檢查端點實作不完整: {py_file}"
+                                assert "health" in content.lower(), (
+                                    f"健康檢查端點實作不完整: {py_file}"
+                                )
                                 break
-            
+
             self._record_result("health_check_endpoints", True)
-            
+
         except Exception as e:
             self._record_result("health_check_endpoints", False, str(e))
 
@@ -497,59 +610,81 @@ class MonitoringLoggingSystemTest:
         """測試監控配置驗證"""
         try:
             # 檢查配置驗證腳本
-            config_validator = self.project_root / "scripts/validate-monitoring-config.py"
+            config_validator = (
+                self.project_root / "scripts/validate-monitoring-config.py"
+            )
             if not config_validator.exists():
-                config_validator = self.project_root / "monitoring/config_validator.py"
-            
+                config_validator = (
+                    self.project_root / "monitoring/config_validator.py"
+                )
+
             if config_validator.exists():
                 content = config_validator.read_text()
                 assert "validate" in content.lower(), "缺少配置驗證功能"
-                assert "prometheus" in content.lower(), "缺少 Prometheus 配置驗證"
+                assert "prometheus" in content.lower(), (
+                    "缺少 Prometheus 配置驗證"
+                )
                 assert "grafana" in content.lower(), "缺少 Grafana 配置驗證"
-            
+
             # 檢查環境變數範本
             env_example = self.project_root / ".env.monitoring.example"
             if env_example.exists():
                 env_content = env_example.read_text()
                 monitoring_vars = [
-                    "PROMETHEUS_PORT", "GRAFANA_ADMIN_PASSWORD", 
-                    "ALERTMANAGER_PORT", "JAEGER_PORT"
+                    "PROMETHEUS_PORT",
+                    "GRAFANA_ADMIN_PASSWORD",
+                    "ALERTMANAGER_PORT",
+                    "JAEGER_PORT",
                 ]
-                
+
                 for var in monitoring_vars:
                     if var not in env_content:
                         logger.warning(f"環境變數範本缺少: {var}")
-            
+
             self._record_result("monitoring_configuration_validation", True)
-            
+
         except Exception as e:
-            self._record_result("monitoring_configuration_validation", False, str(e))
+            self._record_result(
+                "monitoring_configuration_validation", False, str(e)
+            )
 
     def print_results(self):
         """打印測試結果"""
-        total_tests = self.results["tests_passed"] + self.results["tests_failed"]
-        success_rate = (self.results["tests_passed"] / total_tests * 100) if total_tests > 0 else 0
-        
+        total_tests = (
+            self.results["tests_passed"] + self.results["tests_failed"]
+        )
+        success_rate = (
+            (self.results["tests_passed"] / total_tests * 100)
+            if total_tests > 0
+            else 0
+        )
+
         logger.info("=" * 70)
         logger.info("🔴 TDD Red 階段: 監控和日誌系統測試結果")
         logger.info("=" * 70)
         logger.info(f"✅ 通過測試: {self.results['tests_passed']}")
         logger.info(f"❌ 失敗測試: {self.results['tests_failed']}")
         logger.info(f"📈 當前完成率: {success_rate:.1f}%")
-        
+
         if self.results["errors"]:
             logger.info("\n🎯 需要實作的功能:")
             for error in self.results["errors"]:
                 logger.info(f"  - {error}")
-        
+
         # Red 階段評估
         if success_rate < 30:
-            logger.info("\n🔴 TDD Red 階段狀態: 完美 - 大部分測試失敗，定義了清晰的目標")
+            logger.info(
+                "\n🔴 TDD Red 階段狀態: 完美 - 大部分測試失敗，定義了清晰的目標"
+            )
         elif success_rate < 60:
-            logger.info("\n🟡 TDD Red 階段狀態: 良好 - 有些基礎已存在，需要更多實作")
+            logger.info(
+                "\n🟡 TDD Red 階段狀態: 良好 - 有些基礎已存在，需要更多實作"
+            )
         else:
-            logger.info("\n🟢 TDD Red 階段狀態: 意外 - 很多功能已存在，可能需要調整測試")
-        
+            logger.info(
+                "\n🟢 TDD Red 階段狀態: 意外 - 很多功能已存在，可能需要調整測試"
+            )
+
         return success_rate < 50  # Red 階段期望低成功率
 
 
@@ -558,9 +693,9 @@ def main():
     logger.info("🔴 開始 TDD Red 階段: 監控和日誌系統測試")
     logger.info("目標: 定義完整監控和日誌系統的期望行為")
     logger.info("=" * 70)
-    
+
     test_suite = MonitoringLoggingSystemTest()
-    
+
     try:
         # 執行所有測試
         test_suite.test_structured_logging_configuration()
@@ -574,10 +709,10 @@ def main():
         test_suite.test_monitoring_docker_compose_integration()
         test_suite.test_health_check_endpoints()
         test_suite.test_monitoring_configuration_validation()
-        
+
         # 打印結果
         is_proper_red = test_suite.print_results()
-        
+
         if is_proper_red:
             logger.info("\n🎉 TDD Red 階段成功！")
             logger.info("✨ 已定義完整的監控和日誌系統需求")
@@ -585,9 +720,9 @@ def main():
         else:
             logger.info("\n🤔 TDD Red 階段意外通過較多測試")
             logger.info("🔧 可能需要調整測試或檢查現有實作")
-        
+
         return is_proper_red
-        
+
     except Exception as e:
         logger.error(f"❌ Red 階段測試執行異常: {e}")
         return False
@@ -595,10 +730,10 @@ def main():
 
 if __name__ == "__main__":
     success = main()
-    
+
     if success:
         logger.info("🏁 TDD Red 階段完成 - 監控和日誌系統需求已定義")
         exit(0)
     else:
         logger.error("🛑 TDD Red 階段需要調整")
-        exit(1)
\ No newline at end of file
+        exit(1)
diff --git a/auto_generate_video_fold6/test_monitoring_performance_optimization.py b/auto_generate_video_fold6/test_monitoring_performance_optimization.py
index 37f1a25..f5fa898 100644
--- a/auto_generate_video_fold6/test_monitoring_performance_optimization.py
+++ b/auto_generate_video_fold6/test_monitoring_performance_optimization.py
@@ -21,28 +21,29 @@ import threading
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
+
 class MonitoringPerformanceOptimizationTest:
     """監控效能和可觀測性優化 TDD Refactor 測試套件"""
-    
+
     def __init__(self):
         self.project_root = Path(__file__).parent
         self.results = {
             "tests_passed": 0,
             "tests_failed": 0,
             "errors": [],
-            "performance_metrics": {}
+            "performance_metrics": {},
         }
-        
+
         # 效能基準 (微秒)
         self.performance_thresholds = {
             "log_entry_processing": 1000,  # 1ms
-            "metric_collection": 500,      # 0.5ms
-            "dashboard_query": 2000,       # 2ms
-            "alert_evaluation": 100,       # 0.1ms
-            "trace_span_creation": 50,     # 0.05ms
-            "correlation_id_lookup": 10,   # 0.01ms
+            "metric_collection": 500,  # 0.5ms
+            "dashboard_query": 2000,  # 2ms
+            "alert_evaluation": 100,  # 0.1ms
+            "trace_span_creation": 50,  # 0.05ms
+            "correlation_id_lookup": 10,  # 0.01ms
         }
-        
+
         # 可觀測性目標
         self.observability_targets = {
             "log_retention_days": 30,
@@ -51,8 +52,14 @@ class MonitoringPerformanceOptimizationTest:
             "dashboard_refresh_seconds": 5,
             "alert_notification_seconds": 30,
         }
-    
-    def _record_result(self, test_name: str, success: bool, error: str = None, metrics: Dict[str, float] = None):
+
+    def _record_result(
+        self,
+        test_name: str,
+        success: bool,
+        error: str = None,
+        metrics: Dict[str, float] = None,
+    ):
         """記錄測試結果和效能指標"""
         if success:
             self.results["tests_passed"] += 1
@@ -61,7 +68,7 @@ class MonitoringPerformanceOptimizationTest:
             self.results["tests_failed"] += 1
             self.results["errors"].append(f"{test_name}: {error}")
             logger.error(f"❌ {test_name} 失敗: {error}")
-        
+
         if metrics:
             self.results["performance_metrics"][test_name] = metrics
 
@@ -69,138 +76,187 @@ class MonitoringPerformanceOptimizationTest:
         """測試結構化日誌記錄效能"""
         try:
             # 檢查日誌記錄器是否存在
-            logger_module = self.project_root / "monitoring/logging/structured_logger.py"
+            logger_module = (
+                self.project_root / "monitoring/logging/structured_logger.py"
+            )
             assert logger_module.exists(), "結構化日誌記錄器不存在"
-            
+
             # 模擬高併發日誌記錄測試
             import importlib.util
-            spec = importlib.util.spec_from_file_location("structured_logger", logger_module)
+
+            spec = importlib.util.spec_from_file_location(
+                "structured_logger", logger_module
+            )
             structured_logger = importlib.util.module_from_spec(spec)
             spec.loader.exec_module(structured_logger)
-            
+
             # 創建測試日誌記錄器
             test_logger = structured_logger.get_logger("performance_test")
-            
+
             # 效能測試：單個日誌條目處理時間
             log_times = []
             for i in range(100):
                 start_time = time.perf_counter()
-                test_logger.info(f"Performance test log entry {i}", extra={
-                    "test_data": {"iteration": i, "timestamp": time.time()}
-                })
+                test_logger.info(
+                    f"Performance test log entry {i}",
+                    extra={
+                        "test_data": {"iteration": i, "timestamp": time.time()}
+                    },
+                )
                 end_time = time.perf_counter()
-                log_times.append((end_time - start_time) * 1000000)  # 轉換為微秒
-            
+                log_times.append(
+                    (end_time - start_time) * 1000000
+                )  # 轉換為微秒
+
             avg_log_time = statistics.mean(log_times)
-            p95_log_time = statistics.quantiles(log_times, n=20)[18]  # 95th percentile
+            p95_log_time = statistics.quantiles(log_times, n=20)[
+                18
+            ]  # 95th percentile
             max_log_time = max(log_times)
-            
+
             # 驗證效能要求
             threshold = self.performance_thresholds["log_entry_processing"]
-            assert avg_log_time < threshold, f"平均日誌處理時間 {avg_log_time:.2f}μs 超過閾值 {threshold}μs"
-            assert p95_log_time < threshold * 2, f"P95 日誌處理時間 {p95_log_time:.2f}μs 超過閾值 {threshold * 2}μs"
-            
+            assert avg_log_time < threshold, (
+                f"平均日誌處理時間 {avg_log_time:.2f}μs 超過閾值 {threshold}μs"
+            )
+            assert p95_log_time < threshold * 2, (
+                f"P95 日誌處理時間 {p95_log_time:.2f}μs 超過閾值 {threshold * 2}μs"
+            )
+
             # 併發測試
             def concurrent_logging(thread_id, log_count):
                 thread_times = []
                 for i in range(log_count):
                     start_time = time.perf_counter()
-                    test_logger.info(f"Concurrent log from thread {thread_id}, entry {i}")
+                    test_logger.info(
+                        f"Concurrent log from thread {thread_id}, entry {i}"
+                    )
                     end_time = time.perf_counter()
                     thread_times.append((end_time - start_time) * 1000000)
                 return thread_times
-            
-            with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
-                futures = [executor.submit(concurrent_logging, i, 20) for i in range(10)]
+
+            with concurrent.futures.ThreadPoolExecutor(
+                max_workers=10
+            ) as executor:
+                futures = [
+                    executor.submit(concurrent_logging, i, 20)
+                    for i in range(10)
+                ]
                 concurrent_times = []
                 for future in concurrent.futures.as_completed(futures):
                     concurrent_times.extend(future.result())
-            
+
             concurrent_avg = statistics.mean(concurrent_times)
-            
+
             metrics = {
                 "avg_log_time_us": avg_log_time,
                 "p95_log_time_us": p95_log_time,
                 "max_log_time_us": max_log_time,
                 "concurrent_avg_time_us": concurrent_avg,
-                "throughput_logs_per_second": 1000000 / avg_log_time
+                "throughput_logs_per_second": 1000000 / avg_log_time,
             }
-            
-            self._record_result("structured_logging_performance", True, metrics=metrics)
-            
+
+            self._record_result(
+                "structured_logging_performance", True, metrics=metrics
+            )
+
         except Exception as e:
-            self._record_result("structured_logging_performance", False, str(e))
+            self._record_result(
+                "structured_logging_performance", False, str(e)
+            )
 
     def test_prometheus_metrics_performance(self):
         """測試 Prometheus 指標收集效能"""
         try:
             # 檢查業務指標收集器
-            metrics_collector_path = self.project_root / "monitoring/business_metrics/business_metrics_collector.py"
+            metrics_collector_path = (
+                self.project_root
+                / "monitoring/business_metrics/business_metrics_collector.py"
+            )
             assert metrics_collector_path.exists(), "業務指標收集器不存在"
-            
+
             # 導入指標收集器
             import importlib.util
-            spec = importlib.util.spec_from_file_location("business_metrics_collector", metrics_collector_path)
+
+            spec = importlib.util.spec_from_file_location(
+                "business_metrics_collector", metrics_collector_path
+            )
             metrics_module = importlib.util.module_from_spec(spec)
             spec.loader.exec_module(metrics_module)
-            
+
             # 創建測試收集器
             collector = metrics_module.BusinessMetricsCollector()
-            
+
             # 效能測試：指標記錄時間
             metric_times = []
             for i in range(200):
                 start_time = time.perf_counter()
-                collector.record_metric("test_counter", i, {"iteration": str(i)})
+                collector.record_metric(
+                    "test_counter", i, {"iteration": str(i)}
+                )
                 end_time = time.perf_counter()
                 metric_times.append((end_time - start_time) * 1000000)
-            
+
             avg_metric_time = statistics.mean(metric_times)
             p95_metric_time = statistics.quantiles(metric_times, n=20)[18]
-            
+
             # 批量指標測試
             batch_start = time.perf_counter()
             for i in range(1000):
                 collector.record_metric("batch_test", i, {"batch": "true"})
             batch_end = time.perf_counter()
-            batch_time = (batch_end - batch_start) * 1000000 / 1000  # 每個指標的平均時間
-            
+            batch_time = (
+                (batch_end - batch_start) * 1000000 / 1000
+            )  # 每個指標的平均時間
+
             # 驗證效能要求
             threshold = self.performance_thresholds["metric_collection"]
-            assert avg_metric_time < threshold, f"平均指標收集時間 {avg_metric_time:.2f}μs 超過閾值 {threshold}μs"
-            
+            assert avg_metric_time < threshold, (
+                f"平均指標收集時間 {avg_metric_time:.2f}μs 超過閾值 {threshold}μs"
+            )
+
             # 測試指標摘要生成效能
             summary_start = time.perf_counter()
             summary = collector.get_all_metrics_summary()
             summary_end = time.perf_counter()
             summary_time = (summary_end - summary_start) * 1000
-            
+
             metrics = {
                 "avg_metric_time_us": avg_metric_time,
                 "p95_metric_time_us": p95_metric_time,
                 "batch_avg_time_us": batch_time,
                 "summary_generation_time_ms": summary_time,
-                "metrics_per_second": 1000000 / avg_metric_time
+                "metrics_per_second": 1000000 / avg_metric_time,
             }
-            
-            self._record_result("prometheus_metrics_performance", True, metrics=metrics)
-            
+
+            self._record_result(
+                "prometheus_metrics_performance", True, metrics=metrics
+            )
+
         except Exception as e:
-            self._record_result("prometheus_metrics_performance", False, str(e))
+            self._record_result(
+                "prometheus_metrics_performance", False, str(e)
+            )
 
     def test_correlation_middleware_performance(self):
         """測試關聯ID中間件效能"""
         try:
             # 檢查關聯中間件
-            middleware_path = self.project_root / "monitoring/middleware/correlation_middleware.py"
+            middleware_path = (
+                self.project_root
+                / "monitoring/middleware/correlation_middleware.py"
+            )
             assert middleware_path.exists(), "關聯ID中間件不存在"
-            
+
             # 導入中間件
             import importlib.util
-            spec = importlib.util.spec_from_file_location("correlation_middleware", middleware_path)
+
+            spec = importlib.util.spec_from_file_location(
+                "correlation_middleware", middleware_path
+            )
             middleware_module = importlib.util.module_from_spec(spec)
             spec.loader.exec_module(middleware_module)
-            
+
             # 測試關聯ID生成和查找效能
             correlation_times = []
             for i in range(1000):
@@ -208,68 +264,84 @@ class MonitoringPerformanceOptimizationTest:
                 correlation_id = middleware_module.get_correlation_id()
                 end_time = time.perf_counter()
                 correlation_times.append((end_time - start_time) * 1000000)
-            
+
             avg_correlation_time = statistics.mean(correlation_times)
             threshold = self.performance_thresholds["correlation_id_lookup"]
-            
+
             # 測試追踪事件記錄效能
             event_times = []
             for i in range(100):
                 start_time = time.perf_counter()
-                middleware_module.log_trace_event(f"test_event_{i}", iteration=i)
+                middleware_module.log_trace_event(
+                    f"test_event_{i}", iteration=i
+                )
                 end_time = time.perf_counter()
                 event_times.append((end_time - start_time) * 1000000)
-            
+
             avg_event_time = statistics.mean(event_times)
-            
+
             metrics = {
                 "avg_correlation_lookup_us": avg_correlation_time,
                 "avg_trace_event_time_us": avg_event_time,
-                "correlation_lookups_per_second": 1000000 / avg_correlation_time if avg_correlation_time > 0 else 0
+                "correlation_lookups_per_second": 1000000
+                / avg_correlation_time
+                if avg_correlation_time > 0
+                else 0,
             }
-            
-            self._record_result("correlation_middleware_performance", True, metrics=metrics)
-            
+
+            self._record_result(
+                "correlation_middleware_performance", True, metrics=metrics
+            )
+
         except Exception as e:
-            self._record_result("correlation_middleware_performance", False, str(e))
+            self._record_result(
+                "correlation_middleware_performance", False, str(e)
+            )
 
     def test_opentelemetry_span_performance(self):
         """測試 OpenTelemetry Span 創建效能"""
         try:
             # 檢查 OpenTelemetry 中間件
-            otel_path = self.project_root / "monitoring/tracing/opentelemetry_middleware.py"
+            otel_path = (
+                self.project_root
+                / "monitoring/tracing/opentelemetry_middleware.py"
+            )
             assert otel_path.exists(), "OpenTelemetry 中間件不存在"
-            
+
             # 導入 OpenTelemetry 模組
             import importlib.util
-            spec = importlib.util.spec_from_file_location("opentelemetry_middleware", otel_path)
+
+            spec = importlib.util.spec_from_file_location(
+                "opentelemetry_middleware", otel_path
+            )
             otel_module = importlib.util.module_from_spec(spec)
             spec.loader.exec_module(otel_module)
-            
+
             # 創建測試中間件
             otel_middleware = otel_module.OpenTelemetryMiddleware(
-                service_name="performance_test",
-                service_version="1.0.0"
+                service_name="performance_test", service_version="1.0.0"
             )
-            
+
             # 測試 Span 創建效能
             span_times = []
             for i in range(500):
                 start_time = time.perf_counter()
-                span = otel_middleware.create_span(f"test_span_{i}", {
-                    "iteration": i,
-                    "test_type": "performance"
-                })
+                span = otel_middleware.create_span(
+                    f"test_span_{i}",
+                    {"iteration": i, "test_type": "performance"},
+                )
                 span.end()
                 end_time = time.perf_counter()
                 span_times.append((end_time - start_time) * 1000000)
-            
+
             avg_span_time = statistics.mean(span_times)
             p95_span_time = statistics.quantiles(span_times, n=20)[18]
-            
+
             threshold = self.performance_thresholds["trace_span_creation"]
-            assert avg_span_time < threshold, f"平均 Span 創建時間 {avg_span_time:.3f}μs 超過閾值 {threshold}μs"
-            
+            assert avg_span_time < threshold, (
+                f"平均 Span 創建時間 {avg_span_time:.3f}μs 超過閾值 {threshold}μs"
+            )
+
             # 測試嵌套 Span 效能
             nested_start = time.perf_counter()
             parent_span = otel_middleware.create_span("parent_span")
@@ -278,94 +350,124 @@ class MonitoringPerformanceOptimizationTest:
                 child_span.end()
             parent_span.end()
             nested_end = time.perf_counter()
-            nested_time = (nested_end - nested_start) * 1000000 / 11  # 平均每個 span
-            
+            nested_time = (
+                (nested_end - nested_start) * 1000000 / 11
+            )  # 平均每個 span
+
             metrics = {
                 "avg_span_creation_us": avg_span_time,
                 "p95_span_creation_us": p95_span_time,
                 "nested_span_avg_us": nested_time,
-                "spans_per_second": 1000000 / avg_span_time
+                "spans_per_second": 1000000 / avg_span_time,
             }
-            
-            self._record_result("opentelemetry_span_performance", True, metrics=metrics)
-            
+
+            self._record_result(
+                "opentelemetry_span_performance", True, metrics=metrics
+            )
+
         except Exception as e:
-            self._record_result("opentelemetry_span_performance", False, str(e))
+            self._record_result(
+                "opentelemetry_span_performance", False, str(e)
+            )
 
     def test_grafana_dashboard_query_optimization(self):
         """測試 Grafana 儀表板查詢優化"""
         try:
             # 檢查儀表板配置
-            dashboards_dir = self.project_root / "monitoring/grafana/dashboards"
+            dashboards_dir = (
+                self.project_root / "monitoring/grafana/dashboards"
+            )
             assert dashboards_dir.exists(), "Grafana 儀表板目錄不存在"
-            
+
             dashboard_files = list(dashboards_dir.glob("*.json"))
             assert len(dashboard_files) > 0, "沒有找到儀表板配置檔案"
-            
+
             # 分析每個儀表板的查詢複雜度
             dashboard_metrics = {}
-            
+
             for dashboard_file in dashboard_files:
-                with open(dashboard_file, 'r') as f:
+                with open(dashboard_file, "r") as f:
                     dashboard_config = json.load(f)
-                
+
                 dashboard_name = dashboard_file.stem
-                panels = dashboard_config.get('dashboard', {}).get('panels', [])
-                
+                panels = dashboard_config.get("dashboard", {}).get(
+                    "panels", []
+                )
+
                 query_count = 0
                 complex_queries = 0
-                
+
                 for panel in panels:
-                    targets = panel.get('targets', [])
+                    targets = panel.get("targets", [])
                     query_count += len(targets)
-                    
+
                     for target in targets:
-                        expr = target.get('expr', '')
+                        expr = target.get("expr", "")
                         # 檢查查詢複雜度（簡單指標）
-                        if any(func in expr for func in ['rate(', 'increase(', 'histogram_quantile(']):
+                        if any(
+                            func in expr
+                            for func in [
+                                "rate(",
+                                "increase(",
+                                "histogram_quantile(",
+                            ]
+                        ):
                             complex_queries += 1
-                
+
                 dashboard_metrics[dashboard_name] = {
                     "total_queries": query_count,
                     "complex_queries": complex_queries,
-                    "complexity_ratio": complex_queries / query_count if query_count > 0 else 0,
-                    "panels_count": len(panels)
+                    "complexity_ratio": complex_queries / query_count
+                    if query_count > 0
+                    else 0,
+                    "panels_count": len(panels),
                 }
-            
+
             # 驗證儀表板效能特性
-            total_queries = sum(m["total_queries"] for m in dashboard_metrics.values())
+            total_queries = sum(
+                m["total_queries"] for m in dashboard_metrics.values()
+            )
             avg_queries_per_dashboard = total_queries / len(dashboard_metrics)
-            
+
             # 建議：每個儀表板不超過 20 個查詢以保持效能
-            assert avg_queries_per_dashboard <= 20, f"平均每個儀表板查詢數 {avg_queries_per_dashboard:.1f} 過多，建議不超過 20"
-            
+            assert avg_queries_per_dashboard <= 20, (
+                f"平均每個儀表板查詢數 {avg_queries_per_dashboard:.1f} 過多，建議不超過 20"
+            )
+
             metrics = {
                 "total_dashboards": len(dashboard_metrics),
                 "total_queries": total_queries,
                 "avg_queries_per_dashboard": avg_queries_per_dashboard,
-                "dashboard_details": dashboard_metrics
+                "dashboard_details": dashboard_metrics,
             }
-            
-            self._record_result("grafana_dashboard_query_optimization", True, metrics=metrics)
-            
+
+            self._record_result(
+                "grafana_dashboard_query_optimization", True, metrics=metrics
+            )
+
         except Exception as e:
-            self._record_result("grafana_dashboard_query_optimization", False, str(e))
+            self._record_result(
+                "grafana_dashboard_query_optimization", False, str(e)
+            )
 
     def test_log_aggregation_performance(self):
         """測試日誌聚合管道效能"""
         try:
             # 檢查 Logstash 配置
-            logstash_config = self.project_root / "monitoring/logstash/pipeline/logstash.conf"
+            logstash_config = (
+                self.project_root
+                / "monitoring/logstash/pipeline/logstash.conf"
+            )
             assert logstash_config.exists(), "Logstash 配置不存在"
-            
+
             config_content = logstash_config.read_text()
-            
+
             # 分析配置效能特性
             has_grok_filter = "grok" in config_content
             has_json_filter = "json" in config_content
             has_date_filter = "date" in config_content
             has_mutate_filter = "mutate" in config_content
-            
+
             # 計算預期處理延遲（基於過濾器複雜度）
             base_latency = 10  # 基礎延遲 ms
             if has_grok_filter:
@@ -376,38 +478,44 @@ class MonitoringPerformanceOptimizationTest:
                 base_latency += 3  # 日期解析
             if has_mutate_filter:
                 base_latency += 1  # 字段變更
-            
+
             # 檢查 Fluent Bit 配置
-            fluent_config = self.project_root / "monitoring/logging/fluent-bit.conf"
+            fluent_config = (
+                self.project_root / "monitoring/logging/fluent-bit.conf"
+            )
             assert fluent_config.exists(), "Fluent Bit 配置不存在"
-            
+
             fluent_content = fluent_config.read_text()
-            
+
             # 計算緩衝配置
             buffer_chunk_size = "1MB"  # 預設值
-            buffer_max_size = "5MB"    # 預設值
-            
+            buffer_max_size = "5MB"  # 預設值
+
             if "Chunk_Size" in fluent_content:
                 # 提取實際配置值（簡化實作）
-                for line in fluent_content.split('\n'):
+                for line in fluent_content.split("\n"):
                     if "Chunk_Size" in line:
                         buffer_chunk_size = line.split()[-1]
                         break
-            
+
             metrics = {
                 "estimated_processing_latency_ms": base_latency,
                 "has_grok_filter": has_grok_filter,
                 "has_json_filter": has_json_filter,
                 "has_date_filter": has_date_filter,
                 "buffer_chunk_size": buffer_chunk_size,
-                "buffer_max_size": buffer_max_size
+                "buffer_max_size": buffer_max_size,
             }
-            
+
             # 效能驗證：預期延遲不超過 50ms
-            assert base_latency <= 50, f"預期日誌處理延遲 {base_latency}ms 過高，建議不超過 50ms"
-            
-            self._record_result("log_aggregation_performance", True, metrics=metrics)
-            
+            assert base_latency <= 50, (
+                f"預期日誌處理延遲 {base_latency}ms 過高，建議不超過 50ms"
+            )
+
+            self._record_result(
+                "log_aggregation_performance", True, metrics=metrics
+            )
+
         except Exception as e:
             self._record_result("log_aggregation_performance", False, str(e))
 
@@ -417,69 +525,84 @@ class MonitoringPerformanceOptimizationTest:
             # 檢查警報規則配置
             rules_dir = self.project_root / "monitoring/prometheus/rules"
             assert rules_dir.exists(), "警報規則目錄不存在"
-            
+
             rule_files = list(rules_dir.glob("*.yml"))
             assert len(rule_files) > 0, "沒有找到警報規則檔案"
-            
+
             total_rules = 0
             complex_rules = 0
             rule_complexity_scores = []
-            
+
             try:
                 import yaml
+
                 yaml_available = True
             except ImportError:
                 yaml_available = False
-            
+
             for rule_file in rule_files:
                 if yaml_available:
-                    with open(rule_file, 'r') as f:
+                    with open(rule_file, "r") as f:
                         rules_config = yaml.safe_load(f)
-                    
-                    for group in rules_config.get('groups', []):
-                        for rule in group.get('rules', []):
+
+                    for group in rules_config.get("groups", []):
+                        for rule in group.get("rules", []):
                             total_rules += 1
-                            expr = rule.get('expr', '')
-                            
+                            expr = rule.get("expr", "")
+
                             # 計算規則複雜度分數
                             complexity = 0
-                            complexity += expr.count('(')  # 括號數量
-                            complexity += expr.count('rate(') * 2  # rate 函數
-                            complexity += expr.count('histogram_quantile(') * 3  # 分位數計算
-                            complexity += expr.count('by(') * 1  # 分組操作
-                            
+                            complexity += expr.count("(")  # 括號數量
+                            complexity += expr.count("rate(") * 2  # rate 函數
+                            complexity += (
+                                expr.count("histogram_quantile(") * 3
+                            )  # 分位數計算
+                            complexity += expr.count("by(") * 1  # 分組操作
+
                             rule_complexity_scores.append(complexity)
-                            
+
                             if complexity > 5:  # 複雜規則閾值
                                 complex_rules += 1
                 else:
                     # 簡單文本分析
                     content = rule_file.read_text()
-                    total_rules += content.count('alert:')
-                    complex_rules += content.count('histogram_quantile')
-            
-            avg_complexity = statistics.mean(rule_complexity_scores) if rule_complexity_scores else 0
-            max_complexity = max(rule_complexity_scores) if rule_complexity_scores else 0
-            
+                    total_rules += content.count("alert:")
+                    complex_rules += content.count("histogram_quantile")
+
+            avg_complexity = (
+                statistics.mean(rule_complexity_scores)
+                if rule_complexity_scores
+                else 0
+            )
+            max_complexity = (
+                max(rule_complexity_scores) if rule_complexity_scores else 0
+            )
+
             # 預估警報評估時間（基於複雜度）
             base_eval_time = 10  # 基礎評估時間 μs
             estimated_eval_time = base_eval_time + (avg_complexity * 20)
-            
+
             metrics = {
                 "total_rules": total_rules,
                 "complex_rules": complex_rules,
-                "complexity_ratio": complex_rules / total_rules if total_rules > 0 else 0,
+                "complexity_ratio": complex_rules / total_rules
+                if total_rules > 0
+                else 0,
                 "avg_complexity_score": avg_complexity,
                 "max_complexity_score": max_complexity,
-                "estimated_eval_time_us": estimated_eval_time
+                "estimated_eval_time_us": estimated_eval_time,
             }
-            
+
             # 效能驗證
             threshold = self.performance_thresholds["alert_evaluation"]
-            assert estimated_eval_time <= threshold, f"預估警報評估時間 {estimated_eval_time:.1f}μs 超過閾值 {threshold}μs"
-            
-            self._record_result("alert_evaluation_performance", True, metrics=metrics)
-            
+            assert estimated_eval_time <= threshold, (
+                f"預估警報評估時間 {estimated_eval_time:.1f}μs 超過閾值 {threshold}μs"
+            )
+
+            self._record_result(
+                "alert_evaluation_performance", True, metrics=metrics
+            )
+
         except Exception as e:
             self._record_result("alert_evaluation_performance", False, str(e))
 
@@ -487,45 +610,58 @@ class MonitoringPerformanceOptimizationTest:
         """測試可觀測性配置優化"""
         try:
             # 檢查資料保留配置
-            prometheus_config = self.project_root / "monitoring/prometheus/prometheus.yml"
+            prometheus_config = (
+                self.project_root / "monitoring/prometheus/prometheus.yml"
+            )
             assert prometheus_config.exists(), "Prometheus 配置不存在"
-            
+
             config_content = prometheus_config.read_text()
-            
+
             # 檢查抓取間隔配置
             scrape_interval = "15s"  # 預設值
             if "scrape_interval:" in config_content:
-                for line in config_content.split('\n'):
-                    if "scrape_interval:" in line and not line.strip().startswith('#'):
-                        scrape_interval = line.split(':')[-1].strip()
+                for line in config_content.split("\n"):
+                    if (
+                        "scrape_interval:" in line
+                        and not line.strip().startswith("#")
+                    ):
+                        scrape_interval = line.split(":")[-1].strip()
                         break
-            
+
             # 轉換為秒
             interval_seconds = 15
-            if scrape_interval.endswith('s'):
+            if scrape_interval.endswith("s"):
                 interval_seconds = int(scrape_interval[:-1])
-            elif scrape_interval.endswith('m'):
+            elif scrape_interval.endswith("m"):
                 interval_seconds = int(scrape_interval[:-1]) * 60
-            
+
             # 檢查儲存配置（模擬）
             retention_days = 15  # Prometheus 預設
             retention_size = "10GB"
-            
+
             # 檢查 Grafana 配置
-            grafana_config = self.project_root / "monitoring/grafana/grafana.ini"
+            grafana_config = (
+                self.project_root / "monitoring/grafana/grafana.ini"
+            )
             if grafana_config.exists():
                 grafana_content = grafana_config.read_text()
                 # 檢查緩存配置
                 has_query_cache = "query_caching_enabled" in grafana_content
             else:
                 has_query_cache = False
-            
+
             # 計算預估資料量
             services_count = 8  # 基於系統服務數量
             metrics_per_service = 50  # 每個服務的平均指標數
-            data_points_per_day = services_count * metrics_per_service * (86400 / interval_seconds)
-            estimated_storage_mb_per_day = data_points_per_day * 0.1 / 1024  # 估算
-            
+            data_points_per_day = (
+                services_count
+                * metrics_per_service
+                * (86400 / interval_seconds)
+            )
+            estimated_storage_mb_per_day = (
+                data_points_per_day * 0.1 / 1024
+            )  # 估算
+
             metrics = {
                 "scrape_interval_seconds": interval_seconds,
                 "retention_days": retention_days,
@@ -533,57 +669,83 @@ class MonitoringPerformanceOptimizationTest:
                 "estimated_data_points_per_day": data_points_per_day,
                 "estimated_storage_mb_per_day": estimated_storage_mb_per_day,
                 "has_grafana_query_cache": has_query_cache,
-                "services_monitored": services_count
+                "services_monitored": services_count,
             }
-            
+
             # 驗證配置合理性
-            target_interval = self.observability_targets["metric_resolution_seconds"]
-            assert interval_seconds <= target_interval, f"抓取間隔 {interval_seconds}s 超過目標 {target_interval}s"
-            
+            target_interval = self.observability_targets[
+                "metric_resolution_seconds"
+            ]
+            assert interval_seconds <= target_interval, (
+                f"抓取間隔 {interval_seconds}s 超過目標 {target_interval}s"
+            )
+
             target_retention = self.observability_targets["log_retention_days"]
-            assert retention_days >= target_retention, f"資料保留期 {retention_days} 天不足，目標 {target_retention} 天"
-            
-            self._record_result("observability_configuration_optimization", True, metrics=metrics)
-            
+            assert retention_days >= target_retention, (
+                f"資料保留期 {retention_days} 天不足，目標 {target_retention} 天"
+            )
+
+            self._record_result(
+                "observability_configuration_optimization",
+                True,
+                metrics=metrics,
+            )
+
         except Exception as e:
-            self._record_result("observability_configuration_optimization", False, str(e))
+            self._record_result(
+                "observability_configuration_optimization", False, str(e)
+            )
 
     def print_results(self):
         """打印測試結果和效能分析"""
-        total_tests = self.results["tests_passed"] + self.results["tests_failed"]
-        success_rate = (self.results["tests_passed"] / total_tests * 100) if total_tests > 0 else 0
-        
+        total_tests = (
+            self.results["tests_passed"] + self.results["tests_failed"]
+        )
+        success_rate = (
+            (self.results["tests_passed"] / total_tests * 100)
+            if total_tests > 0
+            else 0
+        )
+
         logger.info("=" * 70)
         logger.info("🔧 TDD Refactor 階段: 監控效能和可觀測性優化結果")
         logger.info("=" * 70)
         logger.info(f"✅ 通過測試: {self.results['tests_passed']}")
         logger.info(f"❌ 失敗測試: {self.results['tests_failed']}")
         logger.info(f"📈 測試成功率: {success_rate:.1f}%")
-        
+
         if self.results["errors"]:
             logger.info("\n🎯 需要優化的項目:")
             for error in self.results["errors"]:
                 logger.info(f"  - {error}")
-        
+
         # 效能分析報告
         if self.results["performance_metrics"]:
             logger.info("\n📊 效能分析報告:")
-            for test_name, metrics in self.results["performance_metrics"].items():
+            for test_name, metrics in self.results[
+                "performance_metrics"
+            ].items():
                 logger.info(f"  📈 {test_name}:")
                 for metric_name, value in metrics.items():
                     if isinstance(value, (int, float)):
                         logger.info(f"    - {metric_name}: {value:.3f}")
                     else:
                         logger.info(f"    - {metric_name}: {value}")
-        
+
         # Refactor 階段評估
         if success_rate >= 90:
-            logger.info("\n🟢 TDD Refactor 階段狀態: 優秀 - 效能和可觀測性優化成功")
+            logger.info(
+                "\n🟢 TDD Refactor 階段狀態: 優秀 - 效能和可觀測性優化成功"
+            )
         elif success_rate >= 70:
-            logger.info("\n🟡 TDD Refactor 階段狀態: 良好 - 大部分優化成功，少數需調整")
+            logger.info(
+                "\n🟡 TDD Refactor 階段狀態: 良好 - 大部分優化成功，少數需調整"
+            )
         else:
-            logger.info("\n🔴 TDD Refactor 階段狀態: 需改進 - 多數效能指標需要優化")
-        
+            logger.info(
+                "\n🔴 TDD Refactor 階段狀態: 需改進 - 多數效能指標需要優化"
+            )
+
         return success_rate >= 70
 
 
@@ -592,9 +754,9 @@ def main():
     logger.info("🔧 開始 TDD Refactor 階段: 監控效能和可觀測性優化")
     logger.info("目標: 優化監控系統效能並增強可觀測性功能")
     logger.info("=" * 70)
-    
+
     test_suite = MonitoringPerformanceOptimizationTest()
-    
+
     try:
         # 執行所有優化測試
         test_suite.test_structured_logging_performance()
@@ -605,10 +767,10 @@ def main():
         test_suite.test_log_aggregation_performance()
         test_suite.test_alert_evaluation_performance()
         test_suite.test_observability_configuration_optimization()
-        
+
         # 打印結果和分析
         is_successful = test_suite.print_results()
-        
+
         if is_successful:
             logger.info("\n🎉 TDD Refactor 階段成功！")
             logger.info("✨ 監控系統效能和可觀測性優化完成")
@@ -616,9 +778,9 @@ def main():
         else:
             logger.info("\n🔧 TDD Refactor 階段需要進一步優化")
             logger.info("📊 請根據效能分析報告進行調整")
-        
+
         return is_successful
-        
+
     except Exception as e:
         logger.error(f"❌ Refactor 階段測試執行異常: {e}")
         return False
@@ -626,10 +788,10 @@ def main():
 
 if __name__ == "__main__":
     success = main()
-    
+
     if success:
         logger.info("🏁 TDD Refactor 階段完成 - 監控效能優化成功")
         exit(0)
     else:
         logger.error("🛑 TDD Refactor 階段需要改進")
-        exit(1)
\ No newline at end of file
+        exit(1)
diff --git a/auto_generate_video_fold6/test_monitoring_performance_refactored.py b/auto_generate_video_fold6/test_monitoring_performance_refactored.py
index de70853..98547dd 100644
--- a/auto_generate_video_fold6/test_monitoring_performance_refactored.py
+++ b/auto_generate_video_fold6/test_monitoring_performance_refactored.py
@@ -23,27 +23,34 @@ import uuid
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
+
 class MonitoringPerformanceRefactoredTest:
     """監控效能和可觀測性優化重構測試套件"""
-    
+
     def __init__(self):
         self.project_root = Path(__file__).parent
         self.results = {
             "tests_passed": 0,
             "tests_failed": 0,
             "errors": [],
-            "performance_metrics": {}
+            "performance_metrics": {},
         }
-        
+
         # 效能基準 (微秒)
         self.performance_thresholds = {
             "log_entry_processing": 1000,  # 1ms
-            "metric_collection": 500,      # 0.5ms
-            "correlation_lookup": 50,      # 0.05ms
-            "span_creation": 100,          # 0.1ms
+            "metric_collection": 500,  # 0.5ms
+            "correlation_lookup": 50,  # 0.05ms
+            "span_creation": 100,  # 0.1ms
         }
-    
-    def _record_result(self, test_name: str, success: bool, error: str = None, metrics: Dict[str, float] = None):
+
+    def _record_result(
+        self,
+        test_name: str,
+        success: bool,
+        error: str = None,
+        metrics: Dict[str, float] = None,
+    ):
         """記錄測試結果和效能指標"""
         if success:
             self.results["tests_passed"] += 1
@@ -52,7 +59,7 @@ class MonitoringPerformanceRefactoredTest:
             self.results["tests_failed"] += 1
             self.results["errors"].append(f"{test_name}: {error}")
             logger.error(f"❌ {test_name} 失敗: {error}")
-        
+
         if metrics:
             self.results["performance_metrics"][test_name] = metrics
 
@@ -60,31 +67,40 @@ class MonitoringPerformanceRefactoredTest:
         """測試優化的日誌記錄效能"""
         try:
             # 導入優化的效能日誌記錄器
-            from monitoring.logging.performance_logger import get_performance_logger, performance_monitor
-            
+            from monitoring.logging.performance_logger import (
+                get_performance_logger,
+                performance_monitor,
+            )
+
             # 創建測試日誌記錄器
-            test_logger = get_performance_logger("performance_test", 
-                                               buffer_size=500, 
-                                               enable_async=True)
-            
+            test_logger = get_performance_logger(
+                "performance_test", buffer_size=500, enable_async=True
+            )
+
             # 單個日誌條目效能測試
             log_times = []
             for i in range(200):
                 start_time = time.perf_counter()
-                test_logger.info(f"Performance test log {i}", 
-                               iteration=i, 
-                               test_type="performance")
+                test_logger.info(
+                    f"Performance test log {i}",
+                    iteration=i,
+                    test_type="performance",
+                )
                 end_time = time.perf_counter()
                 log_times.append((end_time - start_time) * 1000000)
-            
+
             # 強制刷新緩衝區
             test_logger.flush()
-            
+
             # 計算統計
             avg_log_time = statistics.mean(log_times)
-            p95_log_time = statistics.quantiles(log_times, n=20)[18] if len(log_times) > 20 else max(log_times)
+            p95_log_time = (
+                statistics.quantiles(log_times, n=20)[18]
+                if len(log_times) > 20
+                else max(log_times)
+            )
             max_log_time = max(log_times)
-            
+
             # 併發日誌記錄測試
             def concurrent_logging_task(thread_id: int, log_count: int):
                 thread_times = []
@@ -94,34 +110,47 @@ class MonitoringPerformanceRefactoredTest:
                     end_time = time.perf_counter()
                     thread_times.append((end_time - start_time) * 1000000)
                 return thread_times
-            
-            with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
-                futures = [executor.submit(concurrent_logging_task, i, 50) for i in range(5)]
+
+            with concurrent.futures.ThreadPoolExecutor(
+                max_workers=5
+            ) as executor:
+                futures = [
+                    executor.submit(concurrent_logging_task, i, 50)
+                    for i in range(5)
+                ]
                 concurrent_times = []
                 for future in concurrent.futures.as_completed(futures):
                     concurrent_times.extend(future.result())
-            
+
             concurrent_avg = statistics.mean(concurrent_times)
-            
+
             # 獲取日誌記錄器統計
             logger_stats = test_logger.get_stats()
-            
+
             metrics = {
                 "avg_log_time_us": avg_log_time,
                 "p95_log_time_us": p95_log_time,
                 "max_log_time_us": max_log_time,
                 "concurrent_avg_time_us": concurrent_avg,
-                "throughput_logs_per_second": 1000000 / avg_log_time if avg_log_time > 0 else 0,
-                "buffer_utilization": logger_stats.get("buffer_utilization", 0),
-                "total_logs_processed": logger_stats.get("logs_processed", 0)
+                "throughput_logs_per_second": 1000000 / avg_log_time
+                if avg_log_time > 0
+                else 0,
+                "buffer_utilization": logger_stats.get(
+                    "buffer_utilization", 0
+                ),
+                "total_logs_processed": logger_stats.get("logs_processed", 0),
             }
-            
+
             # 效能驗證
             threshold = self.performance_thresholds["log_entry_processing"]
-            assert avg_log_time < threshold, f"平均日誌處理時間 {avg_log_time:.2f}μs 超過閾值 {threshold}μs"
-            
-            self._record_result("optimized_logging_performance", True, metrics=metrics)
-            
+            assert avg_log_time < threshold, (
+                f"平均日誌處理時間 {avg_log_time:.2f}μs 超過閾值 {threshold}μs"
+            )
+
+            self._record_result(
+                "optimized_logging_performance", True, metrics=metrics
+            )
+
         except Exception as e:
             self._record_result("optimized_logging_performance", False, str(e))
 
@@ -129,15 +158,18 @@ class MonitoringPerformanceRefactoredTest:
         """測試優化的指標收集效能"""
         try:
             # 導入優化的指標收集器
-            from monitoring.metrics.optimized_metrics_collector import OptimizedMetricsCollector, MetricType
-            
+            from monitoring.metrics.optimized_metrics_collector import (
+                OptimizedMetricsCollector,
+                MetricType,
+            )
+
             # 創建測試收集器
             collector = OptimizedMetricsCollector(
                 buffer_size=1000,
                 flush_interval=2.0,
-                enable_sampling=False  # 關閉採樣以獲得準確的效能測試
+                enable_sampling=False,  # 關閉採樣以獲得準確的效能測試
             )
-            
+
             # 單個指標記錄效能測試
             metric_times = []
             for i in range(500):
@@ -146,62 +178,86 @@ class MonitoringPerformanceRefactoredTest:
                     f"test_metric_{i % 10}",
                     i,
                     labels={"iteration": str(i), "batch": str(i // 100)},
-                    metric_type=MetricType.GAUGE
+                    metric_type=MetricType.GAUGE,
                 )
                 end_time = time.perf_counter()
                 metric_times.append((end_time - start_time) * 1000000)
-            
+
             avg_metric_time = statistics.mean(metric_times)
-            p95_metric_time = statistics.quantiles(metric_times, n=20)[18] if len(metric_times) > 20 else max(metric_times)
-            
+            p95_metric_time = (
+                statistics.quantiles(metric_times, n=20)[18]
+                if len(metric_times) > 20
+                else max(metric_times)
+            )
+
             # 批量指標測試
             batch_start = time.perf_counter()
             for i in range(1000):
-                collector.increment_counter("batch_counter", 1, {"batch_id": str(i // 100)})
+                collector.increment_counter(
+                    "batch_counter", 1, {"batch_id": str(i // 100)}
+                )
             batch_end = time.perf_counter()
             batch_avg_time = (batch_end - batch_start) * 1000000 / 1000
-            
+
             # 不同類型指標測試
             histogram_times = []
             for i in range(100):
                 start_time = time.perf_counter()
-                collector.observe_histogram("response_time", i * 0.01, {"endpoint": f"/api/v{i%3}"})
+                collector.observe_histogram(
+                    "response_time", i * 0.01, {"endpoint": f"/api/v{i % 3}"}
+                )
                 end_time = time.perf_counter()
                 histogram_times.append((end_time - start_time) * 1000000)
-            
+
             avg_histogram_time = statistics.mean(histogram_times)
-            
+
             # 獲取收集器統計
             collector_stats = collector.get_performance_stats()
-            
+
             metrics = {
                 "avg_metric_time_us": avg_metric_time,
                 "p95_metric_time_us": p95_metric_time,
                 "batch_avg_time_us": batch_avg_time,
                 "histogram_avg_time_us": avg_histogram_time,
-                "metrics_per_second": 1000000 / avg_metric_time if avg_metric_time > 0 else 0,
-                "buffer_utilization": collector_stats.get("buffer_utilization", 0),
-                "total_metrics_processed": collector_stats.get("metrics_processed", 0),
-                "total_buffer_flushes": collector_stats.get("buffer_flushes", 0)
+                "metrics_per_second": 1000000 / avg_metric_time
+                if avg_metric_time > 0
+                else 0,
+                "buffer_utilization": collector_stats.get(
+                    "buffer_utilization", 0
+                ),
+                "total_metrics_processed": collector_stats.get(
+                    "metrics_processed", 0
+                ),
+                "total_buffer_flushes": collector_stats.get(
+                    "buffer_flushes", 0
+                ),
             }
-            
+
             # 效能驗證
             threshold = self.performance_thresholds["metric_collection"]
-            assert avg_metric_time < threshold, f"平均指標收集時間 {avg_metric_time:.2f}μs 超過閾值 {threshold}μs"
-            
-            self._record_result("optimized_metrics_collection_performance", True, metrics=metrics)
-            
+            assert avg_metric_time < threshold, (
+                f"平均指標收集時間 {avg_metric_time:.2f}μs 超過閾值 {threshold}μs"
+            )
+
+            self._record_result(
+                "optimized_metrics_collection_performance",
+                True,
+                metrics=metrics,
+            )
+
         except Exception as e:
-            self._record_result("optimized_metrics_collection_performance", False, str(e))
+            self._record_result(
+                "optimized_metrics_collection_performance", False, str(e)
+            )
 
     def test_correlation_id_performance(self):
         """測試關聯ID處理效能"""
         try:
             # 模擬關聯ID上下文操作
             from contextvars import ContextVar
-            
+
             correlation_id_context = ContextVar("correlation_id", default=None)
-            
+
             # 關聯ID生成效能測試
             generation_times = []
             for i in range(1000):
@@ -211,12 +267,18 @@ class MonitoringPerformanceRefactoredTest:
                 retrieved_id = correlation_id_context.get()
                 end_time = time.perf_counter()
                 generation_times.append((end_time - start_time) * 1000000)
-            
+
             avg_generation_time = statistics.mean(generation_times)
-            p95_generation_time = statistics.quantiles(generation_times, n=20)[18] if len(generation_times) > 20 else max(generation_times)
-            
+            p95_generation_time = (
+                statistics.quantiles(generation_times, n=20)[18]
+                if len(generation_times) > 20
+                else max(generation_times)
+            )
+
             # 併發關聯ID操作測試
-            def concurrent_correlation_task(task_id: int, operation_count: int):
+            def concurrent_correlation_task(
+                task_id: int, operation_count: int
+            ):
                 task_times = []
                 for i in range(operation_count):
                     start_time = time.perf_counter()
@@ -227,47 +289,58 @@ class MonitoringPerformanceRefactoredTest:
                     end_time = time.perf_counter()
                     task_times.append((end_time - start_time) * 1000000)
                 return task_times
-            
-            with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
-                futures = [executor.submit(concurrent_correlation_task, i, 100) for i in range(10)]
+
+            with concurrent.futures.ThreadPoolExecutor(
+                max_workers=10
+            ) as executor:
+                futures = [
+                    executor.submit(concurrent_correlation_task, i, 100)
+                    for i in range(10)
+                ]
                 concurrent_times = []
                 for future in concurrent.futures.as_completed(futures):
                     concurrent_times.extend(future.result())
-            
+
             concurrent_avg = statistics.mean(concurrent_times)
-            
+
             # 上下文切換效能測試
             context_switch_times = []
             for i in range(500):
                 old_id = f"old-{i}"
                 new_id = f"new-{i}"
-                
+
                 correlation_id_context.set(old_id)
-                
+
                 start_time = time.perf_counter()
                 token = correlation_id_context.set(new_id)
                 retrieved = correlation_id_context.get()
                 correlation_id_context.reset(token)
                 end_time = time.perf_counter()
-                
+
                 context_switch_times.append((end_time - start_time) * 1000000)
-            
+
             avg_context_switch_time = statistics.mean(context_switch_times)
-            
+
             metrics = {
                 "avg_generation_time_us": avg_generation_time,
                 "p95_generation_time_us": p95_generation_time,
                 "concurrent_avg_time_us": concurrent_avg,
                 "context_switch_avg_time_us": avg_context_switch_time,
-                "operations_per_second": 1000000 / avg_generation_time if avg_generation_time > 0 else 0
+                "operations_per_second": 1000000 / avg_generation_time
+                if avg_generation_time > 0
+                else 0,
             }
-            
+
             # 效能驗證
             threshold = self.performance_thresholds["correlation_lookup"]
-            assert avg_generation_time < threshold, f"平均關聯ID處理時間 {avg_generation_time:.3f}μs 超過閾值 {threshold}μs"
-            
-            self._record_result("correlation_id_performance", True, metrics=metrics)
-            
+            assert avg_generation_time < threshold, (
+                f"平均關聯ID處理時間 {avg_generation_time:.3f}μs 超過閾值 {threshold}μs"
+            )
+
+            self._record_result(
+                "correlation_id_performance", True, metrics=metrics
+            )
+
         except Exception as e:
             self._record_result("correlation_id_performance", False, str(e))
 
@@ -275,34 +348,42 @@ class MonitoringPerformanceRefactoredTest:
         """測試監控配置優化"""
         try:
             # 檢查 Prometheus 配置優化
-            prometheus_config = self.project_root / "monitoring/prometheus/prometheus.yml"
+            prometheus_config = (
+                self.project_root / "monitoring/prometheus/prometheus.yml"
+            )
             assert prometheus_config.exists(), "Prometheus 配置不存在"
-            
+
             config_content = prometheus_config.read_text()
-            
+
             # 檢查效能優化配置
             has_query_log = "query_log_file" in config_content
             has_retention_config = "storage.tsdb.retention" in config_content
             has_compression = "wal-compression" in config_content
             has_concurrency_config = "query.max-concurrency" in config_content
-            
+
             # 檢查抓取間隔優化
             scrape_intervals = []
-            for line in config_content.split('\n'):
-                if "scrape_interval:" in line and not line.strip().startswith('#'):
-                    interval_str = line.split(':')[-1].strip()
-                    if interval_str.endswith('s'):
+            for line in config_content.split("\n"):
+                if "scrape_interval:" in line and not line.strip().startswith(
+                    "#"
+                ):
+                    interval_str = line.split(":")[-1].strip()
+                    if interval_str.endswith("s"):
                         scrape_intervals.append(int(interval_str[:-1]))
-            
-            avg_scrape_interval = statistics.mean(scrape_intervals) if scrape_intervals else 30
-            
+
+            avg_scrape_interval = (
+                statistics.mean(scrape_intervals) if scrape_intervals else 30
+            )
+
             # 檢查服務數量（影響資源使用）
             service_count = config_content.count("job_name:")
-            
+
             # 預估效能特性
             estimated_queries_per_second = service_count / avg_scrape_interval
-            estimated_data_points_per_hour = estimated_queries_per_second * 3600 * 50  # 假設每個查詢50個指標
-            
+            estimated_data_points_per_hour = (
+                estimated_queries_per_second * 3600 * 50
+            )  # 假設每個查詢50個指標
+
             metrics = {
                 "has_query_log": has_query_log,
                 "has_retention_config": has_retention_config,
@@ -311,77 +392,105 @@ class MonitoringPerformanceRefactoredTest:
                 "avg_scrape_interval_seconds": avg_scrape_interval,
                 "monitored_services": service_count,
                 "estimated_queries_per_second": estimated_queries_per_second,
-                "estimated_data_points_per_hour": estimated_data_points_per_hour
+                "estimated_data_points_per_hour": estimated_data_points_per_hour,
             }
-            
+
             # 配置優化驗證
             config_score = 0
             config_score += 1 if has_query_log else 0
             config_score += 1 if has_retention_config else 0
             config_score += 1 if has_compression else 0
             config_score += 1 if has_concurrency_config else 0
-            config_score += 1 if avg_scrape_interval <= 30 else 0  # 合理的抓取間隔
-            
+            config_score += (
+                1 if avg_scrape_interval <= 30 else 0
+            )  # 合理的抓取間隔
+
             metrics["optimization_score"] = config_score
             metrics["optimization_percentage"] = (config_score / 5) * 100
-            
+
             # 要求至少60%的優化配置
-            assert config_score >= 3, f"配置優化分數 {config_score}/5 過低，需要更多優化"
-            
-            self._record_result("monitoring_configuration_optimization", True, metrics=metrics)
-            
+            assert config_score >= 3, (
+                f"配置優化分數 {config_score}/5 過低，需要更多優化"
+            )
+
+            self._record_result(
+                "monitoring_configuration_optimization", True, metrics=metrics
+            )
+
         except Exception as e:
-            self._record_result("monitoring_configuration_optimization", False, str(e))
+            self._record_result(
+                "monitoring_configuration_optimization", False, str(e)
+            )
 
     def test_dashboard_query_performance_optimization(self):
         """測試儀表板查詢效能優化"""
         try:
             # 檢查儀表板配置
-            dashboards_dir = self.project_root / "monitoring/grafana/dashboards"
+            dashboards_dir = (
+                self.project_root / "monitoring/grafana/dashboards"
+            )
             assert dashboards_dir.exists(), "Grafana 儀表板目錄不存在"
-            
+
             dashboard_files = list(dashboards_dir.glob("*.json"))
             assert len(dashboard_files) > 0, "沒有找到儀表板配置檔案"
-            
+
             total_queries = 0
             total_panels = 0
             complex_queries = 0
             dashboard_performance_scores = {}
-            
+
             for dashboard_file in dashboard_files:
-                with open(dashboard_file, 'r') as f:
+                with open(dashboard_file, "r") as f:
                     dashboard_config = json.load(f)
-                
+
                 dashboard_name = dashboard_file.stem
-                panels = dashboard_config.get('dashboard', {}).get('panels', [])
-                
+                panels = dashboard_config.get("dashboard", {}).get(
+                    "panels", []
+                )
+
                 panel_count = len(panels)
                 query_count = 0
                 complex_query_count = 0
-                
+
                 for panel in panels:
-                    targets = panel.get('targets', [])
+                    targets = panel.get("targets", [])
                     query_count += len(targets)
-                    
+
                     for target in targets:
-                        expr = target.get('expr', '')
-                        
+                        expr = target.get("expr", "")
+
                         # 分析查詢複雜度
                         complexity_indicators = [
-                            'rate(', 'increase(', 'histogram_quantile(',
-                            'avg_over_time(', 'max_over_time(', 'min_over_time(',
-                            'by(', 'group_left', 'group_right',
-                            'join', 'on(', 'ignoring('
+                            "rate(",
+                            "increase(",
+                            "histogram_quantile(",
+                            "avg_over_time(",
+                            "max_over_time(",
+                            "min_over_time(",
+                            "by(",
+                            "group_left",
+                            "group_right",
+                            "join",
+                            "on(",
+                            "ignoring(",
                         ]
-                        
-                        complexity_score = sum(1 for indicator in complexity_indicators if indicator in expr)
+
+                        complexity_score = sum(
+                            1
+                            for indicator in complexity_indicators
+                            if indicator in expr
+                        )
                         if complexity_score >= 2:
                             complex_query_count += 1
-                
+
                 # 計算儀表板效能分數
-                queries_per_panel = query_count / panel_count if panel_count > 0 else 0
-                complexity_ratio = complex_query_count / query_count if query_count > 0 else 0
-                
+                queries_per_panel = (
+                    query_count / panel_count if panel_count > 0 else 0
+                )
+                complexity_ratio = (
+                    complex_query_count / query_count if query_count > 0 else 0
+                )
+
                 # 效能分數 (0-100)
                 performance_score = 100
                 if queries_per_panel > 2:
@@ -390,29 +499,36 @@ class MonitoringPerformanceRefactoredTest:
                     performance_score -= (complexity_ratio - 0.5) * 40
                 if panel_count > 15:
                     performance_score -= (panel_count - 15) * 2
-                
+
                 performance_score = max(0, performance_score)
-                
+
                 dashboard_performance_scores[dashboard_name] = {
                     "panels": panel_count,
                     "queries": query_count,
                     "complex_queries": complex_query_count,
                     "queries_per_panel": queries_per_panel,
                     "complexity_ratio": complexity_ratio,
-                    "performance_score": performance_score
+                    "performance_score": performance_score,
                 }
-                
+
                 total_queries += query_count
                 total_panels += panel_count
                 complex_queries += complex_query_count
-            
+
             # 整體效能分析
             avg_queries_per_dashboard = total_queries / len(dashboard_files)
-            avg_panels_per_dashboard = total_panels / len(dashboard_files)  
-            overall_complexity_ratio = complex_queries / total_queries if total_queries > 0 else 0
-            
-            avg_performance_score = statistics.mean([d["performance_score"] for d in dashboard_performance_scores.values()])
-            
+            avg_panels_per_dashboard = total_panels / len(dashboard_files)
+            overall_complexity_ratio = (
+                complex_queries / total_queries if total_queries > 0 else 0
+            )
+
+            avg_performance_score = statistics.mean(
+                [
+                    d["performance_score"]
+                    for d in dashboard_performance_scores.values()
+                ]
+            )
+
             metrics = {
                 "total_dashboards": len(dashboard_files),
                 "total_queries": total_queries,
@@ -421,17 +537,27 @@ class MonitoringPerformanceRefactoredTest:
                 "avg_panels_per_dashboard": avg_panels_per_dashboard,
                 "overall_complexity_ratio": overall_complexity_ratio,
                 "avg_performance_score": avg_performance_score,
-                "dashboard_details": dashboard_performance_scores
+                "dashboard_details": dashboard_performance_scores,
             }
-            
+
             # 效能驗證
-            assert avg_performance_score >= 70, f"平均儀表板效能分數 {avg_performance_score:.1f} 過低，需要優化"
-            assert avg_queries_per_dashboard <= 15, f"平均每個儀表板查詢數 {avg_queries_per_dashboard:.1f} 過多"
-            
-            self._record_result("dashboard_query_performance_optimization", True, metrics=metrics)
-            
+            assert avg_performance_score >= 70, (
+                f"平均儀表板效能分數 {avg_performance_score:.1f} 過低，需要優化"
+            )
+            assert avg_queries_per_dashboard <= 15, (
+                f"平均每個儀表板查詢數 {avg_queries_per_dashboard:.1f} 過多"
+            )
+
+            self._record_result(
+                "dashboard_query_performance_optimization",
+                True,
+                metrics=metrics,
+            )
+
         except Exception as e:
-            self._record_result("dashboard_query_performance_optimization", False, str(e))
+            self._record_result(
+                "dashboard_query_performance_optimization", False, str(e)
+            )
 
     def test_alerting_performance_optimization(self):
         """測試警報效能優化"""
@@ -439,84 +565,103 @@ class MonitoringPerformanceRefactoredTest:
             # 檢查警報規則配置
             rules_dir = self.project_root / "monitoring/prometheus/rules"
             assert rules_dir.exists(), "警報規則目錄不存在"
-            
+
             rule_files = list(rules_dir.glob("*.yml"))
             assert len(rule_files) > 0, "沒有找到警報規則檔案"
-            
+
             total_rules = 0
             total_groups = 0
             complex_rules = 0
             rule_performance_metrics = {}
-            
+
             try:
                 import yaml
+
                 yaml_available = True
             except ImportError:
                 yaml_available = False
-            
+
             for rule_file in rule_files:
                 file_rules = 0
                 file_groups = 0
                 file_complex_rules = 0
-                
+
                 if yaml_available:
                     try:
-                        with open(rule_file, 'r') as f:
+                        with open(rule_file, "r") as f:
                             rules_config = yaml.safe_load(f)
-                        
-                        for group in rules_config.get('groups', []):
+
+                        for group in rules_config.get("groups", []):
                             file_groups += 1
-                            for rule in group.get('rules', []):
+                            for rule in group.get("rules", []):
                                 file_rules += 1
-                                expr = rule.get('expr', '')
-                                
+                                expr = rule.get("expr", "")
+
                                 # 分析規則複雜度
                                 complexity_score = 0
-                                complexity_score += expr.count('(') * 0.5
-                                complexity_score += expr.count('rate(') * 2
-                                complexity_score += expr.count('histogram_quantile(') * 3
-                                complexity_score += expr.count('by(') * 1
-                                complexity_score += expr.count('group_left') * 2
-                                complexity_score += expr.count('group_right') * 2
-                                
+                                complexity_score += expr.count("(") * 0.5
+                                complexity_score += expr.count("rate(") * 2
+                                complexity_score += (
+                                    expr.count("histogram_quantile(") * 3
+                                )
+                                complexity_score += expr.count("by(") * 1
+                                complexity_score += (
+                                    expr.count("group_left") * 2
+                                )
+                                complexity_score += (
+                                    expr.count("group_right") * 2
+                                )
+
                                 if complexity_score > 3:
                                     file_complex_rules += 1
                     except Exception as e:
                         logger.warning(f"無法解析 YAML 文件 {rule_file}: {e}")
                         # 使用文本分析作為備選方案
                         content = rule_file.read_text()
-                        file_rules = content.count('alert:')
-                        file_groups = content.count('name:')
-                        file_complex_rules = content.count('histogram_quantile')
+                        file_rules = content.count("alert:")
+                        file_groups = content.count("name:")
+                        file_complex_rules = content.count(
+                            "histogram_quantile"
+                        )
                 else:
                     # 簡單文本分析
                     content = rule_file.read_text()
-                    file_rules = content.count('alert:')
-                    file_groups = content.count('name:') 
-                    file_complex_rules = content.count('histogram_quantile') + content.count('rate(')
-                
+                    file_rules = content.count("alert:")
+                    file_groups = content.count("name:")
+                    file_complex_rules = content.count(
+                        "histogram_quantile"
+                    ) + content.count("rate(")
+
                 rule_performance_metrics[rule_file.stem] = {
                     "rules": file_rules,
                     "groups": file_groups,
                     "complex_rules": file_complex_rules,
-                    "complexity_ratio": file_complex_rules / file_rules if file_rules > 0 else 0
+                    "complexity_ratio": file_complex_rules / file_rules
+                    if file_rules > 0
+                    else 0,
                 }
-                
+
                 total_rules += file_rules
                 total_groups += file_groups
                 complex_rules += file_complex_rules
-            
+
             # 效能分析
-            avg_rules_per_file = total_rules / len(rule_files) if len(rule_files) > 0 else 0
-            avg_rules_per_group = total_rules / total_groups if total_groups > 0 else 0
-            complexity_ratio = complex_rules / total_rules if total_rules > 0 else 0
-            
+            avg_rules_per_file = (
+                total_rules / len(rule_files) if len(rule_files) > 0 else 0
+            )
+            avg_rules_per_group = (
+                total_rules / total_groups if total_groups > 0 else 0
+            )
+            complexity_ratio = (
+                complex_rules / total_rules if total_rules > 0 else 0
+            )
+
             # 預估警報評估效能
             base_eval_time_us = 5  # 基礎評估時間
             complexity_penalty = complexity_ratio * 20
             estimated_eval_time = base_eval_time_us + complexity_penalty
             estimated_total_eval_time = estimated_eval_time * total_rules
-            
+
             metrics = {
                 "total_rules": total_rules,
                 "total_groups": total_groups,
@@ -526,39 +671,57 @@ class MonitoringPerformanceRefactoredTest:
                 "complexity_ratio": complexity_ratio,
                 "estimated_eval_time_us": estimated_eval_time,
                 "estimated_total_eval_time_us": estimated_total_eval_time,
-                "rule_file_details": rule_performance_metrics
+                "rule_file_details": rule_performance_metrics,
             }
-            
+
             # 效能驗證
-            assert estimated_eval_time <= 50, f"預估警報評估時間 {estimated_eval_time:.1f}μs 過高"
-            assert avg_rules_per_group <= 10, f"平均每組規則數 {avg_rules_per_group:.1f} 過多，建議拆分"
-            
-            self._record_result("alerting_performance_optimization", True, metrics=metrics)
-            
+            assert estimated_eval_time <= 50, (
+                f"預估警報評估時間 {estimated_eval_time:.1f}μs 過高"
+            )
+            assert avg_rules_per_group <= 10, (
+                f"平均每組規則數 {avg_rules_per_group:.1f} 過多，建議拆分"
+            )
+
+            self._record_result(
+                "alerting_performance_optimization", True, metrics=metrics
+            )
+
         except Exception as e:
-            self._record_result("alerting_performance_optimization", False, str(e))
+            self._record_result(
+                "alerting_performance_optimization", False, str(e)
+            )
 
     def print_results(self):
         """打印測試結果和效能分析"""
-        total_tests = self.results["tests_passed"] + self.results["tests_failed"]
-        success_rate = (self.results["tests_passed"] / total_tests * 100) if total_tests > 0 else 0
-        
+        total_tests = (
+            self.results["tests_passed"] + self.results["tests_failed"]
+        )
+        success_rate = (
+            (self.results["tests_passed"] / total_tests * 100)
+            if total_tests > 0
+            else 0
+        )
+
         logger.info("=" * 80)
-        logger.info("🔧 TDD Refactor 階段: 監控效能和可觀測性優化結果 (重構版)")
+        logger.info(
+            "🔧 TDD Refactor 階段: 監控效能和可觀測性優化結果 (重構版)"
+        )
         logger.info("=" * 80)
         logger.info(f"✅ 通過測試: {self.results['tests_passed']}")
         logger.info(f"❌ 失敗測試: {self.results['tests_failed']}")
         logger.info(f"📈 測試成功率: {success_rate:.1f}%")
-        
+
         if self.results["errors"]:
             logger.info("\n🎯 需要優化的項目:")
             for error in self.results["errors"]:
                 logger.info(f"  - {error}")
-        
+
         # 效能分析報告
         if self.results["performance_metrics"]:
             logger.info("\n📊 效能優化分析報告:")
-            for test_name, metrics in self.results["performance_metrics"].items():
+            for test_name, metrics in self.results[
+                "performance_metrics"
+            ].items():
                 logger.info(f"  📈 {test_name}:")
                 for metric_name, value in metrics.items():
                     if isinstance(value, (int, float)):
@@ -568,7 +731,10 @@ class MonitoringPerformanceRefactoredTest:
                             logger.info(f"    - {metric_name}: {value:.3f} ms")
                         elif metric_name.endswith("_seconds"):
                             logger.info(f"    - {metric_name}: {value:.1f} s")
-                        elif "percentage" in metric_name or "ratio" in metric_name:
+                        elif (
+                            "percentage" in metric_name
+                            or "ratio" in metric_name
+                        ):
                             logger.info(f"    - {metric_name}: {value:.1f}%")
                         elif "per_second" in metric_name:
                             logger.info(f"    - {metric_name}: {value:.0f} /s")
@@ -578,33 +744,39 @@ class MonitoringPerformanceRefactoredTest:
                         logger.info(f"    - {metric_name}: {value}")
                     elif not isinstance(value, dict):
                         logger.info(f"    - {metric_name}: {value}")
-        
+
         # 總體效能評估
         logger.info("\n🎯 效能優化摘要:")
-        
+
         performance_summary = {}
         for test_name, metrics in self.results["performance_metrics"].items():
             if "avg_" in str(metrics):
                 for key, value in metrics.items():
                     if "avg_" in key and isinstance(value, (int, float)):
                         performance_summary[f"{test_name}_{key}"] = value
-        
+
         if performance_summary:
             logger.info("  主要效能指標:")
             for metric, value in performance_summary.items():
                 logger.info(f"    - {metric}: {value:.3f}")
-        
+
         # Refactor 階段評估
         if success_rate >= 90:
-            logger.info("\n🟢 TDD Refactor 階段狀態: 優秀 - 效能和可觀測性優化成功")
+            logger.info(
+                "\n🟢 TDD Refactor 階段狀態: 優秀 - 效能和可觀測性優化成功"
+            )
             logger.info("✨ 監控系統已達到生產級效能標準")
         elif success_rate >= 70:
-            logger.info("\n🟡 TDD Refactor 階段狀態: 良好 - 大部分優化成功，少數需調整")
+            logger.info(
+                "\n🟡 TDD Refactor 階段狀態: 良好 - 大部分優化成功，少數需調整"
+            )
             logger.info("🔧 建議進一步調整未達標的效能指標")
         else:
-            logger.info("\n🔴 TDD Refactor 階段狀態: 需改進 - 多數效能指標需要優化")
+            logger.info(
+                "\n🔴 TDD Refactor 階段狀態: 需改進 - 多數效能指標需要優化"
+            )
             logger.info("📊 請根據詳細分析報告進行系統性優化")
-        
+
         return success_rate >= 70
 
 
@@ -613,9 +785,9 @@ def main():
     logger.info("🔧 開始 TDD Refactor 階段: 監控效能和可觀測性優化 (重構版)")
     logger.info("目標: 優化監控系統效能並增強可觀測性功能")
     logger.info("=" * 80)
-    
+
     test_suite = MonitoringPerformanceRefactoredTest()
-    
+
     try:
         # 執行所有優化測試
         test_suite.test_optimized_logging_performance()
@@ -624,10 +796,10 @@ def main():
         test_suite.test_monitoring_configuration_optimization()
         test_suite.test_dashboard_query_performance_optimization()
         test_suite.test_alerting_performance_optimization()
-        
+
         # 打印結果和分析
         is_successful = test_suite.print_results()
-        
+
         if is_successful:
             logger.info("\n🎉 TDD Refactor 階段成功！")
             logger.info("✨ 監控系統效能和可觀測性優化完成")
@@ -636,22 +808,23 @@ def main():
         else:
             logger.info("\n🔧 TDD Refactor 階段需要進一步優化")
             logger.info("📊 請根據效能分析報告進行針對性調整")
-        
+
         return is_successful
-        
+
     except Exception as e:
         logger.error(f"❌ Refactor 階段測試執行異常: {e}")
         import traceback
+
         traceback.print_exc()
         return False
 
 
 if __name__ == "__main__":
     success = main()
-    
+
     if success:
         logger.info("🏁 TDD Refactor 階段完成 - 監控效能優化成功")
         exit(0)
     else:
         logger.error("🛑 TDD Refactor 階段需要改進")
-        exit(1)
\ No newline at end of file
+        exit(1)
diff --git a/auto_generate_video_fold6/test_refactor_validation.py b/auto_generate_video_fold6/test_refactor_validation.py
index f0a2ecb..28bd56e 100644
--- a/auto_generate_video_fold6/test_refactor_validation.py
+++ b/auto_generate_video_fold6/test_refactor_validation.py
@@ -16,176 +16,199 @@ import logging
 sys.path.insert(0, str(Path(__file__).parent / "services" / "common"))
 
 from base_service import (
-    BaseService, ServiceState, ServiceError, MetricsCollector, 
-    StructuredLogger, TraceContext, trace_span
+    BaseService,
+    ServiceState,
+    ServiceError,
+    MetricsCollector,
+    StructuredLogger,
+    TraceContext,
+    trace_span,
 )
 from workflow_engine_refactored import (
-    WorkflowEngine, WorkflowTemplate, WorkflowStep, WorkflowContext,
-    WorkflowState, StepState, StepResult
+    WorkflowEngine,
+    WorkflowTemplate,
+    WorkflowStep,
+    WorkflowContext,
+    WorkflowState,
+    StepState,
+    StepResult,
 )
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
+
 class MockService(BaseService):
     """測試用模擬服務"""
-    
+
     def __init__(self, config: Dict[str, Any] = None):
         super().__init__("mock_service", "1.0.0", config)
         self.initialized = False
         self.started = False
-    
+
     async def _initialize(self):
         await asyncio.sleep(0.1)  # 模擬初始化延遲
         self.initialized = True
-    
+
     async def _startup(self):
         await asyncio.sleep(0.1)  # 模擬啟動延遲
         self.started = True
-    
+
     async def _shutdown(self):
         await asyncio.sleep(0.1)  # 模擬關閉延遲
         self.started = False
 
+
 class MockWorkflowStep(WorkflowStep):
     """測試用工作流程步驟"""
-    
-    def __init__(self, step_name: str, delay: float = 0.1, should_fail: bool = False, **kwargs):
+
+    def __init__(
+        self,
+        step_name: str,
+        delay: float = 0.1,
+        should_fail: bool = False,
+        **kwargs,
+    ):
         super().__init__(step_name, **kwargs)
         self.delay = delay
         self.should_fail = should_fail
         self.execution_count = 0
-    
+
     async def _execute_step(self, context: WorkflowContext) -> Dict[str, Any]:
         self.execution_count += 1
         await asyncio.sleep(self.delay)
-        
+
         if self.should_fail:
             raise Exception(f"Mock step {self.step_name} failed")
-        
+
         return {
             "step_name": self.step_name,
             "execution_count": self.execution_count,
-            "timestamp": time.time()
+            "timestamp": time.time(),
         }
 
+
 class RefactorValidationTest:
     """重構驗證測試套件"""
-    
+
     def __init__(self):
-        self.results = {
-            "tests_passed": 0,
-            "tests_failed": 0,
-            "errors": []
-        }
-    
+        self.results = {"tests_passed": 0, "tests_failed": 0, "errors": []}
+
     def _record_result(self, test_name: str, success: bool, error: str = None):
         """記錄測試結果"""
         if success:
             self.results["tests_passed"] += 1
             logger.info(f"✅ {test_name} 通過")
         else:
-            self.results["tests_failed"] += 1 
+            self.results["tests_failed"] += 1
             self.results["errors"].append(f"{test_name}: {error}")
             logger.error(f"❌ {test_name} 失敗: {error}")
-    
+
     async def test_base_service_lifecycle(self):
         """測試基礎服務生命週期"""
         try:
             service = MockService({"test_config": "value"})
-            
+
             # 測試初始狀態
             assert service.state == ServiceState.INITIALIZING
             assert not service.initialized
             assert not service.started
-            
+
             # 測試啟動
             await service.start()
             assert service.state == ServiceState.HEALTHY
             assert service.initialized
             assert service.started
-            
+
             # 測試健康檢查
             health = await service.health_check()
             assert health.status == ServiceState.HEALTHY
-            
+
             # 測試停止
             await service.stop()
             assert service.state == ServiceState.STOPPED
             assert not service.started
-            
+
             self._record_result("base_service_lifecycle", True)
-            
+
         except Exception as e:
             self._record_result("base_service_lifecycle", False, str(e))
-    
+
     async def test_base_service_context_manager(self):
         """測試基礎服務上下文管理器"""
         try:
             async with MockService() as service:
                 assert service.state == ServiceState.HEALTHY
                 assert service.started
-            
+
             # 服務應該自動停止
             assert service.state == ServiceState.STOPPED
-            
+
             self._record_result("base_service_context_manager", True)
-            
+
         except Exception as e:
             self._record_result("base_service_context_manager", False, str(e))
-    
+
     async def test_metrics_collection(self):
         """測試指標收集"""
         try:
             metrics = MetricsCollector()
-            
+
             # 測試計數器
             await metrics.increment_counter("test_counter", {"type": "test"})
-            await metrics.increment_counter("test_counter", {"type": "test"}, 2)
-            
+            await metrics.increment_counter(
+                "test_counter", {"type": "test"}, 2
+            )
+
             # 測試量表
             await metrics.set_gauge("test_gauge", 42.5, {"unit": "percent"})
-            
+
             # 測試直方圖
             await metrics.record_histogram("test_histogram", 1.5)
             await metrics.record_histogram("test_histogram", 2.5)
             await metrics.record_histogram("test_histogram", 3.5)
-            
+
             # 獲取指標
             all_metrics = await metrics.get_metrics()
             assert len(all_metrics) > 0
-            
+
             # 驗證指標類型
-            counter_metrics = [m for m in all_metrics if "counter" in m["name"] or "_total" in m["name"]]
+            counter_metrics = [
+                m
+                for m in all_metrics
+                if "counter" in m["name"] or "_total" in m["name"]
+            ]
             gauge_metrics = [m for m in all_metrics if "gauge" in m["name"]]
-            histogram_metrics = [m for m in all_metrics if "histogram" in m["name"]]
-            
+            histogram_metrics = [
+                m for m in all_metrics if "histogram" in m["name"]
+            ]
+
             assert len(counter_metrics) > 0
-            assert len(gauge_metrics) > 0  
+            assert len(gauge_metrics) > 0
             assert len(histogram_metrics) > 0
-            
+
             self._record_result("metrics_collection", True)
-            
+
         except Exception as e:
             self._record_result("metrics_collection", False, str(e))
-    
+
     async def test_structured_logging(self):
         """測試結構化日誌"""
         try:
             logger = StructuredLogger("test_service", "1.0.0")
-            
+
             # 測試不同級別的日誌
             logger.info("Test info message", extra_field="value")
             logger.error("Test error message", error_code="TEST_ERROR")
             logger.warning("Test warning message", warning_type="validation")
             logger.debug("Test debug message", debug_info={"key": "value"})
-            
+
             # 如果沒有異常，認為成功
             self._record_result("structured_logging", True)
-            
+
         except Exception as e:
             self._record_result("structured_logging", False, str(e))
-    
+
     async def test_trace_context(self):
         """測試分散式追蹤"""
         try:
@@ -193,226 +216,240 @@ class RefactorValidationTest:
             trace = TraceContext()
             assert trace.trace_id is not None
             assert trace.span_id is not None
-            
+
             # 添加標籤和日誌
             trace.add_tag("operation", "test")
             trace.log("Test log message")
-            
+
             # 測試追蹤 span
             logger = StructuredLogger("test", "1.0.0")
             async with trace_span("test_operation", trace, logger) as span:
                 span.add_tag("test_tag", "test_value")
                 span.log("Operation started")
                 await asyncio.sleep(0.1)
-            
+
             # 驗證 span 數據
             span_data = span.to_dict()
             assert "trace_id" in span_data
             assert "span_id" in span_data
             assert "tags" in span_data
             assert "logs" in span_data
-            
+
             self._record_result("trace_context", True)
-            
+
         except Exception as e:
             self._record_result("trace_context", False, str(e))
-    
+
     async def test_workflow_engine_basic(self):
         """測試工作流程引擎基本功能"""
         try:
             engine = WorkflowEngine()
-            
+
             # 啟動引擎
             await engine.start()
             assert engine.state == ServiceState.HEALTHY
-            
+
             # 創建簡單工作流程範本
             step1 = MockWorkflowStep("step1", delay=0.1)
             step2 = MockWorkflowStep("step2", delay=0.1)
             step1.next_step = step2
-            
+
             template = WorkflowTemplate(
                 name="test_workflow",
                 description="Test workflow template",
                 first_step=step1,
-                timeout=10.0
+                timeout=10.0,
             )
-            
+
             # 註冊範本
             engine.register_workflow_template(template)
-            
+
             # 啟動工作流程
             workflow_id = await engine.start_workflow(
-                "test_workflow",
-                "test_user",
-                {"test_input": "value"}
+                "test_workflow", "test_user", {"test_input": "value"}
             )
-            
+
             assert workflow_id is not None
-            
+
             # 等待工作流程完成
             await asyncio.sleep(1.0)
-            
+
             # 檢查狀態
             status = await engine.get_workflow_status(workflow_id)
             if status:  # 可能已經完成並清理
-                assert status["state"] in [WorkflowState.COMPLETED.value, WorkflowState.RUNNING.value]
-            
+                assert status["state"] in [
+                    WorkflowState.COMPLETED.value,
+                    WorkflowState.RUNNING.value,
+                ]
+
             # 獲取引擎統計
             stats = await engine.get_engine_stats()
             assert stats["stats"]["total_workflows"] >= 1
-            
+
             await engine.stop()
-            
+
             self._record_result("workflow_engine_basic", True)
-            
+
         except Exception as e:
             self._record_result("workflow_engine_basic", False, str(e))
-    
+
     async def test_workflow_step_chain(self):
         """測試工作流程步驟鏈"""
         try:
             # 創建步驟鏈
             step1 = MockWorkflowStep("step1", delay=0.05)
-            step2 = MockWorkflowStep("step2", delay=0.05, required_steps=["step1"])
-            step3 = MockWorkflowStep("step3", delay=0.05, required_steps=["step2"])
-            
+            step2 = MockWorkflowStep(
+                "step2", delay=0.05, required_steps=["step1"]
+            )
+            step3 = MockWorkflowStep(
+                "step3", delay=0.05, required_steps=["step2"]
+            )
+
             step1.next_step = step2
             step2.next_step = step3
-            
+
             # 創建執行上下文
             context = WorkflowContext(
                 workflow_id="test_workflow",
                 user_id="test_user",
-                input_data={"test": "data"}
+                input_data={"test": "data"},
             )
-            
+
             # 執行步驟鏈
             result_context = await step1.process(context)
-            
+
             # 驗證所有步驟都執行了
             assert "step1" in result_context.step_results
             assert "step2" in result_context.step_results
             assert "step3" in result_context.step_results
-            
+
             # 驗證步驟狀態
             for step_name in ["step1", "step2", "step3"]:
                 result = result_context.step_results[step_name]
                 assert result.state == StepState.COMPLETED
                 assert result.duration is not None
                 assert result.duration > 0
-            
+
             # 驗證步驟執行順序
             step1_time = result_context.step_results["step1"].start_time
-            step2_time = result_context.step_results["step2"].start_time  
+            step2_time = result_context.step_results["step2"].start_time
             step3_time = result_context.step_results["step3"].start_time
-            
+
             assert step1_time < step2_time < step3_time
-            
+
             self._record_result("workflow_step_chain", True)
-            
+
         except Exception as e:
             self._record_result("workflow_step_chain", False, str(e))
-    
+
     async def test_workflow_error_handling(self):
         """測試工作流程錯誤處理"""
         try:
             # 創建會失敗的步驟
             failing_step = MockWorkflowStep("failing_step", should_fail=True)
-            
+
             context = WorkflowContext(
                 workflow_id="test_error_workflow",
-                user_id="test_user", 
-                input_data={}
+                user_id="test_user",
+                input_data={},
             )
-            
+
             # 執行應該失敗的步驟
             result = await failing_step.execute(context)
-            
+
             # 驗證失敗狀態
             assert result.state == StepState.FAILED
             assert result.error is not None
             assert "failed" in result.error
-            
+
             self._record_result("workflow_error_handling", True)
-            
+
         except Exception as e:
             self._record_result("workflow_error_handling", False, str(e))
-    
+
     async def test_workflow_prerequisites(self):
         """測試工作流程前置條件"""
         try:
             # 創建有前置條件的步驟
-            step_with_prereq = MockWorkflowStep("step_with_prereq", 
-                                              required_steps=["missing_step"])
-            
+            step_with_prereq = MockWorkflowStep(
+                "step_with_prereq", required_steps=["missing_step"]
+            )
+
             context = WorkflowContext(
                 workflow_id="test_prereq_workflow",
                 user_id="test_user",
-                input_data={}
+                input_data={},
             )
-            
+
             # 執行應該被跳過的步驟
             result = await step_with_prereq.execute(context)
-            
+
             # 驗證跳過狀態
             assert result.state == StepState.SKIPPED
             assert "Prerequisites not met" in result.error
-            
+
             self._record_result("workflow_prerequisites", True)
-            
+
         except Exception as e:
             self._record_result("workflow_prerequisites", False, str(e))
-    
+
     async def test_performance_metrics(self):
         """測試效能指標"""
         try:
             start_time = time.time()
-            
+
             # 創建服務並執行操作
             async with MockService() as service:
                 # 記錄一些指標
-                await service.metrics.increment_counter("operations", {"type": "test"})
+                await service.metrics.increment_counter(
+                    "operations", {"type": "test"}
+                )
                 await service.metrics.set_gauge("cpu_usage", 45.2)
                 await service.metrics.record_histogram("response_time", 0.123)
-                
+
                 # 執行追蹤操作
                 async with service.trace_operation("performance_test") as span:
                     await asyncio.sleep(0.1)
                     span.add_tag("test_metric", "value")
-            
+
             end_time = time.time()
             execution_time = end_time - start_time
-            
+
             # 驗證執行時間合理（應該小於1秒）
             assert execution_time < 1.0
-            
+
             # 獲取指標
             metrics = await service.metrics.get_metrics()
             assert len(metrics) > 0
-            
+
             self._record_result("performance_metrics", True)
-            
+
         except Exception as e:
             self._record_result("performance_metrics", False, str(e))
-    
+
     def print_results(self):
         """打印測試結果"""
-        total_tests = self.results["tests_passed"] + self.results["tests_failed"]
-        success_rate = (self.results["tests_passed"] / total_tests * 100) if total_tests > 0 else 0
-        
+        total_tests = (
+            self.results["tests_passed"] + self.results["tests_failed"]
+        )
+        success_rate = (
+            (self.results["tests_passed"] / total_tests * 100)
+            if total_tests > 0
+            else 0
+        )
+
         logger.info("=" * 60)
         logger.info("🔍 TDD Refactor 驗證測試結果")
         logger.info("=" * 60)
         logger.info(f"✅ 通過測試: {self.results['tests_passed']}")
         logger.info(f"❌ 失敗測試: {self.results['tests_failed']}")
         logger.info(f"📈 成功率: {success_rate:.1f}%")
-        
+
         if self.results["errors"]:
             logger.info("\n🚨 失敗測試詳情:")
             for error in self.results["errors"]:
                 logger.info(f"  - {error}")
-        
+
         # 重構品質評估
         if success_rate >= 95:
             logger.info("\n🏆 重構品質: 優秀 - 所有功能完整保留並增強")
@@ -422,17 +459,18 @@ class RefactorValidationTest:
             logger.info("\n⚠️ 重構品質: 一般 - 存在一些問題需要修復")
         else:
             logger.info("\n❌ 重構品質: 不佳 - 存在重大問題，需要重新檢視")
-        
+
         return success_rate >= 85  # 85% 以上算通過
 
+
 async def main():
     """執行重構驗證測試"""
     logger.info("🚀 開始 TDD Refactor 階段驗證測試")
     logger.info("目標: 確保重構後系統功能完整且品質提升")
     logger.info("=" * 60)
-    
+
     test_suite = RefactorValidationTest()
-    
+
     try:
         # 執行所有測試
         await test_suite.test_base_service_lifecycle()
@@ -445,10 +483,10 @@ async def main():
         await test_suite.test_workflow_error_handling()
         await test_suite.test_workflow_prerequisites()
         await test_suite.test_performance_metrics()
-        
+
         # 打印結果
         success = test_suite.print_results()
-        
+
         if success:
             logger.info("\n🎉 TDD Refactor 階段驗證成功！")
             logger.info("✨ 系統架構已優化，品質顯著提升")
@@ -456,19 +494,20 @@ async def main():
         else:
             logger.error("\n💥 TDD Refactor 階段驗證失敗！")
             logger.error("🔧 需要修復問題後重新驗證")
-        
+
         return success
-        
+
     except Exception as e:
         logger.error(f"❌ 驗證測試執行異常: {e}")
         return False
 
+
 if __name__ == "__main__":
     success = asyncio.run(main())
-    
+
     if success:
         logger.info("🏁 TDD Refactor 階段完成 - 系統重構成功")
         sys.exit(0)
     else:
         logger.error("🛑 TDD Refactor 階段失敗 - 需要修復問題")
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/auto_generate_video_fold6/tests/conftest.py b/auto_generate_video_fold6/tests/conftest.py
index a84b875..e687c9e 100644
--- a/auto_generate_video_fold6/tests/conftest.py
+++ b/auto_generate_video_fold6/tests/conftest.py
@@ -75,11 +75,23 @@ def mock_config_manager():
                     "batch_size": 2,
                     "platforms": ["tiktok", "instagram"],
                 },
-                "cost_control": {"daily_budget_usd": 10.0, "stop_on_budget_exceeded": True},
+                "cost_control": {
+                    "daily_budget_usd": 10.0,
+                    "stop_on_budget_exceeded": True,
+                },
                 "ai_services": {
-                    "text_generation": {"provider": "openai", "model": "gpt-3.5-turbo"},
-                    "image_generation": {"provider": "stability", "model": "stable-diffusion-xl"},
-                    "voice_synthesis": {"provider": "elevenlabs", "voice_id": "test-voice"},
+                    "text_generation": {
+                        "provider": "openai",
+                        "model": "gpt-3.5-turbo",
+                    },
+                    "image_generation": {
+                        "provider": "stability",
+                        "model": "stable-diffusion-xl",
+                    },
+                    "voice_synthesis": {
+                        "provider": "elevenlabs",
+                        "voice_id": "test-voice",
+                    },
                 },
             }
 
@@ -114,7 +126,9 @@ def mock_cost_tracker():
             self.total_cost = 0.0
             self.calls = []
 
-        async def track_api_call(self, provider, model, operation_type, **kwargs):
+        async def track_api_call(
+            self, provider, model, operation_type, **kwargs
+        ):
             cost = 0.1  # 固定測試成本
             self.total_cost += cost
             self.calls.append(
@@ -189,8 +203,12 @@ def mock_openai_client():
             self.chat.completions = MagicMock()
             self.chat.completions.create = AsyncMock(
                 return_value=MagicMock(
-                    choices=[MagicMock(message=MagicMock(content="測試生成的內容"))],
-                    usage=MagicMock(prompt_tokens=10, completion_tokens=20, total_tokens=30),
+                    choices=[
+                        MagicMock(message=MagicMock(content="測試生成的內容"))
+                    ],
+                    usage=MagicMock(
+                        prompt_tokens=10, completion_tokens=20, total_tokens=30
+                    ),
                 )
             )
 
@@ -205,7 +223,11 @@ def sample_video_data():
         "description": "這是一個測試影片的描述",
         "script": "這是測試影片腳本內容",
         "platforms": ["tiktok", "instagram"],
-        "style": {"theme": "technology", "tone": "professional", "duration": 60},
+        "style": {
+            "theme": "technology",
+            "tone": "professional",
+            "duration": 60,
+        },
         "generated_content": {
             "images": ["image1.jpg", "image2.jpg"],
             "audio": "audio.mp3",
@@ -272,10 +294,14 @@ def mock_http_client():
             self.responses[url] = MockResponse(response_data, status_code)
 
         async def get(self, url, **kwargs):
-            return self.responses.get(url, MockResponse({"error": "Not mocked"}, 404))
+            return self.responses.get(
+                url, MockResponse({"error": "Not mocked"}, 404)
+            )
 
         async def post(self, url, **kwargs):
-            return self.responses.get(url, MockResponse({"success": True}, 200))
+            return self.responses.get(
+                url, MockResponse({"success": True}, 200)
+            )
 
         async def __aenter__(self):
             return self
@@ -346,5 +372,15 @@ def pytest_collection_modifyitems(config, items):
 
 def pytest_addoption(parser):
     """添加命令行選項"""
-    parser.addoption("--runslow", action="store_true", default=False, help="執行標記為 slow 的測試")
-    parser.addoption("--runintegration", action="store_true", default=False, help="執行整合測試")
+    parser.addoption(
+        "--runslow",
+        action="store_true",
+        default=False,
+        help="執行標記為 slow 的測試",
+    )
+    parser.addoption(
+        "--runintegration",
+        action="store_true",
+        default=False,
+        help="執行整合測試",
+    )
diff --git a/auto_generate_video_fold6/tests/factories/__init__.py b/auto_generate_video_fold6/tests/factories/__init__.py
index 3a51679..e2263b9 100644
--- a/auto_generate_video_fold6/tests/factories/__init__.py
+++ b/auto_generate_video_fold6/tests/factories/__init__.py
@@ -8,14 +8,14 @@ from .script_factory import ScriptFactory, CreateScriptFactory
 from .voice_factory import VoiceCloneFactory, CreateVoiceCloneFactory
 
 __all__ = [
-    'UserFactory',
-    'CreateUserFactory',
-    'ProjectFactory', 
-    'CreateProjectFactory',
-    'VideoFactory',
-    'CreateVideoFactory',
-    'ScriptFactory',
-    'CreateScriptFactory',
-    'VoiceCloneFactory',
-    'CreateVoiceCloneFactory',
-]
\ No newline at end of file
+    "UserFactory",
+    "CreateUserFactory",
+    "ProjectFactory",
+    "CreateProjectFactory",
+    "VideoFactory",
+    "CreateVideoFactory",
+    "ScriptFactory",
+    "CreateScriptFactory",
+    "VoiceCloneFactory",
+    "CreateVoiceCloneFactory",
+]
diff --git a/auto_generate_video_fold6/tests/factories/base_factory.py b/auto_generate_video_fold6/tests/factories/base_factory.py
index 15a859d..609fc3d 100644
--- a/auto_generate_video_fold6/tests/factories/base_factory.py
+++ b/auto_generate_video_fold6/tests/factories/base_factory.py
@@ -8,37 +8,39 @@ import uuid
 import factory
 from faker import Faker
 
-fake = Faker(['zh_TW', 'en_US'])  # 支援繁體中文和英文
+fake = Faker(["zh_TW", "en_US"])  # 支援繁體中文和英文
+
+T = TypeVar("T")
 
-T = TypeVar('T')
 
 class BaseFactory(ABC, Generic[T]):
     """
     基礎工廠抽象類別
     為所有測試數據工廠提供統一接口
     """
-    
+
     @abstractmethod
     def create(self, **kwargs) -> T:
         """建立一個測試實例"""
         pass
-    
+
     @abstractmethod
     def build(self, **kwargs) -> T:
         """建構但不保存的測試實例（用於單元測試）"""
         pass
-    
+
     @abstractmethod
     def create_batch(self, size: int, **kwargs) -> list[T]:
         """建立多個測試實例"""
         pass
 
+
 class TDDFactoryMixin:
     """
     TDD 工廠混合類別
     提供 TDD 特定的工廠方法
     """
-    
+
     @classmethod
     def create_for_red_phase(cls, **kwargs):
         """
@@ -46,15 +48,15 @@ class TDDFactoryMixin:
         例如：無效的輸入、邊界條件等
         """
         return cls.create(**kwargs)
-    
+
     @classmethod
     def create_for_green_phase(cls, **kwargs):
         """
         GREEN 階段：建立讓測試通過的最簡數據
         """
         return cls.create(**kwargs)
-    
-    @classmethod 
+
+    @classmethod
     def create_for_refactor_phase(cls, **kwargs):
         """
         REFACTOR 階段：建立測試重構的數據
@@ -62,51 +64,56 @@ class TDDFactoryMixin:
         """
         return cls.create(**kwargs)
 
+
 class CommonFieldsMixin:
     """提供常用欄位的混合類別"""
-    
+
     id = factory.LazyFunction(lambda: str(uuid.uuid4()))
     created_at = factory.LazyFunction(lambda: datetime.now(timezone.utc))
     updated_at = factory.LazyFunction(lambda: datetime.now(timezone.utc))
-    
+
     @factory.lazy_attribute
     def name(self):
         return fake.name()
-    
+
     @factory.lazy_attribute
     def email(self):
         return fake.unique.email()
-    
+
     @factory.lazy_attribute
     def description(self):
         return fake.text(max_nb_chars=200)
 
+
 class FactoryRegistry:
     """
     工廠註冊器
     管理所有測試工廠的中央註冊表
     """
-    
+
     _factories: Dict[str, Any] = {}
-    
+
     @classmethod
     def register(cls, name: str, factory_class: Any):
         """註冊工廠"""
         cls._factories[name] = factory_class
-    
+
     @classmethod
     def get(cls, name: str) -> Optional[Any]:
         """獲取工廠"""
         return cls._factories.get(name)
-    
+
     @classmethod
     def list_all(cls) -> Dict[str, Any]:
         """列出所有工廠"""
         return cls._factories.copy()
 
+
 def register_factory(name: str):
     """裝飾器：自動註冊工廠"""
+
     def decorator(factory_class):
         FactoryRegistry.register(name, factory_class)
         return factory_class
-    return decorator
\ No newline at end of file
+
+    return decorator
diff --git a/auto_generate_video_fold6/tests/factories/examples.py b/auto_generate_video_fold6/tests/factories/examples.py
index 93c4eeb..eeaff1c 100644
--- a/auto_generate_video_fold6/tests/factories/examples.py
+++ b/auto_generate_video_fold6/tests/factories/examples.py
@@ -8,255 +8,267 @@ from .video_factory import VideoFactory, create_test_videos_scenario
 from .script_factory import ScriptFactory, create_test_scripts_scenario
 from .voice_factory import VoiceCloneFactory, create_test_voices_scenario
 
+
 # TDD 範例 1: RED 階段測試
 def example_red_phase_test():
     """
     RED 階段範例：撰寫會失敗的測試
     使用工廠建立無效數據來測試驗證邏輯
     """
-    
+
     # 建立無效用戶數據來測試驗證
     invalid_user = UserFactory.create_for_red_phase()
-    
+
     # 這些數據應該導致測試失敗
     assert invalid_user.email == "invalid-email"  # 無效 email 格式
     assert invalid_user.username == ""  # 空用戶名
-    
+
     print("RED 階段：建立了會導致測試失敗的無效數據")
 
+
 # TDD 範例 2: GREEN 階段測試
 def example_green_phase_test():
     """
     GREEN 階段範例：建立讓測試通過的最簡數據
     """
-    
+
     # 建立最簡有效數據
     valid_user = UserFactory.create_for_green_phase()
     valid_project = ProjectFactory.create_for_green_phase()
     valid_script = ScriptFactory.create_for_green_phase()
-    
+
     # 這些數據應該讓測試通過
     assert valid_user.username == "testuser"
     assert valid_user.email == "test@example.com"
     assert valid_project.title == "測試專案"
     assert valid_script.content == "這是一個測試腳本的內容。"
-    
+
     print("GREEN 階段：建立了讓測試通過的最簡數據")
 
+
 # TDD 範例 3: REFACTOR 階段測試
 def example_refactor_phase_test():
     """
     REFACTOR 階段範例：確保重構後行為不變
     """
-    
+
     # 建立穩定的測試數據確保重構不破壞功能
     user = UserFactory.create_for_refactor_phase()
     project = ProjectFactory.create_for_refactor_phase()
-    
+
     # 在重構前後，這些斷言應該保持相同結果
     assert user.is_active is True
-    assert project.status in ['draft', 'in_progress', 'completed']
-    
+    assert project.status in ["draft", "in_progress", "completed"]
+
     print("REFACTOR 階段：確保重構後測試仍然通過")
 
+
 # 複雜場景範例：完整用戶工作流程測試
 def example_complete_user_workflow():
     """
     複雜場景範例：模擬完整的用戶工作流程
     從用戶建立到專案完成的端到端測試
     """
-    
+
     # 1. 建立測試用戶
     user = UserFactory.create_premium_user()
-    
+
     # 2. 為用戶建立專案
     project = ProjectFactory.create_draft_project(user_id=user.id)
-    
+
     # 3. 為專案建立腳本
     script = ScriptFactory.create_educational_script(
-        project_id=project.id,
-        user_id=user.id
+        project_id=project.id, user_id=user.id
     )
-    
+
     # 4. 建立語音克隆
     voice = VoiceCloneFactory.create_ready_voice(user_id=user.id)
-    
+
     # 5. 生成影片
     video = VideoFactory.create_completed_video(project_id=project.id)
-    
+
     # 驗證完整工作流程
     assert user.is_premium is True
     assert project.user_id == user.id
     assert script.project_id == project.id
     assert voice.user_id == user.id
     assert video.project_id == project.id
-    
+
     print(f"完整工作流程測試：用戶 {user.username} 成功完成影片製作")
-    
+
     return {
-        'user': user,
-        'project': project,
-        'script': script,
-        'voice': voice,
-        'video': video
+        "user": user,
+        "project": project,
+        "script": script,
+        "voice": voice,
+        "video": video,
     }
 
+
 # 批次數據測試範例
 def example_batch_data_test():
     """
     批次數據測試範例：測試大量數據的處理
     """
-    
+
     # 建立測試用戶
     user = UserFactory.create()
-    
+
     # 批次建立專案
     projects = [
         ProjectFactory.create(user_id=user.id, title=f"批次專案 {i}")
         for i in range(5)
     ]
-    
+
     # 為每個專案建立影片
     videos = []
     for project in projects:
         video = VideoFactory.create_completed_video(project_id=project.id)
         videos.append(video)
-    
+
     # 驗證批次數據
     assert len(projects) == 5
     assert len(videos) == 5
     assert all(p.user_id == user.id for p in projects)
     assert all(v.project_id in [p.id for p in projects] for v in videos)
-    
-    print(f"批次數據測試：為用戶建立了 {len(projects)} 個專案和 {len(videos)} 個影片")
+
+    print(
+        f"批次數據測試：為用戶建立了 {len(projects)} 個專案和 {len(videos)} 個影片"
+    )
+
 
 # 邊界條件測試範例
 def example_edge_case_test():
     """
     邊界條件測試範例：測試極限情況
     """
-    
+
     # 建立最小有效數據
     minimal_user = UserFactory.create(
         username="a",  # 最短用戶名
         video_count=0,  # 最少影片數
-        follower_count=0  # 最少追蹤者
+        follower_count=0,  # 最少追蹤者
     )
-    
+
     # 建立最大有效數據
     maximal_user = UserFactory.create(
         username="a" * 50,  # 最長用戶名
         video_count=9999,  # 最多影片數
-        follower_count=999999  # 最多追蹤者
+        follower_count=999999,  # 最多追蹤者
     )
-    
+
     # 驗證邊界條件
     assert len(minimal_user.username) == 1
     assert len(maximal_user.username) == 50
     assert minimal_user.video_count == 0
     assert maximal_user.video_count == 9999
-    
+
     print("邊界條件測試：驗證了最小和最大有效值")
 
+
 # 工廠註冊表範例
 def example_factory_registry_usage():
     """
     工廠註冊表使用範例：動態取得工廠
     """
     from .base_factory import FactoryRegistry
-    
+
     # 列出所有註冊的工廠
     factories = FactoryRegistry.list_all()
     print(f"已註冊的工廠: {list(factories.keys())}")
-    
+
     # 動態取得工廠並建立數據
-    user_factory = FactoryRegistry.get('user')
+    user_factory = FactoryRegistry.get("user")
     if user_factory:
         user = user_factory.create()
         print(f"透過註冊表建立用戶: {user.username}")
 
+
 # 測試數據清理範例
 def example_test_cleanup():
     """
     測試數據清理範例：確保測試間的隔離
     """
-    
+
     # 建立測試場景
     users_scenario = create_test_users_scenario()
     projects_scenario = create_test_projects_scenario()
-    
+
     # 執行測試邏輯...
-    
+
     # 清理測試數據
     from .user_factory import cleanup_test_users
     from .project_factory import cleanup_test_projects
-    
+
     cleanup_test_users(users_scenario)
     cleanup_test_projects(projects_scenario)
-    
+
     print("測試數據已清理，確保測試隔離")
 
+
 # 效能測試數據範例
 def example_performance_test_data():
     """
     效能測試數據範例：建立大量數據進行效能測試
     """
-    
+
     import time
-    
+
     start_time = time.time()
-    
+
     # 快速建立大量測試數據
     users = [UserFactory.create() for _ in range(100)]
     projects = [ProjectFactory.create() for _ in range(500)]
     videos = [VideoFactory.create() for _ in range(1000)]
-    
+
     end_time = time.time()
-    
+
     print(f"效能測試：在 {end_time - start_time:.2f} 秒內建立了:")
     print(f"- {len(users)} 個用戶")
-    print(f"- {len(projects)} 個專案") 
+    print(f"- {len(projects)} 個專案")
     print(f"- {len(videos)} 個影片")
 
+
 # 主要範例執行函數
 def run_all_examples():
     """執行所有範例"""
-    
+
     print("🧬 TDD 測試數據工廠範例")
     print("=" * 50)
-    
+
     try:
         example_red_phase_test()
         print()
-        
+
         example_green_phase_test()
         print()
-        
+
         example_refactor_phase_test()
         print()
-        
+
         workflow_data = example_complete_user_workflow()
         print()
-        
+
         example_batch_data_test()
         print()
-        
+
         example_edge_case_test()
         print()
-        
+
         example_factory_registry_usage()
         print()
-        
+
         example_test_cleanup()
         print()
-        
+
         example_performance_test_data()
-        
+
         print("=" * 50)
         print("✅ 所有測試數據工廠範例執行完成！")
-        
+
     except Exception as e:
         print(f"❌ 範例執行失敗: {e}")
 
+
 if __name__ == "__main__":
-    run_all_examples()
\ No newline at end of file
+    run_all_examples()
diff --git a/auto_generate_video_fold6/tests/factories/project_factory.py b/auto_generate_video_fold6/tests/factories/project_factory.py
index fc3c8b7..0da8ac5 100644
--- a/auto_generate_video_fold6/tests/factories/project_factory.py
+++ b/auto_generate_video_fold6/tests/factories/project_factory.py
@@ -8,13 +8,14 @@ from typing import Dict, Any, List
 from enum import Enum
 
 from .base_factory import (
-    BaseFactory, 
-    TDDFactoryMixin, 
+    BaseFactory,
+    TDDFactoryMixin,
     CommonFieldsMixin,
-    register_factory
+    register_factory,
 )
 
-fake = Faker(['zh_TW', 'en_US'])
+fake = Faker(["zh_TW", "en_US"])
+
 
 class ProjectStatus(Enum):
     DRAFT = "draft"
@@ -23,67 +24,90 @@ class ProjectStatus(Enum):
     PUBLISHED = "published"
     ARCHIVED = "archived"
 
+
 class ProjectData:
     """專案數據類別"""
+
     def __init__(self, **kwargs):
         for key, value in kwargs.items():
             setattr(self, key, value)
 
-@register_factory('project')
+
+@register_factory("project")
 class ProjectFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
     """
     專案工廠
     為 TDD 測試提供各種專案數據情境
     """
-    
+
     class Meta:
         model = ProjectData
-    
+
     # 基本欄位
     title = factory.LazyAttribute(lambda o: fake.sentence(nb_words=4))
     description = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=300))
-    
+
     # 用戶關聯
     user_id = factory.LazyFunction(lambda: fake.uuid4())
-    
+
     # 專案設定
-    target_platform = factory.Iterator(['tiktok', 'instagram_reels', 'youtube_shorts'])
-    target_audience = factory.LazyAttribute(lambda o: fake.random_element([
-        '18-24歲年輕人', '25-34歲上班族', '35-44歲家長', '45歲以上'
-    ]))
-    content_style = factory.LazyAttribute(lambda o: fake.random_element([
-        'educational', 'entertainment', 'promotional', 'informational'
-    ]))
-    
+    target_platform = factory.Iterator(
+        ["tiktok", "instagram_reels", "youtube_shorts"]
+    )
+    target_audience = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            ["18-24歲年輕人", "25-34歲上班族", "35-44歲家長", "45歲以上"]
+        )
+    )
+    content_style = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            ["educational", "entertainment", "promotional", "informational"]
+        )
+    )
+
     # 狀態
-    status = factory.LazyAttribute(lambda o: fake.random_element([
-        ProjectStatus.DRAFT.value,
-        ProjectStatus.IN_PROGRESS.value,
-        ProjectStatus.COMPLETED.value
-    ]))
-    
+    status = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            [
+                ProjectStatus.DRAFT.value,
+                ProjectStatus.IN_PROGRESS.value,
+                ProjectStatus.COMPLETED.value,
+            ]
+        )
+    )
+
     # 內容設定
-    script_content = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=500))
-    voice_settings = factory.LazyAttribute(lambda o: {
-        'voice_id': fake.uuid4(),
-        'speed': fake.random.uniform(0.8, 1.2),
-        'pitch': fake.random.uniform(-0.2, 0.2),
-        'emotion': fake.random_element(['neutral', 'happy', 'sad', 'excited'])
-    })
-    
+    script_content = factory.LazyAttribute(
+        lambda o: fake.text(max_nb_chars=500)
+    )
+    voice_settings = factory.LazyAttribute(
+        lambda o: {
+            "voice_id": fake.uuid4(),
+            "speed": fake.random.uniform(0.8, 1.2),
+            "pitch": fake.random.uniform(-0.2, 0.2),
+            "emotion": fake.random_element(
+                ["neutral", "happy", "sad", "excited"]
+            ),
+        }
+    )
+
     # 視覺設定
-    visual_style = factory.LazyAttribute(lambda o: fake.random_element([
-        'modern', 'minimalist', 'colorful', 'dark', 'vintage'
-    ]))
-    background_music = factory.LazyAttribute(lambda o: fake.random_element([
-        'upbeat', 'relaxing', 'epic', 'acoustic', 'electronic'
-    ]))
-    
+    visual_style = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            ["modern", "minimalist", "colorful", "dark", "vintage"]
+        )
+    )
+    background_music = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            ["upbeat", "relaxing", "epic", "acoustic", "electronic"]
+        )
+    )
+
     # 統計數據
     view_count = factory.LazyFunction(lambda: fake.random_int(0, 10000))
     like_count = factory.LazyFunction(lambda: fake.random_int(0, 1000))
     share_count = factory.LazyFunction(lambda: fake.random_int(0, 100))
-    
+
     # 檔案路徑
     output_video_path = factory.LazyAttribute(
         lambda o: f"/videos/{o.id}/output.mp4"
@@ -91,7 +115,7 @@ class ProjectFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
     thumbnail_path = factory.LazyAttribute(
         lambda o: f"/thumbnails/{o.id}/thumb.jpg"
     )
-    
+
     # 時間設定
     duration_seconds = factory.LazyFunction(lambda: fake.random_int(15, 180))
     scheduled_publish_at = None
@@ -104,9 +128,9 @@ class ProjectFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             status=ProjectStatus.DRAFT.value,
             user_id=user_id or fake.uuid4(),
             published_at=None,
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_completed_project(cls, user_id: str = None, **kwargs):
         """建立已完成專案"""
@@ -114,9 +138,9 @@ class ProjectFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             status=ProjectStatus.COMPLETED.value,
             user_id=user_id or fake.uuid4(),
             output_video_path=f"/videos/{fake.uuid4()}/completed.mp4",
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_published_project(cls, user_id: str = None, **kwargs):
         """建立已發布專案"""
@@ -125,9 +149,9 @@ class ProjectFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             user_id=user_id or fake.uuid4(),
             published_at=datetime.now(timezone.utc),
             view_count=fake.random_int(100, 5000),
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_for_red_phase(cls, **kwargs):
         """RED 階段：建立會導致測試失敗的專案數據"""
@@ -135,9 +159,9 @@ class ProjectFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             title="",  # 無效：空標題
             user_id="",  # 無效：空用戶ID
             duration_seconds=-1,  # 無效：負數持續時間
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_for_green_phase(cls, **kwargs):
         """GREEN 階段：建立讓測試通過的最簡專案數據"""
@@ -145,88 +169,101 @@ class ProjectFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             title="測試專案",
             user_id=fake.uuid4(),
             status=ProjectStatus.DRAFT.value,
-            **kwargs
+            **kwargs,
         )
 
-@register_factory('create_project')
+
+@register_factory("create_project")
 class CreateProjectFactory(factory.Factory, TDDFactoryMixin):
     """
     建立專案請求數據工廠
     模擬 API 請求中的專案建立數據
     """
-    
+
     class Meta:
         model = dict
-    
+
     title = factory.LazyAttribute(lambda o: fake.sentence(nb_words=3))
     description = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=200))
-    target_platform = factory.Iterator(['tiktok', 'instagram_reels', 'youtube_shorts'])
-    content_style = factory.Iterator(['educational', 'entertainment', 'promotional'])
+    target_platform = factory.Iterator(
+        ["tiktok", "instagram_reels", "youtube_shorts"]
+    )
+    content_style = factory.Iterator(
+        ["educational", "entertainment", "promotional"]
+    )
     target_audience = "18-34歲年輕人"
     visual_style = "modern"
-    
+
     @classmethod
     def create_invalid_request(cls, **kwargs):
         """建立無效的專案建立請求"""
         return cls.build(
             title="",  # 無效：空標題
             target_platform="invalid_platform",  # 無效：不支援的平台
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_minimal_valid_request(cls, **kwargs):
         """建立最簡有效的專案建立請求"""
         return cls.build(
-            title="最簡測試專案",
-            target_platform="tiktok",
-            **kwargs
+            title="最簡測試專案", target_platform="tiktok", **kwargs
         )
 
+
 class ProjectBatchFactory:
     """專案批次建立工廠"""
-    
+
     @staticmethod
-    def create_user_projects(user_id: str, count: int = 5) -> List[ProjectData]:
+    def create_user_projects(
+        user_id: str, count: int = 5
+    ) -> List[ProjectData]:
         """為特定用戶建立多個專案"""
         projects = []
         for i in range(count):
             project = ProjectFactory.create(
-                user_id=user_id,
-                title=f"用戶專案 {i+1}"
+                user_id=user_id, title=f"用戶專案 {i + 1}"
             )
             projects.append(project)
         return projects
-    
+
     @staticmethod
     def create_mixed_status_projects(user_id: str) -> Dict[str, ProjectData]:
         """建立不同狀態的專案"""
         return {
-            'draft': ProjectFactory.create_draft_project(user_id),
-            'completed': ProjectFactory.create_completed_project(user_id),
-            'published': ProjectFactory.create_published_project(user_id)
+            "draft": ProjectFactory.create_draft_project(user_id),
+            "completed": ProjectFactory.create_completed_project(user_id),
+            "published": ProjectFactory.create_published_project(user_id),
         }
 
+
 # TDD 輔助函數
-def create_test_projects_scenario(user_id: str = None) -> Dict[str, ProjectData]:
+def create_test_projects_scenario(
+    user_id: str = None,
+) -> Dict[str, ProjectData]:
     """
     建立完整的測試專案情境
     用於複雜的 TDD 測試場景
     """
     test_user_id = user_id or fake.uuid4()
-    
+
     return {
-        'draft_project': ProjectFactory.create_draft_project(test_user_id),
-        'completed_project': ProjectFactory.create_completed_project(test_user_id),
-        'published_project': ProjectFactory.create_published_project(test_user_id),
-        'invalid_project': ProjectFactory.create_for_red_phase(),
-        'valid_project': ProjectFactory.create_for_green_phase()
+        "draft_project": ProjectFactory.create_draft_project(test_user_id),
+        "completed_project": ProjectFactory.create_completed_project(
+            test_user_id
+        ),
+        "published_project": ProjectFactory.create_published_project(
+            test_user_id
+        ),
+        "invalid_project": ProjectFactory.create_for_red_phase(),
+        "valid_project": ProjectFactory.create_for_green_phase(),
     }
 
+
 def cleanup_test_projects(projects: Dict[str, ProjectData]):
     """
     清理測試專案數據
     在測試完成後呼叫
     """
     # 清理邏輯
-    pass
\ No newline at end of file
+    pass
diff --git a/auto_generate_video_fold6/tests/factories/script_factory.py b/auto_generate_video_fold6/tests/factories/script_factory.py
index dd4816b..2b354c1 100644
--- a/auto_generate_video_fold6/tests/factories/script_factory.py
+++ b/auto_generate_video_fold6/tests/factories/script_factory.py
@@ -8,13 +8,14 @@ from typing import Dict, Any, List
 from enum import Enum
 
 from .base_factory import (
-    BaseFactory, 
-    TDDFactoryMixin, 
+    BaseFactory,
+    TDDFactoryMixin,
     CommonFieldsMixin,
-    register_factory
+    register_factory,
 )
 
-fake = Faker(['zh_TW', 'en_US'])
+fake = Faker(["zh_TW", "en_US"])
+
 
 class ScriptType(Enum):
     EDUCATIONAL = "educational"
@@ -23,6 +24,7 @@ class ScriptType(Enum):
     NEWS = "news"
     TUTORIAL = "tutorial"
 
+
 class ScriptStatus(Enum):
     DRAFT = "draft"
     GENERATED = "generated"
@@ -30,92 +32,125 @@ class ScriptStatus(Enum):
     APPROVED = "approved"
     USED = "used"
 
+
 class ScriptData:
     """腳本數據類別"""
+
     def __init__(self, **kwargs):
         for key, value in kwargs.items():
             setattr(self, key, value)
 
-@register_factory('script')
+
+@register_factory("script")
 class ScriptFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
     """
     腳本工廠
     為 TDD 測試提供各種腳本數據情境
     """
-    
+
     class Meta:
         model = ScriptData
-    
+
     # 基本欄位
     title = factory.LazyAttribute(lambda o: fake.sentence(nb_words=6))
     content = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=800))
-    
+
     # 關聯欄位
     project_id = factory.LazyFunction(lambda: fake.uuid4())
     user_id = factory.LazyFunction(lambda: fake.uuid4())
-    
+
     # 腳本類型和設定
-    script_type = factory.LazyAttribute(lambda o: fake.random_element([
-        ScriptType.EDUCATIONAL.value,
-        ScriptType.ENTERTAINMENT.value,
-        ScriptType.PROMOTIONAL.value
-    ]))
-    
-    target_platform = factory.Iterator(['tiktok', 'instagram_reels', 'youtube_shorts'])
-    target_audience = factory.LazyAttribute(lambda o: fake.random_element([
-        '18-24歲年輕人', '25-34歲上班族', '35-44歲家長'
-    ]))
-    
+    script_type = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            [
+                ScriptType.EDUCATIONAL.value,
+                ScriptType.ENTERTAINMENT.value,
+                ScriptType.PROMOTIONAL.value,
+            ]
+        )
+    )
+
+    target_platform = factory.Iterator(
+        ["tiktok", "instagram_reels", "youtube_shorts"]
+    )
+    target_audience = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            ["18-24歲年輕人", "25-34歲上班族", "35-44歲家長"]
+        )
+    )
+
     # 語言和風格
-    language = 'zh-TW'
-    tone = factory.LazyAttribute(lambda o: fake.random_element([
-        'professional', 'casual', 'humorous', 'serious', 'friendly'
-    ]))
-    style = factory.LazyAttribute(lambda o: fake.random_element([
-        'conversational', 'narrative', 'instructional', 'persuasive'
-    ]))
-    
+    language = "zh-TW"
+    tone = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            ["professional", "casual", "humorous", "serious", "friendly"]
+        )
+    )
+    style = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            ["conversational", "narrative", "instructional", "persuasive"]
+        )
+    )
+
     # 內容統計
-    word_count = factory.LazyAttribute(lambda o: len(o.content.split()) if hasattr(o, 'content') else fake.random_int(50, 200))
-    estimated_duration = factory.LazyAttribute(lambda o: o.word_count * 0.4 if hasattr(o, 'word_count') else fake.random_int(30, 120))  # 秒
-    
+    word_count = factory.LazyAttribute(
+        lambda o: len(o.content.split())
+        if hasattr(o, "content")
+        else fake.random_int(50, 200)
+    )
+    estimated_duration = factory.LazyAttribute(
+        lambda o: o.word_count * 0.4
+        if hasattr(o, "word_count")
+        else fake.random_int(30, 120)
+    )  # 秒
+
     # 狀態
-    status = factory.LazyAttribute(lambda o: fake.random_element([
-        ScriptStatus.DRAFT.value,
-        ScriptStatus.GENERATED.value,
-        ScriptStatus.REVIEWED.value
-    ]))
-    
+    status = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            [
+                ScriptStatus.DRAFT.value,
+                ScriptStatus.GENERATED.value,
+                ScriptStatus.REVIEWED.value,
+            ]
+        )
+    )
+
     # AI 生成資訊
     generated_by_ai = True
-    ai_model_used = factory.LazyAttribute(lambda o: fake.random_element([
-        'gpt-4', 'claude-3', 'gemini-pro'
-    ]))
-    generation_prompt = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=200))
-    
+    ai_model_used = factory.LazyAttribute(
+        lambda o: fake.random_element(["gpt-4", "claude-3", "gemini-pro"])
+    )
+    generation_prompt = factory.LazyAttribute(
+        lambda o: fake.text(max_nb_chars=200)
+    )
+
     # 關鍵字和標籤
-    keywords = factory.LazyAttribute(lambda o: [
-        fake.word() for _ in range(fake.random_int(3, 8))
-    ])
-    hashtags = factory.LazyAttribute(lambda o: [
-        f"#{fake.word()}" for _ in range(fake.random_int(3, 6))
-    ])
-    
+    keywords = factory.LazyAttribute(
+        lambda o: [fake.word() for _ in range(fake.random_int(3, 8))]
+    )
+    hashtags = factory.LazyAttribute(
+        lambda o: [f"#{fake.word()}" for _ in range(fake.random_int(3, 6))]
+    )
+
     # 結構化內容
-    hook = factory.LazyAttribute(lambda o: fake.sentence(nb_words=8))  # 開場吸引句
-    main_points = factory.LazyAttribute(lambda o: [
-        fake.sentence(nb_words=12) for _ in range(fake.random_int(2, 5))
-    ])
+    hook = factory.LazyAttribute(
+        lambda o: fake.sentence(nb_words=8)
+    )  # 開場吸引句
+    main_points = factory.LazyAttribute(
+        lambda o: [
+            fake.sentence(nb_words=12) for _ in range(fake.random_int(2, 5))
+        ]
+    )
     call_to_action = factory.LazyAttribute(lambda o: fake.sentence(nb_words=6))
-    
+
     # 版本控制
     version = factory.LazyFunction(lambda: fake.random_int(1, 5))
     parent_script_id = None
-    
+
     # 使用統計
     usage_count = factory.LazyFunction(lambda: fake.random_int(0, 10))
     last_used_at = None
-    
+
     # 評分和反饋
     quality_score = factory.LazyFunction(lambda: fake.random.uniform(7.0, 9.5))
     user_rating = None
@@ -126,42 +161,42 @@ class ScriptFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
         """建立教育類型腳本"""
         return cls.create(
             script_type=ScriptType.EDUCATIONAL.value,
-            tone='professional',
-            style='instructional',
+            tone="professional",
+            style="instructional",
             content=fake.text(max_nb_chars=600),
             main_points=[
                 "學習的第一步是理解基本概念",
                 "實踐是掌握技能的關鍵",
-                "持續練習能夠鞏固知識"
+                "持續練習能夠鞏固知識",
             ],
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_entertainment_script(cls, **kwargs):
         """建立娛樂類型腳本"""
         return cls.create(
             script_type=ScriptType.ENTERTAINMENT.value,
-            tone='humorous',
-            style='conversational',
+            tone="humorous",
+            style="conversational",
             content=fake.text(max_nb_chars=400),
             hook="今天要跟大家分享一個超有趣的故事！",
             call_to_action="記得按讚分享給朋友們！",
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_promotional_script(cls, **kwargs):
         """建立推廣類型腳本"""
         return cls.create(
             script_type=ScriptType.PROMOTIONAL.value,
-            tone='persuasive',
-            style='persuasive',
+            tone="persuasive",
+            style="persuasive",
             content=fake.text(max_nb_chars=500),
             call_to_action="立即點擊連結了解更多！",
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_approved_script(cls, **kwargs):
         """建立已審核通過的腳本"""
@@ -169,9 +204,9 @@ class ScriptFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             status=ScriptStatus.APPROVED.value,
             quality_score=fake.random.uniform(8.5, 9.5),
             user_rating=fake.random_int(4, 5),
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_for_red_phase(cls, **kwargs):
         """RED 階段：建立會導致測試失敗的腳本數據"""
@@ -180,9 +215,9 @@ class ScriptFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             content="",  # 無效：空內容
             word_count=-1,  # 無效：負數字數
             estimated_duration=-1,  # 無效：負數持續時間
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_for_green_phase(cls, **kwargs):
         """GREEN 階段：建立讓測試通過的最簡腳本數據"""
@@ -190,19 +225,20 @@ class ScriptFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             title="測試腳本",
             content="這是一個測試腳本的內容。",
             status=ScriptStatus.GENERATED.value,
-            **kwargs
+            **kwargs,
         )
 
-@register_factory('create_script')
+
+@register_factory("create_script")
 class CreateScriptFactory(factory.Factory, TDDFactoryMixin):
     """
     建立腳本請求數據工廠
     模擬 API 請求中的腳本建立數據
     """
-    
+
     class Meta:
         model = dict
-    
+
     title = factory.LazyAttribute(lambda o: fake.sentence(nb_words=5))
     project_id = factory.LazyFunction(lambda: fake.uuid4())
     script_type = ScriptType.EDUCATIONAL.value
@@ -210,12 +246,14 @@ class CreateScriptFactory(factory.Factory, TDDFactoryMixin):
     target_audience = "18-34歲年輕人"
     tone = "friendly"
     style = "conversational"
-    
+
     # 生成設定
-    generation_prompt = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=150))
+    generation_prompt = factory.LazyAttribute(
+        lambda o: fake.text(max_nb_chars=150)
+    )
     keywords = factory.LazyAttribute(lambda o: [fake.word() for _ in range(3)])
     desired_length = "medium"  # short, medium, long
-    
+
     @classmethod
     def create_invalid_request(cls, **kwargs):
         """建立無效的腳本建立請求"""
@@ -223,9 +261,9 @@ class CreateScriptFactory(factory.Factory, TDDFactoryMixin):
             title="",  # 無效：空標題
             project_id="invalid-id",  # 無效：錯誤格式的ID
             script_type="invalid_type",  # 無效：不支援的類型
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_minimal_valid_request(cls, **kwargs):
         """建立最簡有效的腳本建立請求"""
@@ -233,65 +271,70 @@ class CreateScriptFactory(factory.Factory, TDDFactoryMixin):
             title="簡單測試腳本",
             project_id=fake.uuid4(),
             generation_prompt="請生成一個簡單的測試腳本",
-            **kwargs
+            **kwargs,
         )
 
+
 class ScriptBatchFactory:
     """腳本批次建立工廠"""
-    
+
     @staticmethod
-    def create_project_scripts(project_id: str, count: int = 3) -> List[ScriptData]:
+    def create_project_scripts(
+        project_id: str, count: int = 3
+    ) -> List[ScriptData]:
         """為特定專案建立多個腳本"""
         scripts = []
         for i in range(count):
             script = ScriptFactory.create(
-                project_id=project_id,
-                title=f"專案腳本 {i+1}",
-                version=i+1
+                project_id=project_id, title=f"專案腳本 {i + 1}", version=i + 1
             )
             scripts.append(script)
         return scripts
-    
+
     @staticmethod
     def create_different_types_scripts() -> Dict[str, ScriptData]:
         """建立不同類型的腳本"""
         return {
-            'educational': ScriptFactory.create_educational_script(),
-            'entertainment': ScriptFactory.create_entertainment_script(),
-            'promotional': ScriptFactory.create_promotional_script()
+            "educational": ScriptFactory.create_educational_script(),
+            "entertainment": ScriptFactory.create_entertainment_script(),
+            "promotional": ScriptFactory.create_promotional_script(),
         }
 
+
 # TDD 輔助函數
-def create_test_scripts_scenario(project_id: str = None) -> Dict[str, ScriptData]:
+def create_test_scripts_scenario(
+    project_id: str = None,
+) -> Dict[str, ScriptData]:
     """
     建立完整的測試腳本情境
     用於複雜的 TDD 測試場景
     """
     test_project_id = project_id or fake.uuid4()
-    
+
     return {
-        'draft_script': ScriptFactory.create(
-            project_id=test_project_id,
-            status=ScriptStatus.DRAFT.value
+        "draft_script": ScriptFactory.create(
+            project_id=test_project_id, status=ScriptStatus.DRAFT.value
         ),
-        'generated_script': ScriptFactory.create(
-            project_id=test_project_id,
-            status=ScriptStatus.GENERATED.value
+        "generated_script": ScriptFactory.create(
+            project_id=test_project_id, status=ScriptStatus.GENERATED.value
         ),
-        'approved_script': ScriptFactory.create_approved_script(
+        "approved_script": ScriptFactory.create_approved_script(
             project_id=test_project_id
         ),
-        'educational_script': ScriptFactory.create_educational_script(
+        "educational_script": ScriptFactory.create_educational_script(
             project_id=test_project_id
         ),
-        'entertainment_script': ScriptFactory.create_entertainment_script(
+        "entertainment_script": ScriptFactory.create_entertainment_script(
             project_id=test_project_id
         ),
-        'invalid_script': ScriptFactory.create_for_red_phase(),
-        'valid_script': ScriptFactory.create_for_green_phase()
+        "invalid_script": ScriptFactory.create_for_red_phase(),
+        "valid_script": ScriptFactory.create_for_green_phase(),
     }
 
-def create_script_versions(base_script: ScriptData, versions: int = 3) -> List[ScriptData]:
+
+def create_script_versions(
+    base_script: ScriptData, versions: int = 3
+) -> List[ScriptData]:
     """
     建立腳本版本序列
     用於測試版本控制功能
@@ -300,18 +343,19 @@ def create_script_versions(base_script: ScriptData, versions: int = 3) -> List[S
     for i in range(versions):
         version_script = ScriptFactory.create(
             project_id=base_script.project_id,
-            title=f"{base_script.title} v{i+2}",
+            title=f"{base_script.title} v{i + 2}",
             parent_script_id=base_script.id,
-            version=i+2,
-            content=fake.text(max_nb_chars=600)
+            version=i + 2,
+            content=fake.text(max_nb_chars=600),
         )
         versions_list.append(version_script)
     return versions_list
 
+
 def cleanup_test_scripts(scripts: Dict[str, ScriptData]):
     """
     清理測試腳本數據
     在測試完成後呼叫
     """
     # 清理腳本數據和相關檔案
-    pass
\ No newline at end of file
+    pass
diff --git a/auto_generate_video_fold6/tests/factories/user_factory.py b/auto_generate_video_fold6/tests/factories/user_factory.py
index 1e84e7d..bba79e7 100644
--- a/auto_generate_video_fold6/tests/factories/user_factory.py
+++ b/auto_generate_video_fold6/tests/factories/user_factory.py
@@ -7,62 +7,65 @@ from datetime import datetime, timezone
 from typing import Dict, Any
 
 from .base_factory import (
-    BaseFactory, 
-    TDDFactoryMixin, 
+    BaseFactory,
+    TDDFactoryMixin,
     CommonFieldsMixin,
-    register_factory
+    register_factory,
 )
 
-fake = Faker(['zh_TW', 'en_US'])
+fake = Faker(["zh_TW", "en_US"])
+
 
 class UserData:
     """用戶數據類別（用於不需要 ORM 的測試）"""
+
     def __init__(self, **kwargs):
         for key, value in kwargs.items():
             setattr(self, key, value)
 
-@register_factory('user')
+
+@register_factory("user")
 class UserFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
     """
     用戶工廠
     為 TDD 測試提供各種用戶數據情境
     """
-    
+
     class Meta:
         model = UserData
-    
+
     # 基本欄位
     username = factory.LazyAttribute(lambda o: fake.user_name())
     email = factory.LazyAttribute(lambda o: fake.unique.email())
     full_name = factory.LazyAttribute(lambda o: fake.name())
-    
+
     # 密碼相關
     hashed_password = factory.LazyFunction(
         lambda: "$2b$12$test_hash_for_password_123"
     )
-    
+
     # 狀態欄位
     is_active = True
     is_verified = True
     is_premium = False
-    
+
     # 個人資訊
     avatar_url = factory.LazyAttribute(
         lambda o: f"https://example.com/avatars/{o.username}.jpg"
     )
     bio = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=150))
     website = factory.LazyAttribute(lambda o: fake.url())
-    
+
     # 偏好設定
-    language = 'zh-TW'
-    timezone = 'Asia/Taipei'
-    theme = 'light'
-    
+    language = "zh-TW"
+    timezone = "Asia/Taipei"
+    theme = "light"
+
     # 統計數據
     video_count = factory.LazyFunction(lambda: fake.random_int(0, 100))
     follower_count = factory.LazyFunction(lambda: fake.random_int(0, 1000))
     following_count = factory.LazyFunction(lambda: fake.random_int(0, 500))
-    
+
     # 時間戳記
     last_login_at = factory.LazyFunction(lambda: datetime.now(timezone.utc))
     premium_expires_at = None
@@ -74,9 +77,9 @@ class UserFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             username="admin",
             email="admin@example.com",
             is_premium=True,
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_premium_user(cls, **kwargs):
         """建立高級用戶"""
@@ -85,18 +88,14 @@ class UserFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             premium_expires_at=factory.LazyFunction(
                 lambda: datetime.now(timezone.utc).replace(year=2025)
             ),
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_inactive_user(cls, **kwargs):
         """建立未啟用用戶"""
-        return cls.create(
-            is_active=False,
-            is_verified=False,
-            **kwargs
-        )
-    
+        return cls.create(is_active=False, is_verified=False, **kwargs)
+
     @classmethod
     def create_for_red_phase(cls, **kwargs):
         """RED 階段：建立會導致測試失敗的用戶數據"""
@@ -104,35 +103,34 @@ class UserFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
         return cls.create(
             email="invalid-email",  # 無效 email
             username="",  # 空用戶名
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_for_green_phase(cls, **kwargs):
         """GREEN 階段：建立讓測試通過的最簡用戶數據"""
         return cls.create(
-            username="testuser",
-            email="test@example.com",
-            **kwargs
+            username="testuser", email="test@example.com", **kwargs
         )
 
-@register_factory('create_user')
+
+@register_factory("create_user")
 class CreateUserFactory(factory.Factory, TDDFactoryMixin):
     """
     建立用戶請求數據工廠
     模擬 API 請求中的用戶建立數據
     """
-    
+
     class Meta:
         model = dict
-    
+
     username = factory.LazyAttribute(lambda o: fake.user_name())
     email = factory.LazyAttribute(lambda o: fake.unique.email())
     password = "SecurePassword123!"
     full_name = factory.LazyAttribute(lambda o: fake.name())
     language = "zh-TW"
     timezone = "Asia/Taipei"
-    
+
     @classmethod
     def create_invalid_request(cls, **kwargs):
         """建立無效的用戶建立請求"""
@@ -140,18 +138,19 @@ class CreateUserFactory(factory.Factory, TDDFactoryMixin):
             username="",  # 無效：空用戶名
             email="invalid-email",  # 無效：錯誤格式
             password="123",  # 無效：密碼太短
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_duplicate_request(cls, existing_user: UserData, **kwargs):
         """建立重複的用戶建立請求"""
         return cls.build(
             username=existing_user.username,  # 重複用戶名
             email=existing_user.email,  # 重複 email
-            **kwargs
+            **kwargs,
         )
 
+
 # TDD 輔助函數
 def create_test_users_scenario() -> Dict[str, UserData]:
     """
@@ -159,13 +158,14 @@ def create_test_users_scenario() -> Dict[str, UserData]:
     用於複雜的 TDD 測試場景
     """
     return {
-        'active_user': UserFactory.create_for_green_phase(),
-        'inactive_user': UserFactory.create_inactive_user(),
-        'premium_user': UserFactory.create_premium_user(),
-        'admin_user': UserFactory.create_admin_user(),
-        'invalid_user': UserFactory.create_for_red_phase()
+        "active_user": UserFactory.create_for_green_phase(),
+        "inactive_user": UserFactory.create_inactive_user(),
+        "premium_user": UserFactory.create_premium_user(),
+        "admin_user": UserFactory.create_admin_user(),
+        "invalid_user": UserFactory.create_for_red_phase(),
     }
 
+
 def cleanup_test_users(users: Dict[str, UserData]):
     """
     清理測試用戶數據
@@ -173,4 +173,4 @@ def cleanup_test_users(users: Dict[str, UserData]):
     """
     # 這裡可以加入清理邏輯
     # 例如：從資料庫刪除測試數據
-    pass
\ No newline at end of file
+    pass
diff --git a/auto_generate_video_fold6/tests/factories/video_factory.py b/auto_generate_video_fold6/tests/factories/video_factory.py
index 3194a94..9e7f573 100644
--- a/auto_generate_video_fold6/tests/factories/video_factory.py
+++ b/auto_generate_video_fold6/tests/factories/video_factory.py
@@ -8,13 +8,14 @@ from typing import Dict, Any, List
 from enum import Enum
 
 from .base_factory import (
-    BaseFactory, 
-    TDDFactoryMixin, 
+    BaseFactory,
+    TDDFactoryMixin,
     CommonFieldsMixin,
-    register_factory
+    register_factory,
 )
 
-fake = Faker(['zh_TW', 'en_US'])
+fake = Faker(["zh_TW", "en_US"])
+
 
 class VideoStatus(Enum):
     PROCESSING = "processing"
@@ -22,45 +23,50 @@ class VideoStatus(Enum):
     FAILED = "failed"
     PUBLISHED = "published"
 
+
 class VideoQuality(Enum):
     LOW = "360p"
-    MEDIUM = "720p" 
+    MEDIUM = "720p"
     HIGH = "1080p"
     ULTRA = "4K"
 
+
 class VideoData:
     """影片數據類別"""
+
     def __init__(self, **kwargs):
         for key, value in kwargs.items():
             setattr(self, key, value)
 
-@register_factory('video')
+
+@register_factory("video")
 class VideoFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
     """
     影片工廠
     為 TDD 測試提供各種影片數據情境
     """
-    
+
     class Meta:
         model = VideoData
-    
+
     # 基本欄位
     title = factory.LazyAttribute(lambda o: fake.sentence(nb_words=5))
     description = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=400))
-    
+
     # 關聯欄位
     project_id = factory.LazyFunction(lambda: fake.uuid4())
     user_id = factory.LazyFunction(lambda: fake.uuid4())
-    
+
     # 影片屬性
     duration = factory.LazyFunction(lambda: fake.random_int(15, 300))  # 秒
-    resolution = factory.Iterator([
-        VideoQuality.MEDIUM.value,
-        VideoQuality.HIGH.value
-    ])
+    resolution = factory.Iterator(
+        [VideoQuality.MEDIUM.value, VideoQuality.HIGH.value]
+    )
     fps = factory.Iterator([24, 30, 60])
-    file_size = factory.LazyFunction(lambda: fake.random_int(1024*1024, 100*1024*1024))  # bytes
-    
+    file_size = factory.LazyFunction(
+        lambda: fake.random_int(1024 * 1024, 100 * 1024 * 1024)
+    )  # bytes
+
     # 檔案路徑
     file_path = factory.LazyAttribute(
         lambda o: f"/videos/{o.project_id}/{o.id}.mp4"
@@ -68,50 +74,55 @@ class VideoFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
     thumbnail_path = factory.LazyAttribute(
         lambda o: f"/thumbnails/{o.project_id}/{o.id}_thumb.jpg"
     )
-    
+
     # 狀態
-    status = factory.LazyAttribute(lambda o: fake.random_element([
-        VideoStatus.PROCESSING.value,
-        VideoStatus.COMPLETED.value
-    ]))
-    
+    status = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            [VideoStatus.PROCESSING.value, VideoStatus.COMPLETED.value]
+        )
+    )
+
     # 處理資訊
-    processing_started_at = factory.LazyFunction(lambda: datetime.now(timezone.utc))
+    processing_started_at = factory.LazyFunction(
+        lambda: datetime.now(timezone.utc)
+    )
     processing_completed_at = None
     processing_progress = factory.LazyFunction(lambda: fake.random_int(0, 100))
-    
+
     # 錯誤資訊
     error_message = None
     retry_count = 0
-    
+
     # 媒體資訊
-    video_codec = factory.Iterator(['h264', 'h265', 'vp9'])
-    audio_codec = factory.Iterator(['aac', 'mp3', 'opus'])
+    video_codec = factory.Iterator(["h264", "h265", "vp9"])
+    audio_codec = factory.Iterator(["aac", "mp3", "opus"])
     bitrate = factory.LazyFunction(lambda: fake.random_int(1000, 8000))  # kbps
-    
+
     # AI 生成資訊
     script_used = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=500))
-    voice_settings = factory.LazyAttribute(lambda o: {
-        'voice_id': fake.uuid4(),
-        'speed': fake.random.uniform(0.8, 1.2),
-        'pitch': fake.random.uniform(-0.2, 0.2),
-        'volume': fake.random.uniform(0.7, 1.0)
-    })
-    
+    voice_settings = factory.LazyAttribute(
+        lambda o: {
+            "voice_id": fake.uuid4(),
+            "speed": fake.random.uniform(0.8, 1.2),
+            "pitch": fake.random.uniform(-0.2, 0.2),
+            "volume": fake.random.uniform(0.7, 1.0),
+        }
+    )
+
     # 視覺設定
-    background_images = factory.LazyAttribute(lambda o: [
-        f"/images/bg_{i}.jpg" for i in range(fake.random_int(3, 8))
-    ])
-    transition_effects = factory.LazyAttribute(lambda o: fake.random_element([
-        'fade', 'slide', 'zoom', 'dissolve'
-    ]))
-    
+    background_images = factory.LazyAttribute(
+        lambda o: [f"/images/bg_{i}.jpg" for i in range(fake.random_int(3, 8))]
+    )
+    transition_effects = factory.LazyAttribute(
+        lambda o: fake.random_element(["fade", "slide", "zoom", "dissolve"])
+    )
+
     # 統計數據
     view_count = factory.LazyFunction(lambda: fake.random_int(0, 10000))
     like_count = factory.LazyFunction(lambda: fake.random_int(0, 1000))
     share_count = factory.LazyFunction(lambda: fake.random_int(0, 100))
     comment_count = factory.LazyFunction(lambda: fake.random_int(0, 200))
-    
+
     # 發布資訊
     published_at = None
     published_platforms = factory.LazyAttribute(lambda o: [])
@@ -124,9 +135,9 @@ class VideoFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             project_id=project_id or fake.uuid4(),
             processing_progress=fake.random_int(10, 90),
             processing_completed_at=None,
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_completed_video(cls, project_id: str = None, **kwargs):
         """建立已完成的影片"""
@@ -136,9 +147,9 @@ class VideoFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             processing_progress=100,
             processing_completed_at=datetime.now(timezone.utc),
             file_path=f"/videos/{project_id or fake.uuid4()}/completed.mp4",
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_failed_video(cls, project_id: str = None, **kwargs):
         """建立處理失敗的影片"""
@@ -148,9 +159,9 @@ class VideoFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             processing_progress=fake.random_int(0, 50),
             error_message="影片處理失敗：編碼錯誤",
             retry_count=fake.random_int(1, 3),
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_published_video(cls, project_id: str = None, **kwargs):
         """建立已發布的影片"""
@@ -160,11 +171,11 @@ class VideoFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             processing_progress=100,
             processing_completed_at=datetime.now(timezone.utc),
             published_at=datetime.now(timezone.utc),
-            published_platforms=['tiktok', 'instagram_reels'],
+            published_platforms=["tiktok", "instagram_reels"],
             view_count=fake.random_int(100, 5000),
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_high_quality_video(cls, **kwargs):
         """建立高品質影片"""
@@ -172,11 +183,11 @@ class VideoFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             resolution=VideoQuality.HIGH.value,
             fps=60,
             bitrate=fake.random_int(4000, 8000),
-            video_codec='h265',
-            audio_codec='aac',
-            **kwargs
+            video_codec="h265",
+            audio_codec="aac",
+            **kwargs,
         )
-    
+
     @classmethod
     def create_for_red_phase(cls, **kwargs):
         """RED 階段：建立會導致測試失敗的影片數據"""
@@ -185,9 +196,9 @@ class VideoFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             duration=-1,  # 無效：負數持續時間
             file_size=0,  # 無效：檔案大小為0
             project_id="",  # 無效：空專案ID
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_for_green_phase(cls, **kwargs):
         """GREEN 階段：建立讓測試通過的最簡影片數據"""
@@ -196,36 +207,37 @@ class VideoFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             duration=30,
             status=VideoStatus.COMPLETED.value,
             processing_progress=100,
-            **kwargs
+            **kwargs,
         )
 
-@register_factory('create_video')
+
+@register_factory("create_video")
 class CreateVideoFactory(factory.Factory, TDDFactoryMixin):
     """
     建立影片請求數據工廠
     模擬 API 請求中的影片建立數據
     """
-    
+
     class Meta:
         model = dict
-    
+
     title = factory.LazyAttribute(lambda o: fake.sentence(nb_words=4))
     description = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=200))
     project_id = factory.LazyFunction(lambda: fake.uuid4())
-    
+
     # 影片設定
     resolution = VideoQuality.HIGH.value
     fps = 30
     quality_preset = "medium"
-    
+
     # 內容設定
-    script_content = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=300))
-    voice_settings = factory.LazyAttribute(lambda o: {
-        'voice_id': fake.uuid4(),
-        'speed': 1.0,
-        'pitch': 0.0
-    })
-    
+    script_content = factory.LazyAttribute(
+        lambda o: fake.text(max_nb_chars=300)
+    )
+    voice_settings = factory.LazyAttribute(
+        lambda o: {"voice_id": fake.uuid4(), "speed": 1.0, "pitch": 0.0}
+    )
+
     @classmethod
     def create_invalid_request(cls, **kwargs):
         """建立無效的影片建立請求"""
@@ -233,9 +245,9 @@ class CreateVideoFactory(factory.Factory, TDDFactoryMixin):
             title="",  # 無效：空標題
             project_id="invalid-id",  # 無效：錯誤格式的ID
             resolution="invalid-resolution",  # 無效：不支援的解析度
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_minimal_valid_request(cls, **kwargs):
         """建立最簡有效的影片建立請求"""
@@ -243,56 +255,70 @@ class CreateVideoFactory(factory.Factory, TDDFactoryMixin):
             title="簡單測試影片",
             project_id=fake.uuid4(),
             script_content="這是一個測試腳本",
-            **kwargs
+            **kwargs,
         )
 
+
 class VideoBatchFactory:
     """影片批次建立工廠"""
-    
+
     @staticmethod
-    def create_project_videos(project_id: str, count: int = 3) -> List[VideoData]:
+    def create_project_videos(
+        project_id: str, count: int = 3
+    ) -> List[VideoData]:
         """為特定專案建立多個影片"""
         videos = []
         for i in range(count):
             video = VideoFactory.create_completed_video(
-                project_id=project_id,
-                title=f"專案影片 {i+1}"
+                project_id=project_id, title=f"專案影片 {i + 1}"
             )
             videos.append(video)
         return videos
-    
+
     @staticmethod
     def create_mixed_status_videos(project_id: str) -> Dict[str, VideoData]:
         """建立不同狀態的影片"""
         return {
-            'processing': VideoFactory.create_processing_video(project_id),
-            'completed': VideoFactory.create_completed_video(project_id),
-            'failed': VideoFactory.create_failed_video(project_id),
-            'published': VideoFactory.create_published_video(project_id)
+            "processing": VideoFactory.create_processing_video(project_id),
+            "completed": VideoFactory.create_completed_video(project_id),
+            "failed": VideoFactory.create_failed_video(project_id),
+            "published": VideoFactory.create_published_video(project_id),
         }
 
+
 # TDD 輔助函數
-def create_test_videos_scenario(project_id: str = None) -> Dict[str, VideoData]:
+def create_test_videos_scenario(
+    project_id: str = None,
+) -> Dict[str, VideoData]:
     """
     建立完整的測試影片情境
     用於複雜的 TDD 測試場景
     """
     test_project_id = project_id or fake.uuid4()
-    
+
     return {
-        'processing_video': VideoFactory.create_processing_video(test_project_id),
-        'completed_video': VideoFactory.create_completed_video(test_project_id),
-        'failed_video': VideoFactory.create_failed_video(test_project_id),
-        'published_video': VideoFactory.create_published_video(test_project_id),
-        'high_quality_video': VideoFactory.create_high_quality_video(project_id=test_project_id),
-        'invalid_video': VideoFactory.create_for_red_phase(),
-        'valid_video': VideoFactory.create_for_green_phase()
+        "processing_video": VideoFactory.create_processing_video(
+            test_project_id
+        ),
+        "completed_video": VideoFactory.create_completed_video(
+            test_project_id
+        ),
+        "failed_video": VideoFactory.create_failed_video(test_project_id),
+        "published_video": VideoFactory.create_published_video(
+            test_project_id
+        ),
+        "high_quality_video": VideoFactory.create_high_quality_video(
+            project_id=test_project_id
+        ),
+        "invalid_video": VideoFactory.create_for_red_phase(),
+        "valid_video": VideoFactory.create_for_green_phase(),
     }
 
+
 def cleanup_test_videos(videos: Dict[str, VideoData]):
     """
     清理測試影片數據
     在測試完成後呼叫
     """
     # 清理影片檔案和數據庫記錄
-    pass
\ No newline at end of file
+    pass
diff --git a/auto_generate_video_fold6/tests/factories/voice_factory.py b/auto_generate_video_fold6/tests/factories/voice_factory.py
index e49b6b3..36345de 100644
--- a/auto_generate_video_fold6/tests/factories/voice_factory.py
+++ b/auto_generate_video_fold6/tests/factories/voice_factory.py
@@ -8,19 +8,21 @@ from typing import Dict, Any, List
 from enum import Enum
 
 from .base_factory import (
-    BaseFactory, 
-    TDDFactoryMixin, 
+    BaseFactory,
+    TDDFactoryMixin,
     CommonFieldsMixin,
-    register_factory
+    register_factory,
 )
 
-fake = Faker(['zh_TW', 'en_US'])
+fake = Faker(["zh_TW", "en_US"])
+
 
 class VoiceGender(Enum):
     MALE = "male"
     FEMALE = "female"
     NEUTRAL = "neutral"
 
+
 class VoiceLanguage(Enum):
     ZH_TW = "zh-TW"
     ZH_CN = "zh-CN"
@@ -29,121 +31,165 @@ class VoiceLanguage(Enum):
     JA_JP = "ja-JP"
     KO_KR = "ko-KR"
 
+
 class VoiceStatus(Enum):
     TRAINING = "training"
     READY = "ready"
     FAILED = "failed"
     ARCHIVED = "archived"
 
+
 class VoiceCloneData:
     """語音克隆數據類別"""
+
     def __init__(self, **kwargs):
         for key, value in kwargs.items():
             setattr(self, key, value)
 
-@register_factory('voice_clone')
+
+@register_factory("voice_clone")
 class VoiceCloneFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
     """
     語音克隆工廠
     為 TDD 測試提供各種語音克隆數據情境
     """
-    
+
     class Meta:
         model = VoiceCloneData
-    
+
     # 基本欄位
     name = factory.LazyAttribute(lambda o: fake.name())
     description = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=200))
-    
+
     # 關聯欄位
     user_id = factory.LazyFunction(lambda: fake.uuid4())
-    
+
     # 語音屬性
-    gender = factory.LazyAttribute(lambda o: fake.random_element([
-        VoiceGender.MALE.value,
-        VoiceGender.FEMALE.value
-    ]))
-    
-    language = factory.LazyAttribute(lambda o: fake.random_element([
-        VoiceLanguage.ZH_TW.value,
-        VoiceLanguage.EN_US.value
-    ]))
-    
-    accent = factory.LazyAttribute(lambda o: fake.random_element([
-        'standard', 'northern', 'southern', 'american', 'british'
-    ]))
-    
+    gender = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            [VoiceGender.MALE.value, VoiceGender.FEMALE.value]
+        )
+    )
+
+    language = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            [VoiceLanguage.ZH_TW.value, VoiceLanguage.EN_US.value]
+        )
+    )
+
+    accent = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            ["standard", "northern", "southern", "american", "british"]
+        )
+    )
+
     # 音色特徵
-    pitch_range = factory.LazyAttribute(lambda o: {
-        'min': fake.random.uniform(80, 150),
-        'max': fake.random.uniform(200, 300),
-        'average': fake.random.uniform(120, 250)
-    })
-    
-    tone_characteristics = factory.LazyAttribute(lambda o: fake.random_element([
-        'warm', 'professional', 'friendly', 'authoritative', 'calm', 'energetic'
-    ]))
-    
-    speaking_rate = factory.LazyFunction(lambda: fake.random.uniform(0.8, 1.3))  # 相對於標準語速
-    
+    pitch_range = factory.LazyAttribute(
+        lambda o: {
+            "min": fake.random.uniform(80, 150),
+            "max": fake.random.uniform(200, 300),
+            "average": fake.random.uniform(120, 250),
+        }
+    )
+
+    tone_characteristics = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            [
+                "warm",
+                "professional",
+                "friendly",
+                "authoritative",
+                "calm",
+                "energetic",
+            ]
+        )
+    )
+
+    speaking_rate = factory.LazyFunction(
+        lambda: fake.random.uniform(0.8, 1.3)
+    )  # 相對於標準語速
+
     # 訓練資料
-    training_audio_files = factory.LazyAttribute(lambda o: [
-        f"/audio/training/{o.id}/sample_{i}.wav" 
-        for i in range(fake.random_int(5, 20))
-    ])
-    
-    total_training_duration = factory.LazyFunction(lambda: fake.random_int(300, 3600))  # 秒
-    training_quality_score = factory.LazyFunction(lambda: fake.random.uniform(7.0, 9.5))
-    
+    training_audio_files = factory.LazyAttribute(
+        lambda o: [
+            f"/audio/training/{o.id}/sample_{i}.wav"
+            for i in range(fake.random_int(5, 20))
+        ]
+    )
+
+    total_training_duration = factory.LazyFunction(
+        lambda: fake.random_int(300, 3600)
+    )  # 秒
+    training_quality_score = factory.LazyFunction(
+        lambda: fake.random.uniform(7.0, 9.5)
+    )
+
     # 模型資訊
     model_file_path = factory.LazyAttribute(
         lambda o: f"/models/voices/{o.id}/voice_model.pt"
     )
-    model_size = factory.LazyFunction(lambda: fake.random_int(50*1024*1024, 500*1024*1024))  # bytes
+    model_size = factory.LazyFunction(
+        lambda: fake.random_int(50 * 1024 * 1024, 500 * 1024 * 1024)
+    )  # bytes
     model_version = factory.LazyFunction(lambda: fake.random.uniform(1.0, 3.0))
-    
+
     # 狀態和進度
-    status = factory.LazyAttribute(lambda o: fake.random_element([
-        VoiceStatus.READY.value,
-        VoiceStatus.TRAINING.value
-    ]))
-    
+    status = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            [VoiceStatus.READY.value, VoiceStatus.TRAINING.value]
+        )
+    )
+
     training_progress = factory.LazyFunction(lambda: fake.random_int(0, 100))
-    training_started_at = factory.LazyFunction(lambda: datetime.now(timezone.utc))
+    training_started_at = factory.LazyFunction(
+        lambda: datetime.now(timezone.utc)
+    )
     training_completed_at = None
-    
+
     # 品質指標
-    similarity_score = factory.LazyFunction(lambda: fake.random.uniform(0.8, 0.95))  # 與原聲相似度
-    naturalness_score = factory.LazyFunction(lambda: fake.random.uniform(0.7, 0.9))  # 自然度
-    clarity_score = factory.LazyFunction(lambda: fake.random.uniform(0.8, 0.95))  # 清晰度
-    
+    similarity_score = factory.LazyFunction(
+        lambda: fake.random.uniform(0.8, 0.95)
+    )  # 與原聲相似度
+    naturalness_score = factory.LazyFunction(
+        lambda: fake.random.uniform(0.7, 0.9)
+    )  # 自然度
+    clarity_score = factory.LazyFunction(
+        lambda: fake.random.uniform(0.8, 0.95)
+    )  # 清晰度
+
     # 使用統計
     usage_count = factory.LazyFunction(lambda: fake.random_int(0, 100))
     last_used_at = None
-    
+
     # 錯誤資訊
     error_message = None
-    
+
     # 原始聲音來源資訊
     source_speaker_name = factory.LazyAttribute(lambda o: fake.name())
-    source_description = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=100))
+    source_description = factory.LazyAttribute(
+        lambda o: fake.text(max_nb_chars=100)
+    )
     consent_verified = True
-    
+
     # 標籤和分類
-    tags = factory.LazyAttribute(lambda o: [
-        fake.word() for _ in range(fake.random_int(2, 5))
-    ])
-    
-    category = factory.LazyAttribute(lambda o: fake.random_element([
-        'personal', 'commercial', 'character', 'narrator', 'celebrity'
-    ]))
-    
+    tags = factory.LazyAttribute(
+        lambda o: [fake.word() for _ in range(fake.random_int(2, 5))]
+    )
+
+    category = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            ["personal", "commercial", "character", "narrator", "celebrity"]
+        )
+    )
+
     # 隱私和授權
     is_public = factory.LazyFunction(lambda: fake.boolean())
     is_commercial_use_allowed = factory.LazyFunction(lambda: fake.boolean())
-    license_type = factory.LazyAttribute(lambda o: fake.random_element([
-        'personal', 'commercial', 'educational', 'research'
-    ]))
+    license_type = factory.LazyAttribute(
+        lambda o: fake.random_element(
+            ["personal", "commercial", "educational", "research"]
+        )
+    )
 
     @classmethod
     def create_male_voice(cls, **kwargs):
@@ -151,26 +197,26 @@ class VoiceCloneFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
         return cls.create(
             gender=VoiceGender.MALE.value,
             pitch_range={
-                'min': fake.random.uniform(80, 120),
-                'max': fake.random.uniform(150, 200),
-                'average': fake.random.uniform(100, 160)
+                "min": fake.random.uniform(80, 120),
+                "max": fake.random.uniform(150, 200),
+                "average": fake.random.uniform(100, 160),
             },
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_female_voice(cls, **kwargs):
         """建立女聲語音克隆"""
         return cls.create(
             gender=VoiceGender.FEMALE.value,
             pitch_range={
-                'min': fake.random.uniform(150, 200),
-                'max': fake.random.uniform(250, 350),
-                'average': fake.random.uniform(180, 280)
+                "min": fake.random.uniform(150, 200),
+                "max": fake.random.uniform(250, 350),
+                "average": fake.random.uniform(180, 280),
             },
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_training_voice(cls, **kwargs):
         """建立正在訓練的語音克隆"""
@@ -179,9 +225,9 @@ class VoiceCloneFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             training_progress=fake.random_int(10, 90),
             training_completed_at=None,
             model_file_path=None,
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_ready_voice(cls, **kwargs):
         """建立已完成訓練的語音克隆"""
@@ -191,9 +237,9 @@ class VoiceCloneFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             training_completed_at=datetime.now(timezone.utc),
             similarity_score=fake.random.uniform(0.85, 0.95),
             naturalness_score=fake.random.uniform(0.8, 0.9),
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_failed_voice(cls, **kwargs):
         """建立訓練失敗的語音克隆"""
@@ -202,9 +248,9 @@ class VoiceCloneFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             training_progress=fake.random_int(5, 70),
             error_message="訓練數據品質不足，無法完成模型訓練",
             model_file_path=None,
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_high_quality_voice(cls, **kwargs):
         """建立高品質語音克隆"""
@@ -215,9 +261,9 @@ class VoiceCloneFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             naturalness_score=fake.random.uniform(0.85, 0.9),
             clarity_score=fake.random.uniform(0.9, 0.95),
             total_training_duration=fake.random_int(1800, 3600),  # 30-60分鐘
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_for_red_phase(cls, **kwargs):
         """RED 階段：建立會導致測試失敗的語音克隆數據"""
@@ -226,9 +272,9 @@ class VoiceCloneFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             total_training_duration=-1,  # 無效：負數時長
             similarity_score=2.0,  # 無效：超出範圍的分數
             training_audio_files=[],  # 無效：沒有訓練音檔
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_for_green_phase(cls, **kwargs):
         """GREEN 階段：建立讓測試通過的最簡語音克隆數據"""
@@ -236,37 +282,38 @@ class VoiceCloneFactory(factory.Factory, TDDFactoryMixin, CommonFieldsMixin):
             name="測試語音",
             status=VoiceStatus.READY.value,
             training_progress=100,
-            **kwargs
+            **kwargs,
         )
 
-@register_factory('create_voice_clone')
+
+@register_factory("create_voice_clone")
 class CreateVoiceCloneFactory(factory.Factory, TDDFactoryMixin):
     """
     建立語音克隆請求數據工廠
     模擬 API 請求中的語音克隆建立數據
     """
-    
+
     class Meta:
         model = dict
-    
+
     name = factory.LazyAttribute(lambda o: fake.name())
     description = factory.LazyAttribute(lambda o: fake.text(max_nb_chars=150))
-    
+
     # 聲音屬性
     gender = VoiceGender.FEMALE.value
     language = VoiceLanguage.ZH_TW.value
     tone_characteristics = "friendly"
-    
+
     # 訓練設定
-    training_audio_files = factory.LazyAttribute(lambda o: [
-        f"audio_sample_{i}.wav" for i in range(10)
-    ])
-    
+    training_audio_files = factory.LazyAttribute(
+        lambda o: [f"audio_sample_{i}.wav" for i in range(10)]
+    )
+
     # 授權設定
     consent_verified = True
     is_commercial_use_allowed = False
     license_type = "personal"
-    
+
     @classmethod
     def create_invalid_request(cls, **kwargs):
         """建立無效的語音克隆建立請求"""
@@ -274,9 +321,9 @@ class CreateVoiceCloneFactory(factory.Factory, TDDFactoryMixin):
             name="",  # 無效：空名稱
             training_audio_files=[],  # 無效：沒有訓練檔案
             consent_verified=False,  # 無效：未驗證授權
-            **kwargs
+            **kwargs,
         )
-    
+
     @classmethod
     def create_minimal_valid_request(cls, **kwargs):
         """建立最簡有效的語音克隆建立請求"""
@@ -284,52 +331,72 @@ class CreateVoiceCloneFactory(factory.Factory, TDDFactoryMixin):
             name="簡單測試語音",
             training_audio_files=["test_sample.wav"],
             consent_verified=True,
-            **kwargs
+            **kwargs,
         )
 
+
 class VoiceBatchFactory:
     """語音克隆批次建立工廠"""
-    
+
     @staticmethod
-    def create_user_voices(user_id: str, count: int = 3) -> List[VoiceCloneData]:
+    def create_user_voices(
+        user_id: str, count: int = 3
+    ) -> List[VoiceCloneData]:
         """為特定用戶建立多個語音克隆"""
         voices = []
         for i in range(count):
             voice = VoiceCloneFactory.create_ready_voice(
-                user_id=user_id,
-                name=f"用戶語音 {i+1}"
+                user_id=user_id, name=f"用戶語音 {i + 1}"
             )
             voices.append(voice)
         return voices
-    
+
     @staticmethod
     def create_mixed_gender_voices() -> Dict[str, VoiceCloneData]:
         """建立不同性別的語音克隆"""
         return {
-            'male': VoiceCloneFactory.create_male_voice(),
-            'female': VoiceCloneFactory.create_female_voice()
+            "male": VoiceCloneFactory.create_male_voice(),
+            "female": VoiceCloneFactory.create_female_voice(),
         }
 
+
 # TDD 輔助函數
-def create_test_voices_scenario(user_id: str = None) -> Dict[str, VoiceCloneData]:
+def create_test_voices_scenario(
+    user_id: str = None,
+) -> Dict[str, VoiceCloneData]:
     """
     建立完整的測試語音克隆情境
     用於複雜的 TDD 測試場景
     """
     test_user_id = user_id or fake.uuid4()
-    
+
     return {
-        'training_voice': VoiceCloneFactory.create_training_voice(user_id=test_user_id),
-        'ready_voice': VoiceCloneFactory.create_ready_voice(user_id=test_user_id),
-        'failed_voice': VoiceCloneFactory.create_failed_voice(user_id=test_user_id),
-        'male_voice': VoiceCloneFactory.create_male_voice(user_id=test_user_id),
-        'female_voice': VoiceCloneFactory.create_female_voice(user_id=test_user_id),
-        'high_quality_voice': VoiceCloneFactory.create_high_quality_voice(user_id=test_user_id),
-        'invalid_voice': VoiceCloneFactory.create_for_red_phase(),
-        'valid_voice': VoiceCloneFactory.create_for_green_phase()
+        "training_voice": VoiceCloneFactory.create_training_voice(
+            user_id=test_user_id
+        ),
+        "ready_voice": VoiceCloneFactory.create_ready_voice(
+            user_id=test_user_id
+        ),
+        "failed_voice": VoiceCloneFactory.create_failed_voice(
+            user_id=test_user_id
+        ),
+        "male_voice": VoiceCloneFactory.create_male_voice(
+            user_id=test_user_id
+        ),
+        "female_voice": VoiceCloneFactory.create_female_voice(
+            user_id=test_user_id
+        ),
+        "high_quality_voice": VoiceCloneFactory.create_high_quality_voice(
+            user_id=test_user_id
+        ),
+        "invalid_voice": VoiceCloneFactory.create_for_red_phase(),
+        "valid_voice": VoiceCloneFactory.create_for_green_phase(),
     }
 
-def create_voice_training_sequence(base_voice: VoiceCloneData) -> List[VoiceCloneData]:
+
+def create_voice_training_sequence(
+    base_voice: VoiceCloneData,
+) -> List[VoiceCloneData]:
     """
     建立語音訓練進度序列
     用於測試訓練過程
@@ -340,16 +407,19 @@ def create_voice_training_sequence(base_voice: VoiceCloneData) -> List[VoiceClon
             id=base_voice.id,
             name=base_voice.name,
             user_id=base_voice.user_id,
-            status=VoiceStatus.TRAINING.value if progress < 100 else VoiceStatus.READY.value,
-            training_progress=progress
+            status=VoiceStatus.TRAINING.value
+            if progress < 100
+            else VoiceStatus.READY.value,
+            training_progress=progress,
         )
         sequences.append(voice_snapshot)
     return sequences
 
+
 def cleanup_test_voices(voices: Dict[str, VoiceCloneData]):
     """
     清理測試語音克隆數據
     在測試完成後呼叫
     """
     # 清理語音模型檔案和數據庫記錄
-    pass
\ No newline at end of file
+    pass
diff --git a/auto_generate_video_fold6/tests/fixtures/test_data.py b/auto_generate_video_fold6/tests/fixtures/test_data.py
index e082bbf..fb1b226 100644
--- a/auto_generate_video_fold6/tests/fixtures/test_data.py
+++ b/auto_generate_video_fold6/tests/fixtures/test_data.py
@@ -43,8 +43,14 @@ def multiple_users_data():
                 "full_name": f"User {i}",
                 "password": "Test123456!",
                 "is_verified": i % 2 == 0,  # 偶數用戶已驗證
-                "created_at": (datetime.utcnow() - timedelta(days=i)).isoformat(),
-                "credits": {"total": 1000 + i * 100, "used": i * 50, "remaining": 1000 + i * 50},
+                "created_at": (
+                    datetime.utcnow() - timedelta(days=i)
+                ).isoformat(),
+                "credits": {
+                    "total": 1000 + i * 100,
+                    "used": i * 50,
+                    "remaining": 1000 + i * 50,
+                },
             }
         )
     return users
@@ -185,7 +191,11 @@ These tools aren't just cool - they're game-changers! Which one will you try fir
         "style": "engaging",
         "status": "generated",
         "generation_time_seconds": 3.2,
-        "metadata": {"model_used": "gpt-4", "temperature": 0.8, "tokens_used": 456},
+        "metadata": {
+            "model_used": "gpt-4",
+            "temperature": 0.8,
+            "tokens_used": 456,
+        },
     }
 
 
@@ -252,7 +262,12 @@ def trending_keywords_data():
                 "platforms": ["tiktok", "youtube"],
                 "engagement_rate": 6.8,
                 "competition": "very_high",
-                "suggested_tags": ["crypto", "trading", "bitcoin", "investment"],
+                "suggested_tags": [
+                    "crypto",
+                    "trading",
+                    "bitcoin",
+                    "investment",
+                ],
             },
         ],
         "generated_at": datetime.utcnow().isoformat(),
@@ -414,7 +429,11 @@ class TestDataSeeder:
                 description=f"Description for test project {i}",
                 user_id=user_id,
                 status="draft" if i % 2 == 0 else "completed",
-                settings={"aspect_ratio": "9:16", "duration": 60 + i * 10, "style": "engaging"},
+                settings={
+                    "aspect_ratio": "9:16",
+                    "duration": 60 + i * 10,
+                    "style": "engaging",
+                },
             )
             projects.append(project)
             db_session.add(project)
@@ -484,7 +503,9 @@ class MockDataGenerator:
         return data
 
     @staticmethod
-    def generate_project(user_id: str = None, overrides: Dict[str, Any] = None) -> Dict[str, Any]:
+    def generate_project(
+        user_id: str = None, overrides: Dict[str, Any] = None
+    ) -> Dict[str, Any]:
         """生成專案數據"""
         data = {
             "id": str(uuid.uuid4()),
@@ -502,7 +523,9 @@ class MockDataGenerator:
         return data
 
     @staticmethod
-    def generate_api_response(success: bool = True, data: Any = None) -> Dict[str, Any]:
+    def generate_api_response(
+        success: bool = True, data: Any = None
+    ) -> Dict[str, Any]:
         """生成 API 回應數據"""
         if success:
             return {
diff --git a/auto_generate_video_fold6/tests/test_config_manager.py b/auto_generate_video_fold6/tests/test_config_manager.py
index f6e231c..5295189 100644
--- a/auto_generate_video_fold6/tests/test_config_manager.py
+++ b/auto_generate_video_fold6/tests/test_config_manager.py
@@ -16,7 +16,9 @@ except ImportError:
     CONFIG_MANAGER_AVAILABLE = False
 
 
-@pytest.mark.skipif(not CONFIG_MANAGER_AVAILABLE, reason="配置管理器模組不可用")
+@pytest.mark.skipif(
+    not CONFIG_MANAGER_AVAILABLE, reason="配置管理器模組不可用"
+)
 class TestConfigManager:
     """配置管理器測試類"""
 
@@ -35,7 +37,10 @@ class TestConfigManager:
                 "batch_size": 3,
                 "platforms": ["tiktok", "instagram"],
             },
-            "cost_control": {"daily_budget_usd": 50.0, "stop_on_budget_exceeded": True},
+            "cost_control": {
+                "daily_budget_usd": 50.0,
+                "stop_on_budget_exceeded": True,
+            },
         }
 
         with open(config_dir / "base-config.json", "w") as f:
@@ -218,24 +223,34 @@ class TestConfigManager:
         cm2 = ConfigManager(str(temp_config_dir))
 
         # 驗證配置一致性
-        assert cm2.get("generation.daily_video_limit") == cm1.get("generation.daily_video_limit")
+        assert cm2.get("generation.daily_video_limit") == cm1.get(
+            "generation.daily_video_limit"
+        )
 
 
 @pytest.mark.unit
 class TestConfigManagerUtils:
     """配置管理器工具函數測試"""
 
-    @pytest.mark.skipif(not CONFIG_MANAGER_AVAILABLE, reason="配置管理器模組不可用")
+    @pytest.mark.skipif(
+        not CONFIG_MANAGER_AVAILABLE, reason="配置管理器模組不可用"
+    )
     def test_get_config_function(self, mock_config_manager):
         """測試 get_config 便利函數"""
-        with patch("config.config_manager.config_manager", mock_config_manager):
+        with patch(
+            "config.config_manager.config_manager", mock_config_manager
+        ):
             value = get_config("generation.daily_video_limit", 0)
             assert value == 5
 
-    @pytest.mark.skipif(not CONFIG_MANAGER_AVAILABLE, reason="配置管理器模組不可用")
+    @pytest.mark.skipif(
+        not CONFIG_MANAGER_AVAILABLE, reason="配置管理器模組不可用"
+    )
     def test_set_mode_function(self, mock_config_manager):
         """測試 set_mode 便利函數"""
-        with patch("config.config_manager.config_manager", mock_config_manager):
+        with patch(
+            "config.config_manager.config_manager", mock_config_manager
+        ):
             set_mode("enterprise")
             # 這裡應該檢查模式是否改變，但需要 mock 實現
             assert True  # 簡化的測試
@@ -246,7 +261,9 @@ class TestConfigManagerUtils:
 class TestConfigManagerIntegration:
     """配置管理器整合測試"""
 
-    @pytest.mark.skipif(not CONFIG_MANAGER_AVAILABLE, reason="配置管理器模組不可用")
+    @pytest.mark.skipif(
+        not CONFIG_MANAGER_AVAILABLE, reason="配置管理器模組不可用"
+    )
     def test_full_config_workflow(self, temp_config_dir):
         """測試完整配置工作流程"""
         # 初始化配置管理器
diff --git a/auto_generate_video_fold6/tests/test_cost_tracker.py b/auto_generate_video_fold6/tests/test_cost_tracker.py
index 733a1a0..2896df6 100644
--- a/auto_generate_video_fold6/tests/test_cost_tracker.py
+++ b/auto_generate_video_fold6/tests/test_cost_tracker.py
@@ -16,7 +16,10 @@ try:
         APICallRecord,
         DailyCostSummary,
     )
-    from monitoring.budget_controller import BudgetController, get_budget_controller
+    from monitoring.budget_controller import (
+        BudgetController,
+        get_budget_controller,
+    )
 
     COST_MONITORING_AVAILABLE = True
 except ImportError:
@@ -45,7 +48,9 @@ class TestCostTracker:
 
         # 檢查資料庫表是否創建
         with sqlite3.connect(cost_tracker.db_path) as conn:
-            cursor = conn.execute("SELECT name FROM sqlite_master WHERE type='table'")
+            cursor = conn.execute(
+                "SELECT name FROM sqlite_master WHERE type='table'"
+            )
             tables = [row[0] for row in cursor.fetchall()]
             assert "api_calls" in tables
             assert "daily_summaries" in tables
@@ -113,9 +118,14 @@ class TestCostTracker:
     async def test_daily_summary(self, cost_tracker):
         """測試每日摘要功能"""
         # 添加一些測試呼叫
-        await cost_tracker.track_api_call("openai", "gpt-4", "text_generation", tokens_used=500)
         await cost_tracker.track_api_call(
-            "stability_ai", "stable-diffusion-xl", "image_generation", images_generated=2
+            "openai", "gpt-4", "text_generation", tokens_used=500
+        )
+        await cost_tracker.track_api_call(
+            "stability_ai",
+            "stable-diffusion-xl",
+            "image_generation",
+            images_generated=2,
         )
 
         summary = await cost_tracker.get_daily_summary()
@@ -131,7 +141,9 @@ class TestCostTracker:
     async def test_weekly_report(self, cost_tracker):
         """測試週報告功能"""
         # 添加測試數據
-        await cost_tracker.track_api_call("openai", "gpt-4", "text_generation", tokens_used=500)
+        await cost_tracker.track_api_call(
+            "openai", "gpt-4", "text_generation", tokens_used=500
+        )
 
         report = await cost_tracker.get_weekly_report()
 
@@ -145,7 +157,9 @@ class TestCostTracker:
     async def test_budget_status_check(self, cost_tracker):
         """測試預算狀態檢查"""
         # 添加一些成本
-        await cost_tracker.track_api_call("openai", "gpt-4", "text_generation", tokens_used=1000)
+        await cost_tracker.track_api_call(
+            "openai", "gpt-4", "text_generation", tokens_used=1000
+        )
 
         status = await cost_tracker.check_budget_status()
 
@@ -171,9 +185,14 @@ class TestCostTracker:
     async def test_export_cost_data(self, cost_tracker):
         """測試成本數據匯出"""
         # 添加測試數據
-        await cost_tracker.track_api_call("openai", "gpt-4", "text_generation", tokens_used=500)
         await cost_tracker.track_api_call(
-            "stability_ai", "stable-diffusion-xl", "image_generation", images_generated=1
+            "openai", "gpt-4", "text_generation", tokens_used=500
+        )
+        await cost_tracker.track_api_call(
+            "stability_ai",
+            "stable-diffusion-xl",
+            "image_generation",
+            images_generated=1,
         )
 
         export_file = await cost_tracker.export_cost_data(days=7)
@@ -211,7 +230,9 @@ class TestBudgetController:
     @pytest.mark.asyncio
     async def test_budget_decision_normal(self, budget_controller):
         """測試正常預算情況下的決策"""
-        decision = await budget_controller.check_budget_and_decide(estimated_cost=1.0)
+        decision = await budget_controller.check_budget_and_decide(
+            estimated_cost=1.0
+        )
 
         assert decision.can_continue == True
         assert decision.status.value in ["normal", "warning"]
@@ -222,7 +243,9 @@ class TestBudgetController:
     async def test_budget_decision_critical(self, budget_controller):
         """測試臨界預算情況下的決策"""
         # 模擬高預算使用率
-        with patch.object(budget_controller.cost_tracker, "check_budget_status") as mock_status:
+        with patch.object(
+            budget_controller.cost_tracker, "check_budget_status"
+        ) as mock_status:
             mock_status.return_value = {
                 "current_cost": 9.5,
                 "budget_limit": 10.0,
@@ -232,9 +255,14 @@ class TestBudgetController:
                 "can_continue": True,
             }
 
-            decision = await budget_controller.check_budget_and_decide(estimated_cost=1.0)
+            decision = await budget_controller.check_budget_and_decide(
+                estimated_cost=1.0
+            )
 
-            assert decision.can_continue == False or decision.action.value in ["pause", "stop"]
+            assert decision.can_continue == False or decision.action.value in [
+                "pause",
+                "stop",
+            ]
             assert decision.status.value in ["critical", "exceeded"]
 
     @pytest.mark.asyncio
@@ -252,7 +280,9 @@ class TestBudgetController:
     async def test_post_operation_update(self, budget_controller):
         """測試操作後更新"""
         # 這應該不會拋出例外
-        await budget_controller.post_operation_update(actual_cost=1.5, operation_result=True)
+        await budget_controller.post_operation_update(
+            actual_cost=1.5, operation_result=True
+        )
 
         # 驗證成本追蹤器狀態更新
         # 具體驗證邏輯取決於實現
@@ -261,7 +291,9 @@ class TestBudgetController:
     async def test_dynamic_budget_adjustment(self, budget_controller):
         """測試動態預算調整"""
         if budget_controller.config_manager:
-            old_budget = budget_controller.config_manager.get("cost_control.daily_budget_usd", 10.0)
+            old_budget = budget_controller.config_manager.get(
+                "cost_control.daily_budget_usd", 10.0
+            )
 
             result = await budget_controller.adjust_budget_dynamically(
                 new_budget=20.0, reason="測試調整"
@@ -299,7 +331,9 @@ class TestBudgetController:
 class TestCostCalculations:
     """成本計算測試"""
 
-    @pytest.mark.skipif(not COST_MONITORING_AVAILABLE, reason="成本監控模組不可用")
+    @pytest.mark.skipif(
+        not COST_MONITORING_AVAILABLE, reason="成本監控模組不可用"
+    )
     def test_openai_cost_calculation(self, mock_config_manager):
         """測試 OpenAI 成本計算"""
         tracker = CostTracker(mock_config_manager, ":memory:")
@@ -319,7 +353,9 @@ class TestCostCalculations:
         expected_cost = (500 / 1000 * 0.03) + (500 / 1000 * 0.06)
         assert cost == pytest.approx(expected_cost, rel=0.01)
 
-    @pytest.mark.skipif(not COST_MONITORING_AVAILABLE, reason="成本監控模組不可用")
+    @pytest.mark.skipif(
+        not COST_MONITORING_AVAILABLE, reason="成本監控模組不可用"
+    )
     def test_stability_cost_calculation(self, mock_config_manager):
         """測試 Stability AI 成本計算"""
         tracker = CostTracker(mock_config_manager, ":memory:")
@@ -337,7 +373,9 @@ class TestCostCalculations:
         expected_cost = 5 * 0.04
         assert cost == pytest.approx(expected_cost, rel=0.01)
 
-    @pytest.mark.skipif(not COST_MONITORING_AVAILABLE, reason="成本監控模組不可用")
+    @pytest.mark.skipif(
+        not COST_MONITORING_AVAILABLE, reason="成本監控模組不可用"
+    )
     def test_elevenlabs_cost_calculation(self, mock_config_manager):
         """測試 ElevenLabs 成本計算"""
         tracker = CostTracker(mock_config_manager, ":memory:")
@@ -361,9 +399,13 @@ class TestCostCalculations:
 class TestCostMonitoringIntegration:
     """成本監控整合測試"""
 
-    @pytest.mark.skipif(not COST_MONITORING_AVAILABLE, reason="成本監控模組不可用")
+    @pytest.mark.skipif(
+        not COST_MONITORING_AVAILABLE, reason="成本監控模組不可用"
+    )
     @pytest.mark.asyncio
-    async def test_full_cost_tracking_workflow(self, temp_dir, mock_config_manager):
+    async def test_full_cost_tracking_workflow(
+        self, temp_dir, mock_config_manager
+    ):
         """測試完整的成本追蹤工作流程"""
         db_path = temp_dir / "integration_test.db"
 
@@ -374,9 +416,24 @@ class TestCostMonitoringIntegration:
         # 模擬一系列 API 呼叫
         api_calls = [
             ("openai", "gpt-4", "text_generation", {"tokens_used": 800}),
-            ("stability_ai", "stable-diffusion-xl", "image_generation", {"images_generated": 2}),
-            ("elevenlabs", "voice_synthesis", "voice_synthesis", {"characters_used": 1500}),
-            ("openai", "gpt-3.5-turbo", "text_generation", {"tokens_used": 1200}),
+            (
+                "stability_ai",
+                "stable-diffusion-xl",
+                "image_generation",
+                {"images_generated": 2},
+            ),
+            (
+                "elevenlabs",
+                "voice_synthesis",
+                "voice_synthesis",
+                {"characters_used": 1500},
+            ),
+            (
+                "openai",
+                "gpt-3.5-turbo",
+                "text_generation",
+                {"tokens_used": 1200},
+            ),
         ]
 
         total_cost = 0
@@ -389,7 +446,10 @@ class TestCostMonitoringIntegration:
             if can_proceed:
                 # 執行 API 呼叫並追蹤成本
                 cost = await cost_tracker.track_api_call(
-                    provider=provider, model=model, operation_type=operation, **kwargs
+                    provider=provider,
+                    model=model,
+                    operation_type=operation,
+                    **kwargs,
                 )
                 total_cost += cost
 
@@ -406,11 +466,15 @@ class TestCostMonitoringIntegration:
 
         # 檢查預算狀態
         budget_status = await cost_tracker.check_budget_status()
-        assert budget_status["current_cost"] == pytest.approx(total_cost, rel=0.01)
+        assert budget_status["current_cost"] == pytest.approx(
+            total_cost, rel=0.01
+        )
 
         # 獲取預算報告
         budget_report = await budget_controller.get_daily_budget_report()
-        assert budget_report["budget_status"]["current_cost"] == pytest.approx(total_cost, rel=0.01)
+        assert budget_report["budget_status"]["current_cost"] == pytest.approx(
+            total_cost, rel=0.01
+        )
 
         # 清理
         if db_path.exists():
@@ -421,7 +485,9 @@ class TestCostMonitoringIntegration:
 class TestGlobalFunctions:
     """全域函數測試"""
 
-    @pytest.mark.skipif(not COST_MONITORING_AVAILABLE, reason="成本監控模組不可用")
+    @pytest.mark.skipif(
+        not COST_MONITORING_AVAILABLE, reason="成本監控模組不可用"
+    )
     def test_get_cost_tracker(self, mock_config_manager):
         """測試獲取成本追蹤器實例"""
         tracker1 = get_cost_tracker(mock_config_manager)
@@ -430,7 +496,9 @@ class TestGlobalFunctions:
         # 應該返回同一個實例（單例模式）
         assert tracker1 is tracker2
 
-    @pytest.mark.skipif(not COST_MONITORING_AVAILABLE, reason="成本監控模組不可用")
+    @pytest.mark.skipif(
+        not COST_MONITORING_AVAILABLE, reason="成本監控模組不可用"
+    )
     def test_get_budget_controller(self, mock_config_manager):
         """測試獲取預算控制器實例"""
         controller1 = get_budget_controller(mock_config_manager)
diff --git a/services/api-gateway/app/auth.py b/services/api-gateway/app/auth.py
index 1aced64..69c2eb5 100644
--- a/services/api-gateway/app/auth.py
+++ b/services/api-gateway/app/auth.py
@@ -29,14 +29,18 @@ async def verify_token_with_auth_service(token: str) -> dict:
                 return None
 
         except httpx.RequestError as e:
-            logger.error("Failed to verify token with auth service", error=str(e))
+            logger.error(
+                "Failed to verify token with auth service", error=str(e)
+            )
             return None
 
 
 def verify_token_locally(token: str) -> dict:
     """Verify JWT token locally (fallback)"""
     try:
-        payload = jwt.decode(token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm])
+        payload = jwt.decode(
+            token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm]
+        )
         email: str = payload.get("sub")
         if email is None:
             return None
@@ -45,7 +49,9 @@ def verify_token_locally(token: str) -> dict:
         return None
 
 
-async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security_scheme)):
+async def get_current_user(
+    credentials: HTTPAuthorizationCredentials = Depends(security_scheme),
+):
     """Get current authenticated user"""
     credentials_exception = HTTPException(
         status_code=status.HTTP_401_UNAUTHORIZED,
@@ -61,7 +67,9 @@ async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(s
 
         # If auth service is unavailable, verify locally
         if user_data is None:
-            logger.warning("Auth service unavailable, using local token verification")
+            logger.warning(
+                "Auth service unavailable, using local token verification"
+            )
             user_data = verify_token_locally(token)
 
         if user_data is None:
@@ -75,7 +83,9 @@ async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(s
 
 
 async def get_optional_user(
-    credentials: HTTPAuthorizationCredentials = Depends(HTTPBearer(auto_error=False)),
+    credentials: HTTPAuthorizationCredentials = Depends(
+        HTTPBearer(auto_error=False)
+    ),
 ):
     """Get current user if token is provided (optional)"""
     if not credentials:
diff --git a/services/api-gateway/app/config.py b/services/api-gateway/app/config.py
index e9e750e..b64cde3 100644
--- a/services/api-gateway/app/config.py
+++ b/services/api-gateway/app/config.py
@@ -10,7 +10,10 @@ class Settings(BaseSettings):
 
     # CORS
     allowed_hosts: List[str] = ["localhost", "127.0.0.1"]
-    cors_origins: List[str] = ["http://localhost:3000", "http://localhost:5173"]
+    cors_origins: List[str] = [
+        "http://localhost:3000",
+        "http://localhost:5173",
+    ]
 
     # Logging
     log_level: str = "INFO"
diff --git a/services/api-gateway/app/main.py b/services/api-gateway/app/main.py
index fa9ae75..6276b08 100644
--- a/services/api-gateway/app/main.py
+++ b/services/api-gateway/app/main.py
@@ -50,7 +50,9 @@ app = FastAPI(
 
 # Add rate limiting
 app.state.limiter = limiter
-app.add_exception_handler(RateLimitExceeded, custom_rate_limit_exceeded_handler)
+app.add_exception_handler(
+    RateLimitExceeded, custom_rate_limit_exceeded_handler
+)
 
 # Add middleware
 app.add_middleware(SecurityHeadersMiddleware)
diff --git a/services/api-gateway/app/middleware.py b/services/api-gateway/app/middleware.py
index 9c77eac..4e26dfd 100644
--- a/services/api-gateway/app/middleware.py
+++ b/services/api-gateway/app/middleware.py
@@ -15,7 +15,9 @@ class LoggingMiddleware(BaseHTTPMiddleware):
     def __init__(self, app: ASGIApp):
         super().__init__(app)
 
-    async def dispatch(self, request: Request, call_next: Callable) -> Response:
+    async def dispatch(
+        self, request: Request, call_next: Callable
+    ) -> Response:
         # Generate unique request ID
         request_id = str(uuid.uuid4())
 
@@ -76,14 +78,18 @@ class LoggingMiddleware(BaseHTTPMiddleware):
 class SecurityHeadersMiddleware(BaseHTTPMiddleware):
     """Middleware to add security headers"""
 
-    async def dispatch(self, request: Request, call_next: Callable) -> Response:
+    async def dispatch(
+        self, request: Request, call_next: Callable
+    ) -> Response:
         response = await call_next(request)
 
         # Add security headers
         response.headers["X-Content-Type-Options"] = "nosniff"
         response.headers["X-Frame-Options"] = "DENY"
         response.headers["X-XSS-Protection"] = "1; mode=block"
-        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
+        response.headers["Strict-Transport-Security"] = (
+            "max-age=31536000; includeSubDomains"
+        )
         response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
 
         return response
diff --git a/services/api-gateway/app/proxy.py b/services/api-gateway/app/proxy.py
index f99682a..52782ad 100644
--- a/services/api-gateway/app/proxy.py
+++ b/services/api-gateway/app/proxy.py
@@ -33,7 +33,8 @@ class ServiceProxy:
 
         if service not in self.service_urls:
             raise HTTPException(
-                status_code=status.HTTP_404_NOT_FOUND, detail=f"Service '{service}' not found"
+                status_code=status.HTTP_404_NOT_FOUND,
+                detail=f"Service '{service}' not found",
             )
 
         service_url = self.service_urls[service]
@@ -104,7 +105,12 @@ class ServiceProxy:
             )
 
         except httpx.RequestError as e:
-            logger.error("Service request error", service=service, path=path, error=str(e))
+            logger.error(
+                "Service request error",
+                service=service,
+                path=path,
+                error=str(e),
+            )
             raise HTTPException(
                 status_code=status.HTTP_502_BAD_GATEWAY,
                 detail=f"Service '{service}' is unavailable",
@@ -124,13 +130,19 @@ class ServiceProxy:
             return False
 
     async def forward_file_request(
-        self, service: str, path: str, method: str, headers: Dict[str, str] = None, file=None
+        self,
+        service: str,
+        path: str,
+        method: str,
+        headers: Dict[str, str] = None,
+        file=None,
     ) -> Dict[str, Any]:
         """Forward file upload request to internal service"""
 
         if service not in self.service_urls:
             raise HTTPException(
-                status_code=status.HTTP_404_NOT_FOUND, detail=f"Service '{service}' not found"
+                status_code=status.HTTP_404_NOT_FOUND,
+                detail=f"Service '{service}' not found",
             )
 
         service_url = self.service_urls[service]
@@ -139,7 +151,12 @@ class ServiceProxy:
         # Prepare headers (remove content-type for multipart)
         request_headers = {}
         if headers:
-            forwarded_headers = ["authorization", "user-agent", "x-forwarded-for", "x-real-ip"]
+            forwarded_headers = [
+                "authorization",
+                "user-agent",
+                "x-forwarded-for",
+                "x-real-ip",
+            ]
             for header in forwarded_headers:
                 if header in headers:
                     request_headers[header] = headers[header]
@@ -150,7 +167,10 @@ class ServiceProxy:
 
             async with httpx.AsyncClient(timeout=self.timeout) as client:
                 response = await client.request(
-                    method=method, url=full_url, headers=request_headers, files=files
+                    method=method,
+                    url=full_url,
+                    headers=request_headers,
+                    files=files,
                 )
 
                 logger.info(
@@ -196,7 +216,8 @@ class ServiceProxy:
                 error=str(e),
             )
             raise HTTPException(
-                status_code=status.HTTP_502_BAD_GATEWAY, detail=f"File upload to '{service}' failed"
+                status_code=status.HTTP_502_BAD_GATEWAY,
+                detail=f"File upload to '{service}' failed",
             )
 
 
diff --git a/services/api-gateway/app/rate_limiter.py b/services/api-gateway/app/rate_limiter.py
index ca1bc38..ca80902 100644
--- a/services/api-gateway/app/rate_limiter.py
+++ b/services/api-gateway/app/rate_limiter.py
@@ -40,7 +40,9 @@ limiter = Limiter(
 )
 
 
-def custom_rate_limit_exceeded_handler(request: Request, exc: RateLimitExceeded):
+def custom_rate_limit_exceeded_handler(
+    request: Request, exc: RateLimitExceeded
+):
     """Custom rate limit exceeded handler"""
     response = HTTPException(
         status_code=status.HTTP_429_TOO_MANY_REQUESTS,
diff --git a/services/api-gateway/app/routers.py b/services/api-gateway/app/routers.py
index a385576..26d1f2a 100644
--- a/services/api-gateway/app/routers.py
+++ b/services/api-gateway/app/routers.py
@@ -1,4 +1,12 @@
-from fastapi import APIRouter, Request, Depends, HTTPException, status, UploadFile, File
+from fastapi import (
+    APIRouter,
+    Request,
+    Depends,
+    HTTPException,
+    status,
+    UploadFile,
+    File,
+)
 from fastapi.responses import JSONResponse
 from typing import Dict, Any, Optional
 import structlog
@@ -32,7 +40,9 @@ async def register(request: Request):
     )
 
     if result["status_code"] == 201:
-        return JSONResponse(status_code=result["status_code"], content=result["data"])
+        return JSONResponse(
+            status_code=result["status_code"], content=result["data"]
+        )
     else:
         raise HTTPException(
             status_code=result["status_code"],
@@ -54,27 +64,39 @@ async def login(request: Request):
     )
 
     if result["status_code"] == 200:
-        return JSONResponse(status_code=result["status_code"], content=result["data"])
+        return JSONResponse(
+            status_code=result["status_code"], content=result["data"]
+        )
     else:
         raise HTTPException(
-            status_code=result["status_code"], detail=result["data"].get("detail", "Login failed")
+            status_code=result["status_code"],
+            detail=result["data"].get("detail", "Login failed"),
         )
 
 
 @auth_router.get("/me")
 @limiter.limit("30/minute")
-async def get_profile(request: Request, current_user: dict = Depends(get_current_user)):
+async def get_profile(
+    request: Request, current_user: dict = Depends(get_current_user)
+):
     """Get current user profile"""
     result = await proxy.forward_request(
-        service="auth", path="/api/v1/me", method="GET", headers=dict(request.headers)
+        service="auth",
+        path="/api/v1/me",
+        method="GET",
+        headers=dict(request.headers),
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @auth_router.put("/me")
 @limiter.limit("10/minute")
-async def update_profile(request: Request, current_user: dict = Depends(get_current_user)):
+async def update_profile(
+    request: Request, current_user: dict = Depends(get_current_user)
+):
     """Update user profile"""
     body = await request.json()
     result = await proxy.forward_request(
@@ -85,12 +107,16 @@ async def update_profile(request: Request, current_user: dict = Depends(get_curr
         json_data=body,
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @auth_router.post("/change-password")
 @limiter.limit("5/minute")
-async def change_password(request: Request, current_user: dict = Depends(get_current_user)):
+async def change_password(
+    request: Request, current_user: dict = Depends(get_current_user)
+):
     """Change user password"""
     body = await request.json()
     result = await proxy.forward_request(
@@ -101,14 +127,18 @@ async def change_password(request: Request, current_user: dict = Depends(get_cur
         json_data=body,
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 # Data ingestion routes
 @data_router.post("/upload")
 @limiter.limit("10/minute")
 async def upload_audio(
-    request: Request, file: UploadFile = File(...), current_user: dict = Depends(get_current_user)
+    request: Request,
+    file: UploadFile = File(...),
+    current_user: dict = Depends(get_current_user),
 ):
     """Upload audio file for training"""
     # Forward to data service
@@ -120,12 +150,16 @@ async def upload_audio(
         file=file,
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @data_router.get("/files")
 @limiter.limit("30/minute")
-async def get_user_files(request: Request, current_user: dict = Depends(get_current_user)):
+async def get_user_files(
+    request: Request, current_user: dict = Depends(get_current_user)
+):
     """Get user's uploaded files"""
     result = await proxy.forward_request(
         service="data",
@@ -135,13 +169,17 @@ async def get_user_files(request: Request, current_user: dict = Depends(get_curr
         params=dict(request.query_params),
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @data_router.delete("/files/{file_id}")
 @limiter.limit("10/minute")
 async def delete_file(
-    file_id: int, request: Request, current_user: dict = Depends(get_current_user)
+    file_id: int,
+    request: Request,
+    current_user: dict = Depends(get_current_user),
 ):
     """Delete uploaded file"""
     result = await proxy.forward_request(
@@ -151,13 +189,17 @@ async def delete_file(
         headers=dict(request.headers),
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @data_router.post("/process/{file_id}")
 @limiter.limit("20/minute")
 async def start_processing(
-    file_id: int, request: Request, current_user: dict = Depends(get_current_user)
+    file_id: int,
+    request: Request,
+    current_user: dict = Depends(get_current_user),
 ):
     """Start processing job for uploaded file"""
     body = await request.json()
@@ -169,12 +211,16 @@ async def start_processing(
         json_data=body,
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @data_router.get("/jobs")
 @limiter.limit("30/minute")
-async def get_processing_jobs(request: Request, current_user: dict = Depends(get_current_user)):
+async def get_processing_jobs(
+    request: Request, current_user: dict = Depends(get_current_user)
+):
     """Get user's processing jobs"""
     result = await proxy.forward_request(
         service="data",
@@ -184,25 +230,38 @@ async def get_processing_jobs(request: Request, current_user: dict = Depends(get
         params=dict(request.query_params),
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @data_router.get("/jobs/{job_id}")
 @limiter.limit("30/minute")
 async def get_job_status(
-    job_id: int, request: Request, current_user: dict = Depends(get_current_user)
+    job_id: int,
+    request: Request,
+    current_user: dict = Depends(get_current_user),
 ):
     """Get processing job status"""
     result = await proxy.forward_request(
-        service="data", path=f"/api/v1/jobs/{job_id}", method="GET", headers=dict(request.headers)
+        service="data",
+        path=f"/api/v1/jobs/{job_id}",
+        method="GET",
+        headers=dict(request.headers),
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @data_router.delete("/jobs/{job_id}")
 @limiter.limit("10/minute")
-async def cancel_job(job_id: int, request: Request, current_user: dict = Depends(get_current_user)):
+async def cancel_job(
+    job_id: int,
+    request: Request,
+    current_user: dict = Depends(get_current_user),
+):
     """Cancel processing job"""
     result = await proxy.forward_request(
         service="data",
@@ -211,13 +270,17 @@ async def cancel_job(job_id: int, request: Request, current_user: dict = Depends
         headers=dict(request.headers),
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 # Inference routes
 @inference_router.post("/synthesize")
 @limiter.limit("20/minute")
-async def synthesize_voice(request: Request, current_user: dict = Depends(get_current_user)):
+async def synthesize_voice(
+    request: Request, current_user: dict = Depends(get_current_user)
+):
     """Synthesize voice from text"""
     body = await request.json()
     result = await proxy.forward_request(
@@ -228,12 +291,16 @@ async def synthesize_voice(request: Request, current_user: dict = Depends(get_cu
         json_data=body,
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @inference_router.post("/synthesize/batch")
 @limiter.limit("10/minute")
-async def batch_synthesize_voice(request: Request, current_user: dict = Depends(get_current_user)):
+async def batch_synthesize_voice(
+    request: Request, current_user: dict = Depends(get_current_user)
+):
     """Batch synthesize multiple texts"""
     body = await request.json()
     result = await proxy.forward_request(
@@ -244,13 +311,17 @@ async def batch_synthesize_voice(request: Request, current_user: dict = Depends(
         json_data=body,
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @inference_router.get("/synthesize/audio/{job_id}")
 @limiter.limit("30/minute")
 async def get_synthesis_audio(
-    job_id: int, request: Request, current_user: dict = Depends(get_current_user)
+    job_id: int,
+    request: Request,
+    current_user: dict = Depends(get_current_user),
 ):
     """Get synthesized audio file"""
     result = await proxy.forward_request(
@@ -260,12 +331,16 @@ async def get_synthesis_audio(
         headers=dict(request.headers),
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @inference_router.get("/jobs")
 @limiter.limit("30/minute")
-async def get_synthesis_jobs(request: Request, current_user: dict = Depends(get_current_user)):
+async def get_synthesis_jobs(
+    request: Request, current_user: dict = Depends(get_current_user)
+):
     """Get user's synthesis jobs"""
     result = await proxy.forward_request(
         service="inference",
@@ -275,13 +350,17 @@ async def get_synthesis_jobs(request: Request, current_user: dict = Depends(get_
         params=dict(request.query_params),
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @inference_router.get("/jobs/{job_id}")
 @limiter.limit("30/minute")
 async def get_synthesis_job(
-    job_id: int, request: Request, current_user: dict = Depends(get_current_user)
+    job_id: int,
+    request: Request,
+    current_user: dict = Depends(get_current_user),
 ):
     """Get synthesis job details"""
     result = await proxy.forward_request(
@@ -291,12 +370,16 @@ async def get_synthesis_job(
         headers=dict(request.headers),
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @inference_router.get("/models")
 @limiter.limit("30/minute")
-async def get_available_models(request: Request, current_user: dict = Depends(get_current_user)):
+async def get_available_models(
+    request: Request, current_user: dict = Depends(get_current_user)
+):
     """Get available voice models for user"""
     result = await proxy.forward_request(
         service="inference",
@@ -306,12 +389,16 @@ async def get_available_models(request: Request, current_user: dict = Depends(ge
         params=dict(request.query_params),
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @inference_router.get("/models/ready")
 @limiter.limit("30/minute")
-async def get_ready_models(request: Request, current_user: dict = Depends(get_current_user)):
+async def get_ready_models(
+    request: Request, current_user: dict = Depends(get_current_user)
+):
     """Get ready-to-use voice models"""
     result = await proxy.forward_request(
         service="inference",
@@ -320,13 +407,17 @@ async def get_ready_models(request: Request, current_user: dict = Depends(get_cu
         headers=dict(request.headers),
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @inference_router.get("/models/{model_id}")
 @limiter.limit("30/minute")
 async def get_model_details(
-    model_id: int, request: Request, current_user: dict = Depends(get_current_user)
+    model_id: int,
+    request: Request,
+    current_user: dict = Depends(get_current_user),
 ):
     """Get voice model details"""
     result = await proxy.forward_request(
@@ -336,13 +427,17 @@ async def get_model_details(
         headers=dict(request.headers),
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 @inference_router.post("/models/{model_id}/preload")
 @limiter.limit("10/minute")
 async def preload_model(
-    model_id: int, request: Request, current_user: dict = Depends(get_current_user)
+    model_id: int,
+    request: Request,
+    current_user: dict = Depends(get_current_user),
 ):
     """Preload model into cache"""
     result = await proxy.forward_request(
@@ -352,7 +447,9 @@ async def preload_model(
         headers=dict(request.headers),
     )
 
-    return JSONResponse(status_code=result["status_code"], content=result["data"])
+    return JSONResponse(
+        status_code=result["status_code"], content=result["data"]
+    )
 
 
 # Admin routes
diff --git a/services/auth-service/app/config.py b/services/auth-service/app/config.py
index 6e13b22..b0704b5 100644
--- a/services/auth-service/app/config.py
+++ b/services/auth-service/app/config.py
@@ -4,7 +4,9 @@ from typing import List
 
 class Settings(BaseSettings):
     # Database
-    database_url: str = "postgresql://voiceclone_user:password@postgres:5432/voiceclone_db"
+    database_url: str = (
+        "postgresql://voiceclone_user:password@postgres:5432/voiceclone_db"
+    )
 
     # JWT
     jwt_secret_key: str = "your-secret-key-change-in-production"
@@ -18,7 +20,10 @@ class Settings(BaseSettings):
 
     # CORS
     allowed_hosts: List[str] = ["localhost", "127.0.0.1"]
-    cors_origins: List[str] = ["http://localhost:3000", "http://localhost:5173"]
+    cors_origins: List[str] = [
+        "http://localhost:3000",
+        "http://localhost:5173",
+    ]
 
     # Logging
     log_level: str = "INFO"
diff --git a/services/auth-service/app/crud.py b/services/auth-service/app/crud.py
index 0e9ffbb..6abfb1e 100644
--- a/services/auth-service/app/crud.py
+++ b/services/auth-service/app/crud.py
@@ -17,7 +17,9 @@ def get_user_by_email(db: Session, email: str) -> Optional[models.User]:
 
 def get_user_by_username(db: Session, username: str) -> Optional[models.User]:
     """Get user by username"""
-    return db.query(models.User).filter(models.User.username == username).first()
+    return (
+        db.query(models.User).filter(models.User.username == username).first()
+    )
 
 
 def get_users(db: Session, skip: int = 0, limit: int = 100):
@@ -70,7 +72,9 @@ def delete_user(db: Session, user_id: int) -> bool:
     return True
 
 
-def authenticate_user(db: Session, email: str, password: str) -> Optional[models.User]:
+def authenticate_user(
+    db: Session, email: str, password: str
+) -> Optional[models.User]:
     """Authenticate user with email and password"""
     user = get_user_by_email(db, email)
     if not user:
@@ -107,7 +111,9 @@ def increment_api_calls(db: Session, user_id: int) -> None:
         db.commit()
 
 
-def check_user_exists(db: Session, email: str = None, username: str = None) -> bool:
+def check_user_exists(
+    db: Session, email: str = None, username: str = None
+) -> bool:
     """Check if user exists by email or username"""
     query = db.query(models.User)
 
diff --git a/services/auth-service/app/database.py b/services/auth-service/app/database.py
index a72d8fd..20d2099 100644
--- a/services/auth-service/app/database.py
+++ b/services/auth-service/app/database.py
@@ -4,7 +4,10 @@ from sqlalchemy.orm import sessionmaker
 from .config import settings
 
 engine = create_engine(
-    settings.database_url, pool_pre_ping=True, pool_recycle=300, echo=settings.debug
+    settings.database_url,
+    pool_pre_ping=True,
+    pool_recycle=300,
+    echo=settings.debug,
 )
 
 SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
diff --git a/services/auth-service/app/dependencies.py b/services/auth-service/app/dependencies.py
index 72873a9..6f8fb4f 100644
--- a/services/auth-service/app/dependencies.py
+++ b/services/auth-service/app/dependencies.py
@@ -36,12 +36,17 @@ def get_current_user(
 def get_current_active_user(current_user=Depends(get_current_user)):
     """Get current active user"""
     if not current_user.is_active:
-        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
+        raise HTTPException(
+            status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user"
+        )
     return current_user
 
 
 def get_current_superuser(current_user=Depends(get_current_user)):
     """Get current superuser"""
     if not current_user.is_superuser:
-        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not enough permissions")
+        raise HTTPException(
+            status_code=status.HTTP_403_FORBIDDEN,
+            detail="Not enough permissions",
+        )
     return current_user
diff --git a/services/auth-service/app/routers.py b/services/auth-service/app/routers.py
index 6172676..b7c484f 100644
--- a/services/auth-service/app/routers.py
+++ b/services/auth-service/app/routers.py
@@ -5,28 +5,41 @@ from typing import List
 
 from . import crud, schemas, security
 from .database import get_db
-from .dependencies import get_current_user, get_current_active_user, get_current_superuser
+from .dependencies import (
+    get_current_user,
+    get_current_active_user,
+    get_current_superuser,
+)
 from .config import settings
 
 router = APIRouter()
 
 
-@router.post("/register", response_model=schemas.User, status_code=status.HTTP_201_CREATED)
+@router.post(
+    "/register",
+    response_model=schemas.User,
+    status_code=status.HTTP_201_CREATED,
+)
 def register_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
     """Register a new user"""
     # Check if user already exists
     if crud.check_user_exists(db, email=user.email, username=user.username):
         raise HTTPException(
-            status_code=status.HTTP_400_BAD_REQUEST, detail="Email or username already registered"
+            status_code=status.HTTP_400_BAD_REQUEST,
+            detail="Email or username already registered",
         )
 
     return crud.create_user(db=db, user=user)
 
 
 @router.post("/login", response_model=schemas.Token)
-def login_user(user_credentials: schemas.UserLogin, db: Session = Depends(get_db)):
+def login_user(
+    user_credentials: schemas.UserLogin, db: Session = Depends(get_db)
+):
     """Login user and return access token"""
-    user = crud.authenticate_user(db, user_credentials.email, user_credentials.password)
+    user = crud.authenticate_user(
+        db, user_credentials.email, user_credentials.password
+    )
     if not user:
         raise HTTPException(
             status_code=status.HTTP_401_UNAUTHORIZED,
@@ -35,13 +48,17 @@ def login_user(user_credentials: schemas.UserLogin, db: Session = Depends(get_db
         )
 
     if not user.is_active:
-        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
+        raise HTTPException(
+            status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user"
+        )
 
     # Update last login
     crud.update_last_login(db, user.id)
 
     # Create access token
-    access_token_expires = timedelta(minutes=settings.jwt_access_token_expire_minutes)
+    access_token_expires = timedelta(
+        minutes=settings.jwt_access_token_expire_minutes
+    )
     access_token = security.create_access_token(
         data={"sub": user.email}, expires_delta=access_token_expires
     )
@@ -71,13 +88,15 @@ def update_user_me(
     if user_update.email and user_update.email != current_user.email:
         if crud.get_user_by_email(db, user_update.email):
             raise HTTPException(
-                status_code=status.HTTP_400_BAD_REQUEST, detail="Email already registered"
+                status_code=status.HTTP_400_BAD_REQUEST,
+                detail="Email already registered",
             )
 
     if user_update.username and user_update.username != current_user.username:
         if crud.get_user_by_username(db, user_update.username):
             raise HTTPException(
-                status_code=status.HTTP_400_BAD_REQUEST, detail="Username already taken"
+                status_code=status.HTTP_400_BAD_REQUEST,
+                detail="Username already taken",
             )
 
     updated_user = crud.update_user(db, current_user.id, user_update)
@@ -92,28 +111,38 @@ def change_password(
 ):
     """Change user password"""
     # Verify current password
-    if not security.verify_password(password_change.current_password, current_user.hashed_password):
+    if not security.verify_password(
+        password_change.current_password, current_user.hashed_password
+    ):
         raise HTTPException(
-            status_code=status.HTTP_400_BAD_REQUEST, detail="Incorrect current password"
+            status_code=status.HTTP_400_BAD_REQUEST,
+            detail="Incorrect current password",
         )
 
     # Update password
-    success = crud.update_user_password(db, current_user.id, password_change.new_password)
+    success = crud.update_user_password(
+        db, current_user.id, password_change.new_password
+    )
     if not success:
         raise HTTPException(
-            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update password"
+            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
+            detail="Failed to update password",
         )
 
     return {"message": "Password updated successfully"}
 
 
 @router.post("/password-reset")
-def request_password_reset(password_reset: schemas.PasswordReset, db: Session = Depends(get_db)):
+def request_password_reset(
+    password_reset: schemas.PasswordReset, db: Session = Depends(get_db)
+):
     """Request password reset token"""
     user = crud.get_user_by_email(db, password_reset.email)
     if not user:
         # Don't reveal if email exists or not
-        return {"message": "If the email exists, a password reset link has been sent"}
+        return {
+            "message": "If the email exists, a password reset link has been sent"
+        }
 
     reset_token = security.create_password_reset_token(user.email)
 
@@ -127,24 +156,31 @@ def request_password_reset(password_reset: schemas.PasswordReset, db: Session =
 
 @router.post("/password-reset-confirm")
 def confirm_password_reset(
-    password_reset_confirm: schemas.PasswordResetConfirm, db: Session = Depends(get_db)
+    password_reset_confirm: schemas.PasswordResetConfirm,
+    db: Session = Depends(get_db),
 ):
     """Confirm password reset with token"""
     email = security.verify_password_reset_token(password_reset_confirm.token)
     if not email:
         raise HTTPException(
-            status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid or expired reset token"
+            status_code=status.HTTP_400_BAD_REQUEST,
+            detail="Invalid or expired reset token",
         )
 
     user = crud.get_user_by_email(db, email)
     if not user:
-        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
+        )
 
     # Update password
-    success = crud.update_user_password(db, user.id, password_reset_confirm.new_password)
+    success = crud.update_user_password(
+        db, user.id, password_reset_confirm.new_password
+    )
     if not success:
         raise HTTPException(
-            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update password"
+            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
+            detail="Failed to update password",
         )
 
     return {"message": "Password reset successfully"}
@@ -165,21 +201,29 @@ def read_users(
 
 @router.get("/users/{user_id}", response_model=schemas.User)
 def read_user(
-    user_id: int, current_user=Depends(get_current_superuser), db: Session = Depends(get_db)
+    user_id: int,
+    current_user=Depends(get_current_superuser),
+    db: Session = Depends(get_db),
 ):
     """Get user by ID (admin only)"""
     user = crud.get_user(db, user_id=user_id)
     if user is None:
-        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
+        )
     return user
 
 
 @router.delete("/users/{user_id}")
 def delete_user(
-    user_id: int, current_user=Depends(get_current_superuser), db: Session = Depends(get_db)
+    user_id: int,
+    current_user=Depends(get_current_superuser),
+    db: Session = Depends(get_db),
 ):
     """Delete user (admin only)"""
     success = crud.delete_user(db, user_id)
     if not success:
-        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
+        )
     return {"message": "User deleted successfully"}
diff --git a/services/auth-service/app/schemas.py b/services/auth-service/app/schemas.py
index ce8fb33..7ce120f 100644
--- a/services/auth-service/app/schemas.py
+++ b/services/auth-service/app/schemas.py
@@ -25,7 +25,9 @@ class UserCreate(UserBase):
         if len(v) < 3:
             raise ValueError("Username must be at least 3 characters long")
         if not v.isalnum():
-            raise ValueError("Username must contain only alphanumeric characters")
+            raise ValueError(
+                "Username must contain only alphanumeric characters"
+            )
         return v.lower()
 
 
@@ -41,7 +43,9 @@ class UserUpdate(BaseModel):
         if v and len(v) < 3:
             raise ValueError("Username must be at least 3 characters long")
         if v and not v.isalnum():
-            raise ValueError("Username must contain only alphanumeric characters")
+            raise ValueError(
+                "Username must contain only alphanumeric characters"
+            )
         return v.lower() if v else v
 
 
diff --git a/services/auth-service/app/security.py b/services/auth-service/app/security.py
index 53b9808..e3b50e8 100644
--- a/services/auth-service/app/security.py
+++ b/services/auth-service/app/security.py
@@ -19,23 +19,31 @@ def get_password_hash(password: str) -> str:
     return pwd_context.hash(password)
 
 
-def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
+def create_access_token(
+    data: dict, expires_delta: Optional[timedelta] = None
+) -> str:
     """Create JWT access token"""
     to_encode = data.copy()
     if expires_delta:
         expire = datetime.utcnow() + expires_delta
     else:
-        expire = datetime.utcnow() + timedelta(minutes=settings.jwt_access_token_expire_minutes)
+        expire = datetime.utcnow() + timedelta(
+            minutes=settings.jwt_access_token_expire_minutes
+        )
 
     to_encode.update({"exp": expire})
-    encoded_jwt = jwt.encode(to_encode, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)
+    encoded_jwt = jwt.encode(
+        to_encode, settings.jwt_secret_key, algorithm=settings.jwt_algorithm
+    )
     return encoded_jwt
 
 
 def verify_token(token: str) -> Optional[str]:
     """Verify JWT token and return email"""
     try:
-        payload = jwt.decode(token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm])
+        payload = jwt.decode(
+            token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm]
+        )
         email: str = payload.get("sub")
         if email is None:
             return None
@@ -47,14 +55,18 @@ def verify_token(token: str) -> Optional[str]:
 def create_password_reset_token(email: str) -> str:
     """Create password reset token"""
     data = {"sub": email, "type": "password_reset"}
-    expires_delta = timedelta(hours=1)  # Password reset tokens expire in 1 hour
+    expires_delta = timedelta(
+        hours=1
+    )  # Password reset tokens expire in 1 hour
     return create_access_token(data, expires_delta)
 
 
 def verify_password_reset_token(token: str) -> Optional[str]:
     """Verify password reset token"""
     try:
-        payload = jwt.decode(token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm])
+        payload = jwt.decode(
+            token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm]
+        )
         email: str = payload.get("sub")
         token_type: str = payload.get("type")
         if email is None or token_type != "password_reset":
diff --git a/services/auth-service/tests/conftest.py b/services/auth-service/tests/conftest.py
index b1aa7cb..97106d9 100644
--- a/services/auth-service/tests/conftest.py
+++ b/services/auth-service/tests/conftest.py
@@ -17,7 +17,9 @@ engine = create_engine(
     poolclass=StaticPool,
 )
 
-TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
+TestingSessionLocal = sessionmaker(
+    autocommit=False, autoflush=False, bind=engine
+)
 
 
 def override_get_db():
diff --git a/services/auth-service/tests/test_auth.py b/services/auth-service/tests/test_auth.py
index fc239fd..1346b87 100644
--- a/services/auth-service/tests/test_auth.py
+++ b/services/auth-service/tests/test_auth.py
@@ -18,7 +18,9 @@ class TestUserRegistration:
         assert "id" in data
         assert "hashed_password" not in data
 
-    def test_register_user_duplicate_email(self, client: TestClient, sample_user_data):
+    def test_register_user_duplicate_email(
+        self, client: TestClient, sample_user_data
+    ):
         """Test registration with duplicate email"""
         # Register first user
         client.post("/api/v1/register", json=sample_user_data)
@@ -31,7 +33,9 @@ class TestUserRegistration:
         assert response.status_code == 400
         assert "already registered" in response.json()["detail"]
 
-    def test_register_user_duplicate_username(self, client: TestClient, sample_user_data):
+    def test_register_user_duplicate_username(
+        self, client: TestClient, sample_user_data
+    ):
         """Test registration with duplicate username"""
         # Register first user
         client.post("/api/v1/register", json=sample_user_data)
@@ -44,7 +48,9 @@ class TestUserRegistration:
         assert response.status_code == 400
         assert "already registered" in response.json()["detail"]
 
-    def test_register_user_invalid_password(self, client: TestClient, sample_user_data):
+    def test_register_user_invalid_password(
+        self, client: TestClient, sample_user_data
+    ):
         """Test registration with invalid password"""
         invalid_data = sample_user_data.copy()
         invalid_data["password"] = "123"  # Too short
@@ -62,7 +68,10 @@ class TestUserLogin:
         client.post("/api/v1/register", json=sample_user_data)
 
         # Login
-        login_data = {"email": sample_user_data["email"], "password": sample_user_data["password"]}
+        login_data = {
+            "email": sample_user_data["email"],
+            "password": sample_user_data["password"],
+        }
         response = client.post("/api/v1/login", json=login_data)
 
         assert response.status_code == 200
@@ -73,19 +82,27 @@ class TestUserLogin:
 
     def test_login_invalid_email(self, client: TestClient, sample_user_data):
         """Test login with invalid email"""
-        login_data = {"email": "nonexistent@example.com", "password": "somepassword"}
+        login_data = {
+            "email": "nonexistent@example.com",
+            "password": "somepassword",
+        }
         response = client.post("/api/v1/login", json=login_data)
 
         assert response.status_code == 401
         assert "Incorrect email or password" in response.json()["detail"]
 
-    def test_login_invalid_password(self, client: TestClient, sample_user_data):
+    def test_login_invalid_password(
+        self, client: TestClient, sample_user_data
+    ):
         """Test login with invalid password"""
         # Register user
         client.post("/api/v1/register", json=sample_user_data)
 
         # Try login with wrong password
-        login_data = {"email": sample_user_data["email"], "password": "wrongpassword"}
+        login_data = {
+            "email": sample_user_data["email"],
+            "password": "wrongpassword",
+        }
         response = client.post("/api/v1/login", json=login_data)
 
         assert response.status_code == 401
@@ -101,12 +118,17 @@ class TestUserProfile:
         client.post("/api/v1/register", json=sample_user_data)
         login_response = client.post(
             "/api/v1/login",
-            json={"email": sample_user_data["email"], "password": sample_user_data["password"]},
+            json={
+                "email": sample_user_data["email"],
+                "password": sample_user_data["password"],
+            },
         )
         token = login_response.json()["access_token"]
 
         # Get profile
-        response = client.get("/api/v1/me", headers={"Authorization": f"Bearer {token}"})
+        response = client.get(
+            "/api/v1/me", headers={"Authorization": f"Bearer {token}"}
+        )
 
         assert response.status_code == 200
         data = response.json()
@@ -120,7 +142,9 @@ class TestUserProfile:
 
     def test_get_current_user_invalid_token(self, client: TestClient):
         """Test getting current user with invalid token"""
-        response = client.get("/api/v1/me", headers={"Authorization": "Bearer invalid-token"})
+        response = client.get(
+            "/api/v1/me", headers={"Authorization": "Bearer invalid-token"}
+        )
         assert response.status_code == 401
 
     def test_update_user_profile(self, client: TestClient, sample_user_data):
@@ -129,14 +153,19 @@ class TestUserProfile:
         client.post("/api/v1/register", json=sample_user_data)
         login_response = client.post(
             "/api/v1/login",
-            json={"email": sample_user_data["email"], "password": sample_user_data["password"]},
+            json={
+                "email": sample_user_data["email"],
+                "password": sample_user_data["password"],
+            },
         )
         token = login_response.json()["access_token"]
 
         # Update profile
         update_data = {"full_name": "Updated Name", "bio": "This is my bio"}
         response = client.put(
-            "/api/v1/me", json=update_data, headers={"Authorization": f"Bearer {token}"}
+            "/api/v1/me",
+            json=update_data,
+            headers={"Authorization": f"Bearer {token}"},
         )
 
         assert response.status_code == 200
@@ -148,13 +177,18 @@ class TestUserProfile:
 class TestPasswordManagement:
     """Test password management functionality"""
 
-    def test_change_password_success(self, client: TestClient, sample_user_data):
+    def test_change_password_success(
+        self, client: TestClient, sample_user_data
+    ):
         """Test successful password change"""
         # Register and login
         client.post("/api/v1/register", json=sample_user_data)
         login_response = client.post(
             "/api/v1/login",
-            json={"email": sample_user_data["email"], "password": sample_user_data["password"]},
+            json={
+                "email": sample_user_data["email"],
+                "password": sample_user_data["password"],
+            },
         )
         token = login_response.json()["access_token"]
 
@@ -174,17 +208,26 @@ class TestPasswordManagement:
 
         # Test login with new password
         login_response = client.post(
-            "/api/v1/login", json={"email": sample_user_data["email"], "password": "newpassword123"}
+            "/api/v1/login",
+            json={
+                "email": sample_user_data["email"],
+                "password": "newpassword123",
+            },
         )
         assert login_response.status_code == 200
 
-    def test_change_password_wrong_current(self, client: TestClient, sample_user_data):
+    def test_change_password_wrong_current(
+        self, client: TestClient, sample_user_data
+    ):
         """Test password change with wrong current password"""
         # Register and login
         client.post("/api/v1/register", json=sample_user_data)
         login_response = client.post(
             "/api/v1/login",
-            json={"email": sample_user_data["email"], "password": sample_user_data["password"]},
+            json={
+                "email": sample_user_data["email"],
+                "password": sample_user_data["password"],
+            },
         )
         token = login_response.json()["access_token"]
 
diff --git a/services/data-ingestion/main.py b/services/data-ingestion/main.py
index 225c0d1..f4db433 100644
--- a/services/data-ingestion/main.py
+++ b/services/data-ingestion/main.py
@@ -58,18 +58,28 @@ class IngestionResult(BaseModel):
 @app.get("/health")
 async def health_check():
     """Health check endpoint"""
-    return {"status": "healthy", "service": "data-ingestion", "timestamp": datetime.utcnow()}
+    return {
+        "status": "healthy",
+        "service": "data-ingestion",
+        "timestamp": datetime.utcnow(),
+    }
 
 
 @app.post("/api/v1/ingest/trends", response_model=IngestionResult)
-async def ingest_trends(request: IngestionRequest, background_tasks: BackgroundTasks):
+async def ingest_trends(
+    request: IngestionRequest, background_tasks: BackgroundTasks
+):
     """Ingest trending data from social platforms"""
 
     try:
-        logger.info(f"Starting trend ingestion for platform: {request.platform}")
+        logger.info(
+            f"Starting trend ingestion for platform: {request.platform}"
+        )
 
         # Start background ingestion task
-        background_tasks.add_task(process_trend_ingestion, request.platform, request.parameters)
+        background_tasks.add_task(
+            process_trend_ingestion, request.platform, request.parameters
+        )
 
         return IngestionResult(
             success=True,
@@ -84,13 +94,19 @@ async def ingest_trends(request: IngestionRequest, background_tasks: BackgroundT
 
 
 @app.post("/api/v1/ingest/keywords", response_model=IngestionResult)
-async def ingest_keywords(request: IngestionRequest, background_tasks: BackgroundTasks):
+async def ingest_keywords(
+    request: IngestionRequest, background_tasks: BackgroundTasks
+):
     """Ingest keyword data and performance metrics"""
 
     try:
-        logger.info(f"Starting keyword ingestion for platform: {request.platform}")
+        logger.info(
+            f"Starting keyword ingestion for platform: {request.platform}"
+        )
 
-        background_tasks.add_task(process_keyword_ingestion, request.platform, request.parameters)
+        background_tasks.add_task(
+            process_keyword_ingestion, request.platform, request.parameters
+        )
 
         return IngestionResult(
             success=True,
@@ -142,7 +158,9 @@ async def process_trend_ingestion(platform: str, parameters: Dict[str, Any]):
         # Store trends in database
         await store_trends_in_database(platform, trends)
 
-        logger.info(f"Successfully ingested {len(trends)} trends for {platform}")
+        logger.info(
+            f"Successfully ingested {len(trends)} trends for {platform}"
+        )
 
     except Exception as e:
         logger.error(f"Trend ingestion failed for {platform}: {str(e)}")
@@ -162,7 +180,9 @@ async def process_keyword_ingestion(platform: str, parameters: Dict[str, Any]):
         # Store in database
         await store_keywords_in_database(platform, keyword_metrics)
 
-        logger.info(f"Successfully ingested {len(keywords)} keywords for {platform}")
+        logger.info(
+            f"Successfully ingested {len(keywords)} keywords for {platform}"
+        )
 
     except Exception as e:
         logger.error(f"Keyword ingestion failed for {platform}: {str(e)}")
@@ -191,7 +211,9 @@ async def ingest_youtube_trends(parameters: Dict[str, Any]) -> List[TrendData]:
     return trends
 
 
-async def ingest_instagram_trends(parameters: Dict[str, Any]) -> List[TrendData]:
+async def ingest_instagram_trends(
+    parameters: Dict[str, Any],
+) -> List[TrendData]:
     """Ingest trending data from Instagram"""
 
     trends = []
@@ -202,7 +224,9 @@ async def ingest_instagram_trends(parameters: Dict[str, Any]) -> List[TrendData]
     return trends
 
 
-async def fetch_trending_keywords(platform: str, parameters: Dict[str, Any]) -> List[str]:
+async def fetch_trending_keywords(
+    platform: str, parameters: Dict[str, Any]
+) -> List[str]:
     """Fetch trending keywords for a platform"""
 
     # Placeholder implementation
@@ -222,7 +246,11 @@ async def analyze_keyword_performance(keywords: List[str]) -> Dict[str, Any]:
 
     # Placeholder - would use analytics APIs
     metrics = {
-        keyword: {"search_volume": 1000, "competition": 0.5, "trend_score": 0.8}
+        keyword: {
+            "search_volume": 1000,
+            "competition": 0.5,
+            "trend_score": 0.8,
+        }
         for keyword in keywords
     }
 
@@ -236,14 +264,18 @@ async def store_trends_in_database(platform: str, trends: List[TrendData]):
     logger.info(f"Storing {len(trends)} trends for {platform} in database")
 
 
-async def store_keywords_in_database(platform: str, keyword_metrics: Dict[str, Any]):
+async def store_keywords_in_database(
+    platform: str, keyword_metrics: Dict[str, Any]
+):
     """Store keyword metrics in database"""
 
     # Placeholder - would use database connection
     logger.info(f"Storing keyword metrics for {platform} in database")
 
 
-async def fetch_trends_from_database(platform: str, limit: int) -> List[Dict[str, Any]]:
+async def fetch_trends_from_database(
+    platform: str, limit: int
+) -> List[Dict[str, Any]]:
     """Fetch trends from database"""
 
     # Placeholder - would query database
diff --git a/services/data-service/app/audio_validator.py b/services/data-service/app/audio_validator.py
index a00c35b..0731cdc 100644
--- a/services/data-service/app/audio_validator.py
+++ b/services/data-service/app/audio_validator.py
@@ -21,7 +21,9 @@ class AudioValidator:
         self.min_duration = settings.min_duration
         self.max_duration = settings.max_duration
 
-    async def validate_file_upload(self, file_path: str, original_filename: str) -> Dict[str, Any]:
+    async def validate_file_upload(
+        self, file_path: str, original_filename: str
+    ) -> Dict[str, Any]:
         """
         Comprehensive file validation
         Returns metadata dict or raises FileValidationError
@@ -29,14 +31,19 @@ class AudioValidator:
         try:
             # Check file exists
             if not os.path.exists(file_path):
-                raise FileValidationError(error="File not found", details={"file_path": file_path})
+                raise FileValidationError(
+                    error="File not found", details={"file_path": file_path}
+                )
 
             # Check file size
             file_size = os.path.getsize(file_path)
             if file_size > self.max_file_size:
                 raise FileValidationError(
                     error="File too large",
-                    details={"file_size": file_size, "max_size": self.max_file_size},
+                    details={
+                        "file_size": file_size,
+                        "max_size": self.max_file_size,
+                    },
                 )
 
             # Check file format by extension
@@ -44,7 +51,10 @@ class AudioValidator:
             if file_extension not in self.allowed_formats:
                 raise FileValidationError(
                     error="Unsupported file format",
-                    details={"format": file_extension, "allowed_formats": self.allowed_formats},
+                    details={
+                        "format": file_extension,
+                        "allowed_formats": self.allowed_formats,
+                    },
                 )
 
             # Validate MIME type
@@ -69,7 +79,11 @@ class AudioValidator:
                 "validation_passed": True,
             }
 
-            logger.info("File validation successful", filename=original_filename, metadata=metadata)
+            logger.info(
+                "File validation successful",
+                filename=original_filename,
+                metadata=metadata,
+            )
 
             return metadata
 
@@ -77,9 +91,13 @@ class AudioValidator:
             raise
         except Exception as e:
             logger.error(
-                "Unexpected error during file validation", filename=original_filename, error=str(e)
+                "Unexpected error during file validation",
+                filename=original_filename,
+                error=str(e),
+            )
+            raise FileValidationError(
+                error="Validation failed", details={"error": str(e)}
             )
-            raise FileValidationError(error="Validation failed", details={"error": str(e)})
 
     async def _analyze_audio(self, file_path: str) -> Dict[str, Any]:
         """Analyze audio file properties using librosa"""
@@ -93,12 +111,18 @@ class AudioValidator:
 
             # Audio quality analysis
             rms_energy = float(librosa.feature.rms(y=y).mean())
-            spectral_centroid = float(librosa.feature.spectral_centroid(y=y, sr=sr).mean())
-            zero_crossing_rate = float(librosa.feature.zero_crossing_rate(y).mean())
+            spectral_centroid = float(
+                librosa.feature.spectral_centroid(y=y, sr=sr).mean()
+            )
+            zero_crossing_rate = float(
+                librosa.feature.zero_crossing_rate(y).mean()
+            )
 
             # Silence detection
             silence_threshold = 0.01
-            silence_ratio = float((librosa.util.normalize(y) < silence_threshold).mean())
+            silence_ratio = float(
+                (librosa.util.normalize(y) < silence_threshold).mean()
+            )
 
             return {
                 "duration": duration,
@@ -113,7 +137,9 @@ class AudioValidator:
 
         except Exception as e:
             logger.warning(
-                "Audio analysis failed, using basic file info", file_path=file_path, error=str(e)
+                "Audio analysis failed, using basic file info",
+                file_path=file_path,
+                error=str(e),
             )
 
             # Fallback to basic file info
@@ -134,30 +160,40 @@ class AudioValidator:
                     error=str(fallback_error),
                 )
                 raise FileValidationError(
-                    error="Unable to analyze audio file", details={"error": str(fallback_error)}
+                    error="Unable to analyze audio file",
+                    details={"error": str(fallback_error)},
                 )
 
-    def _validate_audio_properties(self, audio_metadata: Dict[str, Any]) -> None:
+    def _validate_audio_properties(
+        self, audio_metadata: Dict[str, Any]
+    ) -> None:
         """Validate audio properties against requirements"""
         duration = audio_metadata.get("duration", 0)
 
         if duration < self.min_duration:
             raise FileValidationError(
                 error="Audio too short",
-                details={"duration": duration, "min_duration": self.min_duration},
+                details={
+                    "duration": duration,
+                    "min_duration": self.min_duration,
+                },
             )
 
         if duration > self.max_duration:
             raise FileValidationError(
                 error="Audio too long",
-                details={"duration": duration, "max_duration": self.max_duration},
+                details={
+                    "duration": duration,
+                    "max_duration": self.max_duration,
+                },
             )
 
         # Check for excessive silence
         silence_ratio = audio_metadata.get("silence_ratio", 0)
         if silence_ratio > 0.8:  # More than 80% silence
             raise FileValidationError(
-                error="Audio contains too much silence", details={"silence_ratio": silence_ratio}
+                error="Audio contains too much silence",
+                details={"silence_ratio": silence_ratio},
             )
 
         # Check for very low energy (likely corrupt or empty)
@@ -189,8 +225,12 @@ class AudioValidator:
         self, audio_metadata: Dict[str, Any]
     ) -> Dict[str, Any]:
         """Determine optimal preprocessing parameters based on audio analysis"""
-        current_sr = audio_metadata.get("sample_rate", settings.target_sample_rate)
-        current_channels = audio_metadata.get("channels", settings.target_channels)
+        current_sr = audio_metadata.get(
+            "sample_rate", settings.target_sample_rate
+        )
+        current_channels = audio_metadata.get(
+            "channels", settings.target_channels
+        )
 
         # Determine if resampling is needed
         needs_resampling = current_sr != settings.target_sample_rate
@@ -221,7 +261,8 @@ class AudioValidator:
             "preprocessing_steps": preprocessing_steps,
             "needs_resampling": needs_resampling,
             "needs_channel_conversion": needs_channel_conversion,
-            "estimated_processing_time": len(preprocessing_steps) * 2,  # rough estimate in seconds
+            "estimated_processing_time": len(preprocessing_steps)
+            * 2,  # rough estimate in seconds
         }
 
 
diff --git a/services/data-service/app/auth.py b/services/data-service/app/auth.py
index cbed3d1..ea05ee2 100644
--- a/services/data-service/app/auth.py
+++ b/services/data-service/app/auth.py
@@ -12,7 +12,8 @@ async def get_current_user(token: str) -> int:
     try:
         async with httpx.AsyncClient() as client:
             response = await client.get(
-                f"{AUTH_SERVICE_URL}/api/v1/me", headers={"Authorization": f"Bearer {token}"}
+                f"{AUTH_SERVICE_URL}/api/v1/me",
+                headers={"Authorization": f"Bearer {token}"},
             )
 
             if response.status_code == 200:
@@ -23,13 +24,21 @@ async def get_current_user(token: str) -> int:
             elif response.status_code == 403:
                 raise HTTPException(status_code=403, detail="Token required")
             else:
-                raise HTTPException(status_code=401, detail="Authentication failed")
+                raise HTTPException(
+                    status_code=401, detail="Authentication failed"
+                )
 
     except httpx.RequestError as e:
         logger.error("Failed to verify token with auth service", error=str(e))
-        raise HTTPException(status_code=503, detail="Authentication service unavailable")
+        raise HTTPException(
+            status_code=503, detail="Authentication service unavailable"
+        )
     except HTTPException:
         raise
     except Exception as e:
-        logger.error("Unexpected error during token verification", error=str(e))
-        raise HTTPException(status_code=500, detail="Internal authentication error")
+        logger.error(
+            "Unexpected error during token verification", error=str(e)
+        )
+        raise HTTPException(
+            status_code=500, detail="Internal authentication error"
+        )
diff --git a/services/data-service/app/celery_tasks.py b/services/data-service/app/celery_tasks.py
index 8423134..b4a5bbc 100644
--- a/services/data-service/app/celery_tasks.py
+++ b/services/data-service/app/celery_tasks.py
@@ -15,7 +15,11 @@ logger = structlog.get_logger(__name__)
 
 @app.task(bind=True)
 def start_preprocessing_task(
-    self, job_id: int, file_id: int, s3_key: str, preprocessing_params: Dict[str, Any]
+    self,
+    job_id: int,
+    file_id: int,
+    s3_key: str,
+    preprocessing_params: Dict[str, Any],
 ):
     """Celery task for audio preprocessing"""
 
@@ -23,7 +27,12 @@ def start_preprocessing_task(
     asyncio.run(update_job_status(job_id, "running", 0))
 
     try:
-        logger.info("Starting audio preprocessing", job_id=job_id, file_id=file_id, s3_key=s3_key)
+        logger.info(
+            "Starting audio preprocessing",
+            job_id=job_id,
+            file_id=file_id,
+            s3_key=s3_key,
+        )
 
         # Download file from S3
         local_filename = f"temp_{job_id}_{file_id}.wav"
@@ -38,8 +47,12 @@ def start_preprocessing_task(
 
         # Apply preprocessing steps
         processed_audio = y
-        target_sr = preprocessing_params.get("target_sample_rate", settings.target_sample_rate)
-        target_channels = preprocessing_params.get("target_channels", settings.target_channels)
+        target_sr = preprocessing_params.get(
+            "target_sample_rate", settings.target_sample_rate
+        )
+        target_channels = preprocessing_params.get(
+            "target_channels", settings.target_channels
+        )
         steps = preprocessing_params.get("preprocessing_steps", [])
 
         step_progress = 40
@@ -47,9 +60,13 @@ def start_preprocessing_task(
 
         for step in steps:
             if step == "resample" and sr != target_sr:
-                processed_audio = librosa.resample(processed_audio, orig_sr=sr, target_sr=target_sr)
+                processed_audio = librosa.resample(
+                    processed_audio, orig_sr=sr, target_sr=target_sr
+                )
                 sr = target_sr
-                logger.info("Audio resampled", job_id=job_id, target_sr=target_sr)
+                logger.info(
+                    "Audio resampled", job_id=job_id, target_sr=target_sr
+                )
 
             elif step == "channel_conversion":
                 if processed_audio.ndim > 1 and target_channels == 1:
@@ -58,7 +75,9 @@ def start_preprocessing_task(
 
             elif step == "silence_removal":
                 # Trim silence from beginning and end
-                processed_audio, _ = librosa.effects.trim(processed_audio, top_db=20)
+                processed_audio, _ = librosa.effects.trim(
+                    processed_audio, top_db=20
+                )
                 logger.info("Silence trimmed", job_id=job_id)
 
             elif step == "normalize":
@@ -114,11 +133,16 @@ def start_preprocessing_task(
     except Exception as e:
         error_message = str(e)
         logger.error(
-            "Audio preprocessing failed", job_id=job_id, file_id=file_id, error=error_message
+            "Audio preprocessing failed",
+            job_id=job_id,
+            file_id=file_id,
+            error=error_message,
         )
 
         # Update job as failed
-        asyncio.run(update_job_status(job_id, "failed", 0, None, error_message))
+        asyncio.run(
+            update_job_status(job_id, "failed", 0, None, error_message)
+        )
 
         # Cleanup temp files if they exist
         try:
@@ -144,7 +168,11 @@ async def update_job_status(
         # Import here to avoid circular imports
         from app.database import database, processing_jobs
 
-        update_data = {"status": status, "progress": progress, "updated_at": datetime.utcnow()}
+        update_data = {
+            "status": status,
+            "progress": progress,
+            "updated_at": datetime.utcnow(),
+        }
 
         if status == "running" and progress == 0:
             update_data["started_at"] = datetime.utcnow()
@@ -158,9 +186,18 @@ async def update_job_status(
         if error_message:
             update_data["error_message"] = error_message
 
-        query = processing_jobs.update().where(processing_jobs.c.id == job_id).values(**update_data)
+        query = (
+            processing_jobs.update()
+            .where(processing_jobs.c.id == job_id)
+            .values(**update_data)
+        )
 
         await database.execute(query)
 
     except Exception as e:
-        logger.error("Failed to update job status", job_id=job_id, status=status, error=str(e))
+        logger.error(
+            "Failed to update job status",
+            job_id=job_id,
+            status=status,
+            error=str(e),
+        )
diff --git a/services/data-service/app/config.py b/services/data-service/app/config.py
index f78cab9..d1e0ff8 100644
--- a/services/data-service/app/config.py
+++ b/services/data-service/app/config.py
@@ -4,7 +4,9 @@ from typing import List
 
 class Settings(BaseSettings):
     # Database
-    database_url: str = "postgresql://voiceclone:voiceclone@postgres:5432/voiceclone"
+    database_url: str = (
+        "postgresql://voiceclone:voiceclone@postgres:5432/voiceclone"
+    )
 
     # Redis
     redis_url: str = "redis://redis:6379/0"
@@ -29,7 +31,10 @@ class Settings(BaseSettings):
 
     # Service settings
     debug: bool = False
-    allowed_origins: List[str] = ["http://localhost:3000", "http://localhost:8000"]
+    allowed_origins: List[str] = [
+        "http://localhost:3000",
+        "http://localhost:8000",
+    ]
 
     # Celery
     celery_broker_url: str = "redis://redis:6379/0"
diff --git a/services/data-service/app/database.py b/services/data-service/app/database.py
index 1881143..e8a7baf 100644
--- a/services/data-service/app/database.py
+++ b/services/data-service/app/database.py
@@ -38,7 +38,9 @@ voice_files = Table(
     Column("duration", Float, nullable=True),
     Column("sample_rate", Integer, nullable=True),
     Column("channels", Integer, nullable=True),
-    Column("status", String(50), default="pending"),  # pending, processing, processed, failed
+    Column(
+        "status", String(50), default="pending"
+    ),  # pending, processing, processed, failed
     Column("metadata", Text, nullable=True),  # JSON metadata
     Column("created_at", DateTime, default=func.now()),
     Column("updated_at", DateTime, default=func.now(), onupdate=func.now()),
@@ -50,9 +52,15 @@ processing_jobs = Table(
     metadata,
     Column("id", Integer, primary_key=True, index=True),
     Column("user_id", Integer, ForeignKey("users.id"), nullable=False),
-    Column("voice_file_id", Integer, ForeignKey("voice_files.id"), nullable=False),
-    Column("job_type", String(50), nullable=False),  # preprocessing, training, inference
-    Column("status", String(50), default="pending"),  # pending, running, completed, failed
+    Column(
+        "voice_file_id", Integer, ForeignKey("voice_files.id"), nullable=False
+    ),
+    Column(
+        "job_type", String(50), nullable=False
+    ),  # preprocessing, training, inference
+    Column(
+        "status", String(50), default="pending"
+    ),  # pending, running, completed, failed
     Column("progress", Integer, default=0),  # 0-100
     Column("result_data", Text, nullable=True),  # JSON result data
     Column("error_message", Text, nullable=True),
diff --git a/services/data-service/app/routers/process.py b/services/data-service/app/routers/process.py
index fc34d17..1866e49 100644
--- a/services/data-service/app/routers/process.py
+++ b/services/data-service/app/routers/process.py
@@ -4,7 +4,12 @@ from typing import Dict, Any
 import structlog
 
 from app.database import database, voice_files, processing_jobs
-from app.schemas import ProcessingJobCreate, ProcessingResponse, JobType, JobStatus
+from app.schemas import (
+    ProcessingJobCreate,
+    ProcessingResponse,
+    JobType,
+    JobStatus,
+)
 from app.audio_validator import audio_validator
 from app.celery_tasks import start_preprocessing_task
 from app.auth import get_current_user
@@ -16,7 +21,9 @@ security = HTTPBearer()
 
 @router.post("/process/{file_id}", response_model=ProcessingResponse)
 async def start_processing(
-    file_id: int, job_type: JobType, credentials: HTTPAuthorizationCredentials = Depends(security)
+    file_id: int,
+    job_type: JobType,
+    credentials: HTTPAuthorizationCredentials = Depends(security),
 ):
     """Start processing job for uploaded file"""
 
@@ -54,7 +61,9 @@ async def start_processing(
 
     try:
         # Create processing job record
-        job_data = ProcessingJobCreate(user_id=user_id, voice_file_id=file_id, job_type=job_type)
+        job_data = ProcessingJobCreate(
+            user_id=user_id, voice_file_id=file_id, job_type=job_type
+        )
 
         insert_query = processing_jobs.insert().values(**job_data.dict())
         job_id = await database.execute(insert_query)
@@ -63,7 +72,11 @@ async def start_processing(
         if job_type == JobType.PREPROCESSING:
             # Get preprocessing parameters
             metadata = file_record.metadata or {}
-            preprocessing_params = await audio_validator.get_optimal_preprocessing_params(metadata)
+            preprocessing_params = (
+                await audio_validator.get_optimal_preprocessing_params(
+                    metadata
+                )
+            )
 
             # Start Celery task
             task = start_preprocessing_task.delay(
@@ -91,11 +104,15 @@ async def start_processing(
 
         elif job_type == JobType.TRAINING:
             # Training logic will be implemented in Phase 3
-            raise HTTPException(status_code=501, detail="Training jobs not yet implemented")
+            raise HTTPException(
+                status_code=501, detail="Training jobs not yet implemented"
+            )
 
         elif job_type == JobType.INFERENCE:
             # Inference logic will be implemented in Phase 2
-            raise HTTPException(status_code=501, detail="Inference jobs not yet implemented")
+            raise HTTPException(
+                status_code=501, detail="Inference jobs not yet implemented"
+            )
 
         return ProcessingResponse(
             message=f"{job_type.value} job started successfully",
@@ -111,7 +128,9 @@ async def start_processing(
             job_type=job_type,
             error=str(e),
         )
-        raise HTTPException(status_code=500, detail="Failed to start processing job")
+        raise HTTPException(
+            status_code=500, detail="Failed to start processing job"
+        )
 
 
 @router.get("/jobs/{job_id}")
@@ -123,7 +142,8 @@ async def get_job_status(
     user_id = await get_current_user(credentials.credentials)
 
     query = processing_jobs.select().where(
-        (processing_jobs.c.id == job_id) & (processing_jobs.c.user_id == user_id)
+        (processing_jobs.c.id == job_id)
+        & (processing_jobs.c.user_id == user_id)
     )
     job = await database.fetch_one(query)
 
@@ -145,7 +165,9 @@ async def list_user_jobs(
 
     user_id = await get_current_user(credentials.credentials)
 
-    query = processing_jobs.select().where(processing_jobs.c.user_id == user_id)
+    query = processing_jobs.select().where(
+        processing_jobs.c.user_id == user_id
+    )
 
     if job_type:
         query = query.where(processing_jobs.c.job_type == job_type)
@@ -153,22 +175,34 @@ async def list_user_jobs(
     if status:
         query = query.where(processing_jobs.c.status == status)
 
-    query = query.offset(skip).limit(limit).order_by(processing_jobs.c.created_at.desc())
+    query = (
+        query.offset(skip)
+        .limit(limit)
+        .order_by(processing_jobs.c.created_at.desc())
+    )
 
     jobs = await database.fetch_all(query)
 
-    return {"jobs": [dict(job) for job in jobs], "total": len(jobs), "skip": skip, "limit": limit}
+    return {
+        "jobs": [dict(job) for job in jobs],
+        "total": len(jobs),
+        "skip": skip,
+        "limit": limit,
+    }
 
 
 @router.delete("/jobs/{job_id}")
-async def cancel_job(job_id: int, credentials: HTTPAuthorizationCredentials = Depends(security)):
+async def cancel_job(
+    job_id: int, credentials: HTTPAuthorizationCredentials = Depends(security)
+):
     """Cancel processing job"""
 
     user_id = await get_current_user(credentials.credentials)
 
     # Check if job exists and belongs to user
     query = processing_jobs.select().where(
-        (processing_jobs.c.id == job_id) & (processing_jobs.c.user_id == user_id)
+        (processing_jobs.c.id == job_id)
+        & (processing_jobs.c.user_id == user_id)
     )
     job = await database.fetch_one(query)
 
@@ -176,7 +210,10 @@ async def cancel_job(job_id: int, credentials: HTTPAuthorizationCredentials = De
         raise HTTPException(status_code=404, detail="Job not found")
 
     if job.status in ["completed", "failed"]:
-        raise HTTPException(status_code=400, detail=f"Cannot cancel job with status: {job.status}")
+        raise HTTPException(
+            status_code=400,
+            detail=f"Cannot cancel job with status: {job.status}",
+        )
 
     # Cancel Celery task if it exists
     if job.celery_task_id:
@@ -193,7 +230,10 @@ async def cancel_job(job_id: int, credentials: HTTPAuthorizationCredentials = De
     await database.execute(update_query)
 
     logger.info(
-        "Processing job cancelled", user_id=user_id, job_id=job_id, task_id=job.celery_task_id
+        "Processing job cancelled",
+        user_id=user_id,
+        job_id=job_id,
+        task_id=job.celery_task_id,
     )
 
     return {"message": "Job cancelled successfully"}
diff --git a/services/data-service/app/routers/upload.py b/services/data-service/app/routers/upload.py
index 18080ea..1050b84 100644
--- a/services/data-service/app/routers/upload.py
+++ b/services/data-service/app/routers/upload.py
@@ -31,12 +31,16 @@ async def upload_voice_file(
         raise HTTPException(status_code=400, detail="No filename provided")
 
     # Generate unique filename
-    file_extension = file.filename.split(".")[-1] if "." in file.filename else ""
+    file_extension = (
+        file.filename.split(".")[-1] if "." in file.filename else ""
+    )
     unique_filename = f"{uuid.uuid4()}.{file_extension}"
 
     try:
         # Save file temporarily
-        temp_file_path = await local_storage.save_upload(file.file, unique_filename)
+        temp_file_path = await local_storage.save_upload(
+            file.file, unique_filename
+        )
 
         logger.info(
             "File upload started",
@@ -48,7 +52,9 @@ async def upload_voice_file(
 
         # Validate file
         try:
-            metadata = await audio_validator.validate_file_upload(temp_file_path, file.filename)
+            metadata = await audio_validator.validate_file_upload(
+                temp_file_path, file.filename
+            )
         except FileValidationError as e:
             # Clean up temp file
             await local_storage.delete_file(temp_file_path)
@@ -77,9 +83,16 @@ async def upload_voice_file(
             # Clean up temp file
             await local_storage.delete_file(temp_file_path)
 
-            logger.error("S3 upload failed", user_id=user_id, filename=file.filename, error=str(e))
+            logger.error(
+                "S3 upload failed",
+                user_id=user_id,
+                filename=file.filename,
+                error=str(e),
+            )
 
-            raise HTTPException(status_code=500, detail="Failed to upload file to storage")
+            raise HTTPException(
+                status_code=500, detail="Failed to upload file to storage"
+            )
 
         # Save file record to database
         file_data = VoiceFileCreate(
@@ -127,12 +140,16 @@ async def upload_voice_file(
             filename=file.filename,
             error=str(e),
         )
-        raise HTTPException(status_code=500, detail="Internal server error during file upload")
+        raise HTTPException(
+            status_code=500, detail="Internal server error during file upload"
+        )
 
 
 @router.get("/files")
 async def list_user_files(
-    credentials: HTTPAuthorizationCredentials = Depends(security), skip: int = 0, limit: int = 10
+    credentials: HTTPAuthorizationCredentials = Depends(security),
+    skip: int = 0,
+    limit: int = 10,
 ):
     """List user's uploaded files"""
 
@@ -157,7 +174,9 @@ async def list_user_files(
 
 
 @router.delete("/files/{file_id}")
-async def delete_file(file_id: int, credentials: HTTPAuthorizationCredentials = Depends(security)):
+async def delete_file(
+    file_id: int, credentials: HTTPAuthorizationCredentials = Depends(security)
+):
     """Delete user's uploaded file"""
 
     user_id = await get_current_user(credentials.credentials)
@@ -176,7 +195,9 @@ async def delete_file(file_id: int, credentials: HTTPAuthorizationCredentials =
         await s3_storage.delete_file(file_record.s3_key)
 
     # Delete local file if it exists
-    if file_record.file_path and local_storage.file_exists(file_record.file_path):
+    if file_record.file_path and local_storage.file_exists(
+        file_record.file_path
+    ):
         await local_storage.delete_file(file_record.file_path)
 
     # Delete from database
@@ -184,7 +205,10 @@ async def delete_file(file_id: int, credentials: HTTPAuthorizationCredentials =
     await database.execute(delete_query)
 
     logger.info(
-        "File deleted successfully", user_id=user_id, file_id=file_id, filename=file_record.filename
+        "File deleted successfully",
+        user_id=user_id,
+        file_id=file_id,
+        filename=file_record.filename,
     )
 
     return {"message": "File deleted successfully"}
diff --git a/services/data-service/app/storage.py b/services/data-service/app/storage.py
index 89ea598..cc5762e 100644
--- a/services/data-service/app/storage.py
+++ b/services/data-service/app/storage.py
@@ -38,11 +38,17 @@ class S3Storage:
                     logger.info("Created S3 bucket", bucket=self.bucket)
                 except ClientError as create_error:
                     logger.error(
-                        "Failed to create S3 bucket", bucket=self.bucket, error=str(create_error)
+                        "Failed to create S3 bucket",
+                        bucket=self.bucket,
+                        error=str(create_error),
                     )
                     raise
             else:
-                logger.error("Error checking S3 bucket", bucket=self.bucket, error=str(e))
+                logger.error(
+                    "Error checking S3 bucket",
+                    bucket=self.bucket,
+                    error=str(e),
+                )
                 raise
 
     async def upload_file(self, file_path: str, s3_key: str) -> str:
@@ -54,13 +60,21 @@ class S3Storage:
             # Generate URL
             url = f"{settings.s3_endpoint}/{self.bucket}/{s3_key}"
 
-            logger.info("File uploaded to S3", file_path=file_path, s3_key=s3_key, url=url)
+            logger.info(
+                "File uploaded to S3",
+                file_path=file_path,
+                s3_key=s3_key,
+                url=url,
+            )
 
             return url
 
         except ClientError as e:
             logger.error(
-                "Failed to upload file to S3", file_path=file_path, s3_key=s3_key, error=str(e)
+                "Failed to upload file to S3",
+                file_path=file_path,
+                s3_key=s3_key,
+                error=str(e),
             )
             raise
 
@@ -73,7 +87,9 @@ class S3Storage:
             # Download file
             self.client.download_file(self.bucket, s3_key, local_path)
 
-            logger.info("File downloaded from S3", s3_key=s3_key, local_path=local_path)
+            logger.info(
+                "File downloaded from S3", s3_key=s3_key, local_path=local_path
+            )
 
             return local_path
 
@@ -95,7 +111,9 @@ class S3Storage:
             return True
 
         except ClientError as e:
-            logger.error("Failed to delete file from S3", s3_key=s3_key, error=str(e))
+            logger.error(
+                "Failed to delete file from S3", s3_key=s3_key, error=str(e)
+            )
             return False
 
     def file_exists(self, s3_key: str) -> bool:
@@ -135,7 +153,11 @@ class LocalStorage:
             logger.info("File deleted locally", file_path=file_path)
             return True
         except OSError as e:
-            logger.error("Failed to delete local file", file_path=file_path, error=str(e))
+            logger.error(
+                "Failed to delete local file",
+                file_path=file_path,
+                error=str(e),
+            )
             return False
 
     def file_exists(self, file_path: str) -> bool:
diff --git a/services/data-service/tests/conftest.py b/services/data-service/tests/conftest.py
index 722a195..eec858e 100644
--- a/services/data-service/tests/conftest.py
+++ b/services/data-service/tests/conftest.py
@@ -33,7 +33,9 @@ def mock_auth_service():
 def mock_s3_storage():
     """Mock S3 storage operations"""
     with patch("app.storage.s3_storage") as mock:
-        mock.upload_file = AsyncMock(return_value="http://minio:9000/voice-data/test-file.wav")
+        mock.upload_file = AsyncMock(
+            return_value="http://minio:9000/voice-data/test-file.wav"
+        )
         mock.delete_file = AsyncMock(return_value=True)
         mock.file_exists = AsyncMock(return_value=True)
         yield mock
diff --git a/services/inference-service/app/auth.py b/services/inference-service/app/auth.py
index eb713d1..6d46b61 100644
--- a/services/inference-service/app/auth.py
+++ b/services/inference-service/app/auth.py
@@ -14,7 +14,9 @@ async def verify_token(token: str) -> dict:
     """Verify JWT token with auth service"""
     try:
         # First try to decode locally
-        payload = jwt.decode(token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm])
+        payload = jwt.decode(
+            token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm]
+        )
         return payload
     except JWTError:
         # If local verification fails, check with auth service
@@ -40,7 +42,9 @@ async def verify_token(token: str) -> dict:
             )
 
 
-async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> dict:
+async def get_current_user(
+    credentials: HTTPAuthorizationCredentials = Depends(security),
+) -> dict:
     """Get current authenticated user"""
     try:
         token = credentials.credentials
@@ -49,7 +53,8 @@ async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(s
         user_id = payload.get("sub")
         if user_id is None:
             raise HTTPException(
-                status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token payload"
+                status_code=status.HTTP_401_UNAUTHORIZED,
+                detail="Invalid token payload",
             )
 
         return {
@@ -59,11 +64,14 @@ async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(s
         }
     except ValueError:
         raise HTTPException(
-            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid user ID in token"
+            status_code=status.HTTP_401_UNAUTHORIZED,
+            detail="Invalid user ID in token",
         )
 
 
-async def get_optional_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> dict:
+async def get_optional_user(
+    credentials: HTTPAuthorizationCredentials = Depends(security),
+) -> dict:
     """Get current user if authenticated, otherwise return None"""
     try:
         return await get_current_user(credentials)
diff --git a/services/inference-service/app/config.py b/services/inference-service/app/config.py
index 616c7aa..35728be 100644
--- a/services/inference-service/app/config.py
+++ b/services/inference-service/app/config.py
@@ -28,7 +28,9 @@ class Settings(BaseSettings):
     jwt_algorithm: str = os.getenv("JWT_ALGORITHM", "HS256")
 
     # Auth Service
-    auth_service_url: str = os.getenv("AUTH_SERVICE_URL", "http://auth-service:8001")
+    auth_service_url: str = os.getenv(
+        "AUTH_SERVICE_URL", "http://auth-service:8001"
+    )
 
     # CORS
     cors_origins: List[str] = [
@@ -44,11 +46,17 @@ class Settings(BaseSettings):
 
     # Synthesis settings
     max_text_length: int = int(os.getenv("MAX_TEXT_LENGTH", "1000"))
-    max_audio_duration: int = int(os.getenv("MAX_AUDIO_DURATION", "300"))  # 5 minutes
+    max_audio_duration: int = int(
+        os.getenv("MAX_AUDIO_DURATION", "300")
+    )  # 5 minutes
 
     # Performance
-    synthesis_timeout: int = int(os.getenv("SYNTHESIS_TIMEOUT", "60"))  # 60 seconds
-    model_load_timeout: int = int(os.getenv("MODEL_LOAD_TIMEOUT", "120"))  # 2 minutes
+    synthesis_timeout: int = int(
+        os.getenv("SYNTHESIS_TIMEOUT", "60")
+    )  # 60 seconds
+    model_load_timeout: int = int(
+        os.getenv("MODEL_LOAD_TIMEOUT", "120")
+    )  # 2 minutes
 
 
 @lru_cache()
diff --git a/services/inference-service/app/database.py b/services/inference-service/app/database.py
index de7d095..d1536b4 100644
--- a/services/inference-service/app/database.py
+++ b/services/inference-service/app/database.py
@@ -33,7 +33,9 @@ voice_models = Table(
     Column("description", Text),
     Column("model_type", String(50), nullable=False, default="tacotron2"),
     Column("language", String(10), nullable=False, default="en"),
-    Column("status", String(20), nullable=False, default="training"),  # training, ready, failed
+    Column(
+        "status", String(20), nullable=False, default="training"
+    ),  # training, ready, failed
     Column("model_path", String(500)),  # S3 path to model files
     Column("config_data", Text),  # JSON config for model
     Column("training_data_size", Integer, default=0),
diff --git a/services/inference-service/app/main.py b/services/inference-service/app/main.py
index 075b9d0..b3b250b 100644
--- a/services/inference-service/app/main.py
+++ b/services/inference-service/app/main.py
@@ -33,7 +33,9 @@ logger = structlog.get_logger()
 @asynccontextmanager
 async def lifespan(app: FastAPI):
     """Application lifespan management"""
-    logger.info("Starting voice inference service", service="inference-service")
+    logger.info(
+        "Starting voice inference service", service="inference-service"
+    )
 
     # Create database tables
     metadata.create_all(bind=engine)
@@ -89,4 +91,8 @@ async def health_check():
 @app.get("/")
 async def root():
     """Root endpoint"""
-    return {"service": "voice-cloning-inference", "version": "1.0.0", "status": "running"}
+    return {
+        "service": "voice-cloning-inference",
+        "version": "1.0.0",
+        "status": "running",
+    }
diff --git a/services/inference-service/app/routers/models.py b/services/inference-service/app/routers/models.py
index d8e7b74..ce15862 100644
--- a/services/inference-service/app/routers/models.py
+++ b/services/inference-service/app/routers/models.py
@@ -51,12 +51,18 @@ async def get_user_models(
 ):
     """Get user's voice models"""
 
-    query = voice_models.select().where(voice_models.c.user_id == current_user["id"])
+    query = voice_models.select().where(
+        voice_models.c.user_id == current_user["id"]
+    )
 
     if status_filter:
         query = query.where(voice_models.c.status == status_filter)
 
-    query = query.order_by(voice_models.c.created_at.desc()).limit(limit).offset(offset)
+    query = (
+        query.order_by(voice_models.c.created_at.desc())
+        .limit(limit)
+        .offset(offset)
+    )
 
     models = await database.fetch_all(query)
 
@@ -79,17 +85,23 @@ async def get_user_models(
 
 
 @router.get("/models/{model_id}", response_model=VoiceModelResponse)
-async def get_model_details(model_id: int, current_user: dict = Depends(get_current_user)):
+async def get_model_details(
+    model_id: int, current_user: dict = Depends(get_current_user)
+):
     """Get voice model details"""
 
     query = voice_models.select().where(
-        (voice_models.c.id == model_id) & (voice_models.c.user_id == current_user["id"])
+        (voice_models.c.id == model_id)
+        & (voice_models.c.user_id == current_user["id"])
     )
 
     model = await database.fetch_one(query)
 
     if not model:
-        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Voice model not found")
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="Voice model not found",
+        )
 
     return VoiceModelResponse(
         id=model["id"],
@@ -107,7 +119,9 @@ async def get_model_details(model_id: int, current_user: dict = Depends(get_curr
 
 
 @router.post("/models/{model_id}/preload")
-async def preload_model(model_id: int, current_user: dict = Depends(get_current_user)):
+async def preload_model(
+    model_id: int, current_user: dict = Depends(get_current_user)
+):
     """Preload model into cache"""
 
     # Verify model ownership and readiness
@@ -121,7 +135,8 @@ async def preload_model(model_id: int, current_user: dict = Depends(get_current_
 
     if not model_result:
         raise HTTPException(
-            status_code=status.HTTP_404_NOT_FOUND, detail="Voice model not found or not ready"
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="Voice model not found or not ready",
         )
 
     try:
@@ -133,12 +148,22 @@ async def preload_model(model_id: int, current_user: dict = Depends(get_current_
 
         await model_manager.preload_model(model_id, model_config)
 
-        logger.info("Model preloaded successfully", model_id=model_id, user_id=current_user["id"])
+        logger.info(
+            "Model preloaded successfully",
+            model_id=model_id,
+            user_id=current_user["id"],
+        )
 
-        return {"message": "Model preloaded successfully", "model_id": model_id, "status": "cached"}
+        return {
+            "message": "Model preloaded successfully",
+            "model_id": model_id,
+            "status": "cached",
+        }
 
     except Exception as e:
-        logger.error("Failed to preload model", model_id=model_id, error=str(e))
+        logger.error(
+            "Failed to preload model", model_id=model_id, error=str(e)
+        )
         raise HTTPException(
             status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
             detail=f"Failed to preload model: {str(e)}",
@@ -146,18 +171,24 @@ async def preload_model(model_id: int, current_user: dict = Depends(get_current_
 
 
 @router.get("/models/{model_id}/usage", response_model=ModelUsageStats)
-async def get_model_usage_stats(model_id: int, current_user: dict = Depends(get_current_user)):
+async def get_model_usage_stats(
+    model_id: int, current_user: dict = Depends(get_current_user)
+):
     """Get model usage statistics"""
 
     # Verify model ownership
     model_query = voice_models.select().where(
-        (voice_models.c.id == model_id) & (voice_models.c.user_id == current_user["id"])
+        (voice_models.c.id == model_id)
+        & (voice_models.c.user_id == current_user["id"])
     )
 
     model_result = await database.fetch_one(model_query)
 
     if not model_result:
-        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Voice model not found")
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="Voice model not found",
+        )
 
     # Get usage stats
     stats_query = model_usage_stats.select().where(
@@ -191,7 +222,10 @@ async def get_ready_models(current_user: dict = Depends(get_current_user)):
 
     query = (
         voice_models.select()
-        .where((voice_models.c.user_id == current_user["id"]) & (voice_models.c.status == "ready"))
+        .where(
+            (voice_models.c.user_id == current_user["id"])
+            & (voice_models.c.status == "ready")
+        )
         .order_by(voice_models.c.created_at.desc())
     )
 
@@ -272,5 +306,6 @@ async def clear_model_cache(current_user: dict = Depends(get_current_user)):
     except Exception as e:
         logger.error("Failed to clear cache", error=str(e))
         raise HTTPException(
-            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to clear model cache"
+            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
+            detail="Failed to clear model cache",
         )
diff --git a/services/inference-service/app/routers/synthesis.py b/services/inference-service/app/routers/synthesis.py
index 140c0dd..6ea07fd 100644
--- a/services/inference-service/app/routers/synthesis.py
+++ b/services/inference-service/app/routers/synthesis.py
@@ -17,17 +17,31 @@ router = APIRouter()
 
 
 class SynthesisRequest(BaseModel):
-    text: str = Field(..., min_length=1, max_length=1000, description="Text to synthesize")
+    text: str = Field(
+        ..., min_length=1, max_length=1000, description="Text to synthesize"
+    )
     model_id: int = Field(..., description="Voice model ID to use")
-    speed: Optional[float] = Field(default=1.0, ge=0.5, le=2.0, description="Speech speed")
-    pitch: Optional[float] = Field(default=1.0, ge=0.5, le=2.0, description="Speech pitch")
-    volume: Optional[float] = Field(default=1.0, ge=0.1, le=2.0, description="Speech volume")
-    emotion: Optional[str] = Field(default="neutral", description="Emotion style")
-    return_audio: bool = Field(default=False, description="Return audio data directly")
+    speed: Optional[float] = Field(
+        default=1.0, ge=0.5, le=2.0, description="Speech speed"
+    )
+    pitch: Optional[float] = Field(
+        default=1.0, ge=0.5, le=2.0, description="Speech pitch"
+    )
+    volume: Optional[float] = Field(
+        default=1.0, ge=0.1, le=2.0, description="Speech volume"
+    )
+    emotion: Optional[str] = Field(
+        default="neutral", description="Emotion style"
+    )
+    return_audio: bool = Field(
+        default=False, description="Return audio data directly"
+    )
 
 
 class BatchSynthesisRequest(BaseModel):
-    texts: List[str] = Field(..., max_items=10, description="List of texts to synthesize")
+    texts: List[str] = Field(
+        ..., max_items=10, description="List of texts to synthesize"
+    )
     model_id: int = Field(..., description="Voice model ID to use")
     speed: Optional[float] = Field(default=1.0, ge=0.5, le=2.0)
     pitch: Optional[float] = Field(default=1.0, ge=0.5, le=2.0)
@@ -65,7 +79,8 @@ async def synthesize_voice(
 
     if not model_result:
         raise HTTPException(
-            status_code=status.HTTP_404_NOT_FOUND, detail="Voice model not found or not ready"
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="Voice model not found or not ready",
         )
 
     # Create synthesis job record
@@ -121,7 +136,9 @@ async def synthesize_voice(
 
             # Upload audio to S3
             audio_key = f"synthesized/{current_user['id']}/{job_id}.wav"
-            audio_url = await s3_storage.upload_audio(synthesis_result["audio_data"], audio_key)
+            audio_url = await s3_storage.upload_audio(
+                synthesis_result["audio_data"], audio_key
+            )
 
             # Update job with results
             await database.execute(
@@ -153,7 +170,11 @@ async def synthesize_voice(
             await database.execute(
                 synthesis_jobs.update()
                 .where(synthesis_jobs.c.id == job_id)
-                .values(status="failed", error_message=str(e), completed_at=datetime.utcnow())
+                .values(
+                    status="failed",
+                    error_message=str(e),
+                    completed_at=datetime.utcnow(),
+                )
             )
             raise HTTPException(
                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
@@ -198,7 +219,8 @@ async def batch_synthesize_voice(
 
     if not model_result:
         raise HTTPException(
-            status_code=status.HTTP_404_NOT_FOUND, detail="Voice model not found or not ready"
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="Voice model not found or not ready",
         )
 
     # Create synthesis jobs for each text
@@ -229,25 +251,36 @@ async def batch_synthesize_voice(
         current_user["id"],
     )
 
-    return {"job_ids": job_ids, "status": "pending", "batch_size": len(request.texts)}
+    return {
+        "job_ids": job_ids,
+        "status": "pending",
+        "batch_size": len(request.texts),
+    }
 
 
 @router.get("/synthesize/audio/{job_id}")
-async def get_synthesis_audio(job_id: int, current_user: dict = Depends(get_current_user)):
+async def get_synthesis_audio(
+    job_id: int, current_user: dict = Depends(get_current_user)
+):
     """Get synthesized audio file"""
 
     # Get job details
     job_query = synthesis_jobs.select().where(
-        (synthesis_jobs.c.id == job_id) & (synthesis_jobs.c.user_id == current_user["id"])
+        (synthesis_jobs.c.id == job_id)
+        & (synthesis_jobs.c.user_id == current_user["id"])
     )
     job = await database.fetch_one(job_query)
 
     if not job:
-        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Synthesis job not found")
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="Synthesis job not found",
+        )
 
     if job["status"] != "completed" or not job["audio_url"]:
         raise HTTPException(
-            status_code=status.HTTP_400_BAD_REQUEST, detail="Audio not ready or synthesis failed"
+            status_code=status.HTTP_400_BAD_REQUEST,
+            detail="Audio not ready or synthesis failed",
         )
 
     # Stream audio file
@@ -256,24 +289,31 @@ async def get_synthesis_audio(job_id: int, current_user: dict = Depends(get_curr
         audio_key = job["audio_url"].split("/")[-1]
 
         # For demonstration, return mock audio
-        mock_audio = b"RIFF\x24\x08\x00\x00WAVEfmt \x10\x00\x00\x00" + b"\x00" * 1000
+        mock_audio = (
+            b"RIFF\x24\x08\x00\x00WAVEfmt \x10\x00\x00\x00" + b"\x00" * 1000
+        )
 
         return StreamingResponse(
             io.BytesIO(mock_audio),
             media_type="audio/wav",
-            headers={"Content-Disposition": f"attachment; filename=synthesis_{job_id}.wav"},
+            headers={
+                "Content-Disposition": f"attachment; filename=synthesis_{job_id}.wav"
+            },
         )
 
     except Exception as e:
         logger.error("Failed to stream audio", job_id=job_id, error=str(e))
         raise HTTPException(
-            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to retrieve audio"
+            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
+            detail="Failed to retrieve audio",
         )
 
 
 @router.get("/jobs", response_model=List[SynthesisResponse])
 async def get_synthesis_jobs(
-    current_user: dict = Depends(get_current_user), limit: int = 20, offset: int = 0
+    current_user: dict = Depends(get_current_user),
+    limit: int = 20,
+    offset: int = 0,
 ):
     """Get user's synthesis jobs"""
 
@@ -304,17 +344,23 @@ async def get_synthesis_jobs(
 
 
 @router.get("/jobs/{job_id}", response_model=SynthesisResponse)
-async def get_synthesis_job(job_id: int, current_user: dict = Depends(get_current_user)):
+async def get_synthesis_job(
+    job_id: int, current_user: dict = Depends(get_current_user)
+):
     """Get synthesis job details"""
 
     query = synthesis_jobs.select().where(
-        (synthesis_jobs.c.id == job_id) & (synthesis_jobs.c.user_id == current_user["id"])
+        (synthesis_jobs.c.id == job_id)
+        & (synthesis_jobs.c.user_id == current_user["id"])
     )
 
     job = await database.fetch_one(query)
 
     if not job:
-        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Synthesis job not found")
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="Synthesis job not found",
+        )
 
     return SynthesisResponse(
         job_id=job["id"],
@@ -330,13 +376,19 @@ async def get_synthesis_job(job_id: int, current_user: dict = Depends(get_curren
 
 
 async def process_synthesis_job(
-    job_id: int, model_id: int, model_result, request: SynthesisRequest, user_id: int
+    job_id: int,
+    model_id: int,
+    model_result,
+    request: SynthesisRequest,
+    user_id: int,
 ):
     """Background task to process synthesis job"""
     try:
         # Update job status
         await database.execute(
-            synthesis_jobs.update().where(synthesis_jobs.c.id == job_id).values(status="processing")
+            synthesis_jobs.update()
+            .where(synthesis_jobs.c.id == job_id)
+            .values(status="processing")
         )
 
         # Perform synthesis
@@ -360,7 +412,9 @@ async def process_synthesis_job(
 
         # Upload audio to S3
         audio_key = f"synthesized/{user_id}/{job_id}.wav"
-        audio_url = await s3_storage.upload_audio(synthesis_result["audio_data"], audio_key)
+        audio_url = await s3_storage.upload_audio(
+            synthesis_result["audio_data"], audio_key
+        )
 
         # Update job with results
         await database.execute(
@@ -382,16 +436,26 @@ async def process_synthesis_job(
         await database.execute(
             synthesis_jobs.update()
             .where(synthesis_jobs.c.id == job_id)
-            .values(status="failed", error_message=str(e), completed_at=datetime.utcnow())
+            .values(
+                status="failed",
+                error_message=str(e),
+                completed_at=datetime.utcnow(),
+            )
         )
         logger.error("Synthesis job failed", job_id=job_id, error=str(e))
 
 
 async def process_batch_synthesis(
-    job_ids: List[int], model_id: int, model_result, request: BatchSynthesisRequest, user_id: int
+    job_ids: List[int],
+    model_id: int,
+    model_result,
+    request: BatchSynthesisRequest,
+    user_id: int,
 ):
     """Background task to process batch synthesis"""
-    logger.info("Starting batch synthesis", job_ids=job_ids, batch_size=len(job_ids))
+    logger.info(
+        "Starting batch synthesis", job_ids=job_ids, batch_size=len(job_ids)
+    )
 
     for i, job_id in enumerate(job_ids):
         try:
@@ -410,4 +474,6 @@ async def process_batch_synthesis(
                 user_id,
             )
         except Exception as e:
-            logger.error("Batch synthesis item failed", job_id=job_id, error=str(e))
+            logger.error(
+                "Batch synthesis item failed", job_id=job_id, error=str(e)
+            )
diff --git a/services/inference-service/app/services/model_manager.py b/services/inference-service/app/services/model_manager.py
index cc50698..f37d9de 100644
--- a/services/inference-service/app/services/model_manager.py
+++ b/services/inference-service/app/services/model_manager.py
@@ -37,7 +37,9 @@ class MockVoiceModel:
         t = np.linspace(0, duration, int(sample_rate * duration))
 
         # Create a simple sine wave with varying frequency
-        frequency = 440 + (hash(text) % 200)  # Base frequency with text-based variation
+        frequency = 440 + (
+            hash(text) % 200
+        )  # Base frequency with text-based variation
         audio = np.sin(2 * np.pi * frequency * t) * 0.3
 
         # Convert to 16-bit PCM
@@ -67,19 +69,30 @@ class ModelManager:
 
     async def initialize(self):
         """Initialize the model manager"""
-        logger.info("Initializing model manager", max_cache_size=settings.max_model_cache_size)
-
-    async def get_model(self, model_id: int, model_config: Dict[str, Any]) -> MockVoiceModel:
+        logger.info(
+            "Initializing model manager",
+            max_cache_size=settings.max_model_cache_size,
+        )
+
+    async def get_model(
+        self, model_id: int, model_config: Dict[str, Any]
+    ) -> MockVoiceModel:
         """Get a model from cache or load it"""
 
         # Check if model is already cached and not expired
         if model_id in self.model_cache:
             cache_age = time.time() - self.cache_timestamps[model_id]
             if cache_age < settings.model_cache_ttl:
-                logger.debug("Model cache hit", model_id=model_id, cache_age=cache_age)
+                logger.debug(
+                    "Model cache hit", model_id=model_id, cache_age=cache_age
+                )
                 return self.model_cache[model_id]
             else:
-                logger.debug("Model cache expired", model_id=model_id, cache_age=cache_age)
+                logger.debug(
+                    "Model cache expired",
+                    model_id=model_id,
+                    cache_age=cache_age,
+                )
                 await self._unload_model(model_id)
 
         # Get or create loading lock for this model
@@ -103,15 +116,21 @@ class ModelManager:
             self.cache_timestamps[model_id] = time.time()
 
             logger.info(
-                "Model loaded successfully", model_id=model_id, cache_size=len(self.model_cache)
+                "Model loaded successfully",
+                model_id=model_id,
+                cache_size=len(self.model_cache),
             )
 
             return model
 
-    async def _load_model(self, model_id: int, model_config: Dict[str, Any]) -> MockVoiceModel:
+    async def _load_model(
+        self, model_id: int, model_config: Dict[str, Any]
+    ) -> MockVoiceModel:
         """Load a model from storage"""
         try:
-            model_path = model_config.get("model_path", f"models/model_{model_id}")
+            model_path = model_config.get(
+                "model_path", f"models/model_{model_id}"
+            )
 
             # Simulate model loading time
             await asyncio.sleep(0.5)
@@ -122,7 +141,9 @@ class ModelManager:
             return model
 
         except Exception as e:
-            logger.error("Failed to load model", model_id=model_id, error=str(e))
+            logger.error(
+                "Failed to load model", model_id=model_id, error=str(e)
+            )
             raise RuntimeError(f"Failed to load model {model_id}: {str(e)}")
 
     async def _unload_model(self, model_id: int):
@@ -141,7 +162,8 @@ class ModelManager:
         while len(self.model_cache) >= settings.max_model_cache_size:
             # Find oldest model to evict
             oldest_model_id = min(
-                self.cache_timestamps.keys(), key=lambda k: self.cache_timestamps[k]
+                self.cache_timestamps.keys(),
+                key=lambda k: self.cache_timestamps[k],
             )
             await self._unload_model(oldest_model_id)
             logger.debug("Evicted model from cache", model_id=oldest_model_id)
@@ -152,7 +174,9 @@ class ModelManager:
             await self.get_model(model_id, model_config)
             logger.info("Model preloaded", model_id=model_id)
         except Exception as e:
-            logger.error("Failed to preload model", model_id=model_id, error=str(e))
+            logger.error(
+                "Failed to preload model", model_id=model_id, error=str(e)
+            )
 
     async def get_cache_stats(self) -> Dict[str, Any]:
         """Get cache statistics"""
@@ -162,7 +186,9 @@ class ModelManager:
             "cache_ttl": settings.model_cache_ttl,
             "model_ids": list(self.model_cache.keys()),
             "oldest_cache_age": (
-                time.time() - min(self.cache_timestamps.values()) if self.cache_timestamps else 0
+                time.time() - min(self.cache_timestamps.values())
+                if self.cache_timestamps
+                else 0
             ),
         }
 
diff --git a/services/inference-service/app/services/synthesis_engine.py b/services/inference-service/app/services/synthesis_engine.py
index 8913930..75f36e2 100644
--- a/services/inference-service/app/services/synthesis_engine.py
+++ b/services/inference-service/app/services/synthesis_engine.py
@@ -30,7 +30,9 @@ class SynthesisEngine:
 
         # Validate input
         if len(text) > settings.max_text_length:
-            raise ValueError(f"Text too long: {len(text)} > {settings.max_text_length}")
+            raise ValueError(
+                f"Text too long: {len(text)} > {settings.max_text_length}"
+            )
 
         if not text.strip():
             raise ValueError("Text cannot be empty")
@@ -67,7 +69,8 @@ class SynthesisEngine:
 
             # Perform synthesis
             audio_data = await asyncio.wait_for(
-                model.synthesize(text, **synthesis_params), timeout=settings.synthesis_timeout
+                model.synthesize(text, **synthesis_params),
+                timeout=settings.synthesis_timeout,
             )
 
             processing_time = time.time() - start_time
@@ -92,13 +95,22 @@ class SynthesisEngine:
             }
 
         except asyncio.TimeoutError:
-            logger.error("Synthesis timeout", job_id=job_id, timeout=settings.synthesis_timeout)
-            raise RuntimeError(f"Synthesis timed out after {settings.synthesis_timeout} seconds")
+            logger.error(
+                "Synthesis timeout",
+                job_id=job_id,
+                timeout=settings.synthesis_timeout,
+            )
+            raise RuntimeError(
+                f"Synthesis timed out after {settings.synthesis_timeout} seconds"
+            )
 
         except Exception as e:
             processing_time = time.time() - start_time
             logger.error(
-                "Synthesis failed", job_id=job_id, error=str(e), processing_time=processing_time
+                "Synthesis failed",
+                job_id=job_id,
+                error=str(e),
+                processing_time=processing_time,
             )
             raise RuntimeError(f"Synthesis failed: {str(e)}")
 
@@ -116,7 +128,10 @@ class SynthesisEngine:
             raise ValueError("Batch size too large: maximum 10 texts")
 
         logger.info(
-            "Starting batch synthesis", batch_size=len(texts), model_id=model_id, user_id=user_id
+            "Starting batch synthesis",
+            batch_size=len(texts),
+            model_id=model_id,
+            user_id=user_id,
         )
 
         # Create synthesis tasks
@@ -140,11 +155,21 @@ class SynthesisEngine:
             for i, result in enumerate(results):
                 if isinstance(result, Exception):
                     batch_results.append(
-                        {"index": i, "text": texts[i], "error": str(result), "success": False}
+                        {
+                            "index": i,
+                            "text": texts[i],
+                            "error": str(result),
+                            "success": False,
+                        }
                     )
                 else:
                     batch_results.append(
-                        {"index": i, "text": texts[i], "result": result, "success": True}
+                        {
+                            "index": i,
+                            "text": texts[i],
+                            "result": result,
+                            "success": True,
+                        }
                     )
 
             logger.info(
diff --git a/services/inference-service/app/storage.py b/services/inference-service/app/storage.py
index 7078c18..d92fa5b 100644
--- a/services/inference-service/app/storage.py
+++ b/services/inference-service/app/storage.py
@@ -48,12 +48,18 @@ class S3Storage:
     async def download_model(self, key: str, local_path: str) -> bool:
         """Download model file from S3"""
         try:
-            self.client.download_file(Bucket=self.bucket_name, Key=key, Filename=local_path)
-            logger.info("Model downloaded from S3", key=key, local_path=local_path)
+            self.client.download_file(
+                Bucket=self.bucket_name, Key=key, Filename=local_path
+            )
+            logger.info(
+                "Model downloaded from S3", key=key, local_path=local_path
+            )
             return True
 
         except (ClientError, BotoCoreError) as e:
-            logger.error("Failed to download model from S3", key=key, error=str(e))
+            logger.error(
+                "Failed to download model from S3", key=key, error=str(e)
+            )
             return False
 
     async def file_exists(self, key: str) -> bool:
@@ -71,13 +77,17 @@ class S3Storage:
             logger.info("File deleted from S3", key=key)
             return True
         except (ClientError, BotoCoreError) as e:
-            logger.error("Failed to delete file from S3", key=key, error=str(e))
+            logger.error(
+                "Failed to delete file from S3", key=key, error=str(e)
+            )
             return False
 
     async def list_model_files(self, prefix: str) -> list[str]:
         """List model files with given prefix"""
         try:
-            response = self.client.list_objects_v2(Bucket=self.bucket_name, Prefix=prefix)
+            response = self.client.list_objects_v2(
+                Bucket=self.bucket_name, Prefix=prefix
+            )
 
             files = []
             if "Contents" in response:
@@ -86,7 +96,9 @@ class S3Storage:
             return files
 
         except (ClientError, BotoCoreError) as e:
-            logger.error("Failed to list model files", prefix=prefix, error=str(e))
+            logger.error(
+                "Failed to list model files", prefix=prefix, error=str(e)
+            )
             return []
 
 
@@ -105,11 +117,15 @@ class LocalStorage:
             async with aiofiles.open(file_path, "wb") as f:
                 await f.write(audio_data)
 
-            logger.debug("Temp audio saved", file_path=file_path, size=len(audio_data))
+            logger.debug(
+                "Temp audio saved", file_path=file_path, size=len(audio_data)
+            )
             return file_path
 
         except Exception as e:
-            logger.error("Failed to save temp audio", filename=filename, error=str(e))
+            logger.error(
+                "Failed to save temp audio", filename=filename, error=str(e)
+            )
             raise RuntimeError(f"Failed to save temporary audio: {str(e)}")
 
     async def read_temp_file(self, file_path: str) -> Optional[bytes]:
@@ -124,7 +140,9 @@ class LocalStorage:
             return data
 
         except Exception as e:
-            logger.error("Failed to read temp file", file_path=file_path, error=str(e))
+            logger.error(
+                "Failed to read temp file", file_path=file_path, error=str(e)
+            )
             return None
 
     async def cleanup_temp_file(self, file_path: str) -> bool:
@@ -135,7 +153,11 @@ class LocalStorage:
                 logger.debug("Temp file cleaned up", file_path=file_path)
             return True
         except Exception as e:
-            logger.error("Failed to cleanup temp file", file_path=file_path, error=str(e))
+            logger.error(
+                "Failed to cleanup temp file",
+                file_path=file_path,
+                error=str(e),
+            )
             return False
 
 
diff --git a/services/inference-service/tests/conftest.py b/services/inference-service/tests/conftest.py
index 927f6c9..6412ed5 100644
--- a/services/inference-service/tests/conftest.py
+++ b/services/inference-service/tests/conftest.py
@@ -25,7 +25,11 @@ def client():
 def mock_auth_service():
     """Mock authentication service responses"""
     with patch("app.auth.get_current_user") as mock:
-        mock.return_value = {"id": 1, "username": "testuser", "email": "test@example.com"}
+        mock.return_value = {
+            "id": 1,
+            "username": "testuser",
+            "email": "test@example.com",
+        }
         yield mock
 
 
@@ -43,7 +47,9 @@ def mock_database():
 def mock_s3_storage():
     """Mock S3 storage operations"""
     with patch("app.storage.s3_storage") as mock:
-        mock.upload_audio = AsyncMock(return_value="http://minio:9000/voice-models/test-audio.wav")
+        mock.upload_audio = AsyncMock(
+            return_value="http://minio:9000/voice-models/test-audio.wav"
+        )
         mock.delete_file = AsyncMock(return_value=True)
         mock.file_exists = AsyncMock(return_value=True)
         yield mock
diff --git a/services/inference-service/tests/test_synthesis.py b/services/inference-service/tests/test_synthesis.py
index 8a45bc1..7b87033 100644
--- a/services/inference-service/tests/test_synthesis.py
+++ b/services/inference-service/tests/test_synthesis.py
@@ -17,7 +17,9 @@ class TestSynthesisEndpoints:
 
     def test_synthesis_without_auth(self, client):
         """Test synthesis endpoint without authentication"""
-        response = client.post("/api/v1/synthesize", json={"text": "Hello world", "model_id": 1})
+        response = client.post(
+            "/api/v1/synthesize", json={"text": "Hello world", "model_id": 1}
+        )
         assert response.status_code == 403  # Unauthorized
 
     def test_synthesis_with_auth(
@@ -36,7 +38,11 @@ class TestSynthesisEndpoints:
         mock_database.execute.return_value = 1  # job_id
 
         headers = {"Authorization": "Bearer fake-token"}
-        response = client.post("/api/v1/synthesize", json=sample_synthesis_request, headers=headers)
+        response = client.post(
+            "/api/v1/synthesize",
+            json=sample_synthesis_request,
+            headers=headers,
+        )
 
         assert response.status_code == 200
         data = response.json()
@@ -44,14 +50,18 @@ class TestSynthesisEndpoints:
         assert data["model_id"] == 1
         assert data["text"] == sample_synthesis_request["text"]
 
-    def test_synthesis_model_not_found(self, client, mock_auth_service, mock_database):
+    def test_synthesis_model_not_found(
+        self, client, mock_auth_service, mock_database
+    ):
         """Test synthesis with non-existent model"""
         # Mock database to return None (model not found)
         mock_database.fetch_one.return_value = None
 
         headers = {"Authorization": "Bearer fake-token"}
         response = client.post(
-            "/api/v1/synthesize", json={"text": "Hello world", "model_id": 999}, headers=headers
+            "/api/v1/synthesize",
+            json={"text": "Hello world", "model_id": 999},
+            headers=headers,
         )
 
         assert response.status_code == 404
@@ -84,7 +94,9 @@ class TestSynthesisEndpoints:
         assert "audio_url" in data
         assert "processing_time" in data
 
-    def test_batch_synthesis(self, client, mock_auth_service, mock_database, sample_voice_model):
+    def test_batch_synthesis(
+        self, client, mock_auth_service, mock_database, sample_voice_model
+    ):
         """Test batch synthesis"""
         # Mock database responses
         mock_database.fetch_one.return_value = sample_voice_model
@@ -103,7 +115,9 @@ class TestSynthesisEndpoints:
         assert data["batch_size"] == 2
         assert len(data["job_ids"]) == 2
 
-    def test_get_synthesis_jobs(self, client, mock_auth_service, mock_database):
+    def test_get_synthesis_jobs(
+        self, client, mock_auth_service, mock_database
+    ):
         """Test getting synthesis jobs"""
         # Mock database response
         mock_database.fetch_all.return_value = [
@@ -129,7 +143,9 @@ class TestSynthesisEndpoints:
         assert data[0]["job_id"] == 1
         assert data[0]["status"] == "completed"
 
-    def test_get_synthesis_job_by_id(self, client, mock_auth_service, mock_database):
+    def test_get_synthesis_job_by_id(
+        self, client, mock_auth_service, mock_database
+    ):
         """Test getting specific synthesis job"""
         # Mock database response
         mock_database.fetch_one.return_value = {
@@ -152,7 +168,9 @@ class TestSynthesisEndpoints:
         assert data["job_id"] == 1
         assert data["status"] == "completed"
 
-    def test_get_synthesis_job_not_found(self, client, mock_auth_service, mock_database):
+    def test_get_synthesis_job_not_found(
+        self, client, mock_auth_service, mock_database
+    ):
         """Test getting non-existent synthesis job"""
         # Mock database to return None
         mock_database.fetch_one.return_value = None
@@ -169,14 +187,19 @@ class TestSynthesisEndpoints:
 
         # Test empty text
         response = client.post(
-            "/api/v1/synthesize", json={"text": "", "model_id": 1}, headers=headers
+            "/api/v1/synthesize",
+            json={"text": "", "model_id": 1},
+            headers=headers,
         )
         assert response.status_code == 422
 
         # Test text too long
         response = client.post(
             "/api/v1/synthesize",
-            json={"text": "x" * 1001, "model_id": 1},  # Over the 1000 character limit
+            json={
+                "text": "x" * 1001,
+                "model_id": 1,
+            },  # Over the 1000 character limit
             headers=headers,
         )
         assert response.status_code == 422
@@ -184,7 +207,11 @@ class TestSynthesisEndpoints:
         # Test invalid speed
         response = client.post(
             "/api/v1/synthesize",
-            json={"text": "Hello world", "model_id": 1, "speed": 3.0},  # Over the 2.0 limit
+            json={
+                "text": "Hello world",
+                "model_id": 1,
+                "speed": 3.0,
+            },  # Over the 2.0 limit
             headers=headers,
         )
         assert response.status_code == 422
diff --git a/services/training-worker/main.py b/services/training-worker/main.py
index f8d60dc..8ffd08f 100644
--- a/services/training-worker/main.py
+++ b/services/training-worker/main.py
@@ -91,7 +91,11 @@ def train_voice_model(self, task_data: Dict[str, Any]):
         # Update task status
         self.update_state(
             state=TrainingStatus.STARTED,
-            meta={"progress": 0, "status": "Training started", "current_step": "initializing"},
+            meta={
+                "progress": 0,
+                "status": "Training started",
+                "current_step": "initializing",
+            },
         )
 
         # Step 1: Preprocess training data
@@ -105,7 +109,9 @@ def train_voice_model(self, task_data: Dict[str, Any]):
             },
         )
 
-        processed_data = preprocess_training_data(task.training_data_urls, task.config)
+        processed_data = preprocess_training_data(
+            task.training_data_urls, task.config
+        )
 
         # Step 2: Initialize training
         self.update_state(
@@ -138,7 +144,9 @@ def train_voice_model(self, task_data: Dict[str, Any]):
             )
 
             # Simulate training step
-            train_step_result = simulate_training_step(processed_data, model_config, epoch)
+            train_step_result = simulate_training_step(
+                processed_data, model_config, epoch
+            )
 
             # Check for early stopping or cancellation
             if self.is_aborted():
@@ -156,16 +164,24 @@ def train_voice_model(self, task_data: Dict[str, Any]):
             },
         )
 
-        evaluation_metrics = evaluate_trained_model(processed_data, model_config)
+        evaluation_metrics = evaluate_trained_model(
+            processed_data, model_config
+        )
         task.model_metrics = evaluation_metrics
 
         # Step 5: Save and finalize model
         self.update_state(
             state=TrainingStatus.COMPLETED,
-            meta={"progress": 95, "status": "Saving trained model", "current_step": "saving"},
+            meta={
+                "progress": 95,
+                "status": "Saving trained model",
+                "current_step": "saving",
+            },
         )
 
-        model_path = save_trained_model(task.model_name, model_config, evaluation_metrics)
+        model_path = save_trained_model(
+            task.model_name, model_config, evaluation_metrics
+        )
 
         # Complete training
         task.status = TrainingStatus.COMPLETED
@@ -179,12 +195,16 @@ def train_voice_model(self, task_data: Dict[str, Any]):
             "task_id": task.task_id,
             "model_path": model_path,
             "metrics": evaluation_metrics,
-            "training_time": (task.completed_at - task.started_at).total_seconds(),
+            "training_time": (
+                task.completed_at - task.started_at
+            ).total_seconds(),
             "progress": 100,
         }
 
     except Exception as e:
-        logger.error(f"Training failed for task {task_data.get('task_id', 'unknown')}: {str(e)}")
+        logger.error(
+            f"Training failed for task {task_data.get('task_id', 'unknown')}: {str(e)}"
+        )
 
         task.status = TrainingStatus.FAILED
         task.error_message = str(e)
@@ -192,14 +212,20 @@ def train_voice_model(self, task_data: Dict[str, Any]):
 
         self.update_state(
             state=TrainingStatus.FAILED,
-            meta={"progress": task.progress, "status": "Training failed", "error": str(e)},
+            meta={
+                "progress": task.progress,
+                "status": "Training failed",
+                "error": str(e),
+            },
         )
 
         raise
 
 
 @celery_app.task(name="training_worker.evaluate_model")
-def evaluate_model(model_path: str, test_data_urls: List[str]) -> Dict[str, float]:
+def evaluate_model(
+    model_path: str, test_data_urls: List[str]
+) -> Dict[str, float]:
     """
     Evaluate a trained model against test data
 
@@ -259,7 +285,9 @@ def cleanup_training_data(task_id: str, keep_model: bool = True):
         raise
 
 
-def preprocess_training_data(data_urls: List[str], config: Dict[str, Any]) -> Dict[str, Any]:
+def preprocess_training_data(
+    data_urls: List[str], config: Dict[str, Any]
+) -> Dict[str, Any]:
     """Preprocess training data for model training"""
 
     logger.info(f"Preprocessing {len(data_urls)} training files")
@@ -309,7 +337,9 @@ def simulate_training_step(
     return {"loss": loss, "accuracy": accuracy, "epoch": epoch}
 
 
-def evaluate_trained_model(data: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, float]:
+def evaluate_trained_model(
+    data: Dict[str, Any], config: Dict[str, Any]
+) -> Dict[str, float]:
     """Evaluate the trained model"""
 
     # Placeholder evaluation metrics
@@ -326,10 +356,14 @@ def evaluate_trained_model(data: Dict[str, Any], config: Dict[str, Any]) -> Dict
     return metrics
 
 
-def save_trained_model(model_name: str, config: Dict[str, Any], metrics: Dict[str, float]) -> str:
+def save_trained_model(
+    model_name: str, config: Dict[str, Any], metrics: Dict[str, float]
+) -> str:
     """Save the trained model"""
 
-    model_path = f"/models/{model_name}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
+    model_path = (
+        f"/models/{model_name}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
+    )
 
     # Create model directory
     os.makedirs(model_path, exist_ok=True)
diff --git a/services/video-service/ai/__init__.py b/services/video-service/ai/__init__.py
index f5d894b..460657d 100644
--- a/services/video-service/ai/__init__.py
+++ b/services/video-service/ai/__init__.py
@@ -7,7 +7,11 @@ This module provides AI service clients for video generation:
 - Stable Diffusion for image generation and visual content
 """
 
-from .suno_client import SunoAIClient, VoiceGenerationRequest, VoiceGenerationResponse
+from .suno_client import (
+    SunoAIClient,
+    VoiceGenerationRequest,
+    VoiceGenerationResponse,
+)
 from .gemini_client import GeminiClient, ScriptScene, ScriptGenerationResponse
 from .stable_diffusion_client import (
     StableDiffusionClient,
diff --git a/services/video-service/ai/gemini_client.py b/services/video-service/ai/gemini_client.py
index 07adb40..f9133cb 100644
--- a/services/video-service/ai/gemini_client.py
+++ b/services/video-service/ai/gemini_client.py
@@ -51,9 +51,14 @@ class GeminiClient:
     async def _get_session(self) -> aiohttp.ClientSession:
         """Get or create aiohttp session"""
         if self.session is None or self.session.closed:
-            headers = {"Content-Type": "application/json", "User-Agent": "AutoVideoGeneration/1.0"}
+            headers = {
+                "Content-Type": "application/json",
+                "User-Agent": "AutoVideoGeneration/1.0",
+            }
             timeout = aiohttp.ClientTimeout(total=120)  # 2 minutes timeout
-            self.session = aiohttp.ClientSession(headers=headers, timeout=timeout)
+            self.session = aiohttp.ClientSession(
+                headers=headers, timeout=timeout
+            )
         return self.session
 
     async def health_check(self) -> Dict[str, Any]:
@@ -72,7 +77,11 @@ class GeminiClient:
                         "error": f"HTTP {response.status}",
                     }
         except Exception as e:
-            return {"status": "unhealthy", "service": "gemini", "error": str(e)}
+            return {
+                "status": "unhealthy",
+                "service": "gemini",
+                "error": str(e),
+            }
 
     async def generate_script(
         self,
@@ -85,9 +94,13 @@ class GeminiClient:
 
         try:
             # Create detailed prompt for script generation
-            prompt = self._create_script_prompt(theme, duration, style, target_platform)
+            prompt = self._create_script_prompt(
+                theme, duration, style, target_platform
+            )
 
-            logger.info(f"Generating script with Gemini Pro: theme='{theme}', duration={duration}s")
+            logger.info(
+                f"Generating script with Gemini Pro: theme='{theme}', duration={duration}s"
+            )
 
             # Generate script using Gemini Pro
             response_text = await self._generate_content(prompt)
@@ -126,7 +139,9 @@ class GeminiClient:
             logger.error(f"Script generation failed: {str(e)}")
             raise Exception(f"Failed to generate script: {str(e)}")
 
-    def _create_script_prompt(self, theme: str, duration: int, style: str, platform: str) -> str:
+    def _create_script_prompt(
+        self, theme: str, duration: int, style: str, platform: str
+    ) -> str:
         """Create detailed prompt for script generation"""
 
         platform_specs = {
@@ -189,8 +204,14 @@ Make sure the total duration of all scenes equals {duration} seconds.
                 "stopSequences": [],
             },
             "safetySettings": [
-                {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
-                {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
+                {
+                    "category": "HARM_CATEGORY_HARASSMENT",
+                    "threshold": "BLOCK_MEDIUM_AND_ABOVE",
+                },
+                {
+                    "category": "HARM_CATEGORY_HATE_SPEECH",
+                    "threshold": "BLOCK_MEDIUM_AND_ABOVE",
+                },
                 {
                     "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                     "threshold": "BLOCK_MEDIUM_AND_ABOVE",
@@ -205,7 +226,9 @@ Make sure the total duration of all scenes equals {duration} seconds.
         async with session.post(url, json=payload) as response:
             if response.status != 200:
                 error_text = await response.text()
-                raise Exception(f"Gemini API error: {response.status} - {error_text}")
+                raise Exception(
+                    f"Gemini API error: {response.status} - {error_text}"
+                )
 
             result = await response.json()
 
@@ -243,7 +266,9 @@ Make sure the total duration of all scenes equals {duration} seconds.
 
         except json.JSONDecodeError as e:
             # Fallback: create simple structure from text
-            logger.warning(f"Failed to parse JSON response, creating fallback structure: {e}")
+            logger.warning(
+                f"Failed to parse JSON response, creating fallback structure: {e}"
+            )
             return self._create_fallback_script(response_text)
         except Exception as e:
             logger.error(f"Error parsing script response: {e}")
@@ -261,11 +286,21 @@ Make sure the total duration of all scenes equals {duration} seconds.
 
         for i in range(scene_count):
             start_idx = i * sentences_per_scene
-            end_idx = start_idx + sentences_per_scene if i < scene_count - 1 else len(sentences)
+            end_idx = (
+                start_idx + sentences_per_scene
+                if i < scene_count - 1
+                else len(sentences)
+            )
 
             scene_text = ". ".join(sentences[start_idx:end_idx])
 
-            scene_type = "intro" if i == 0 else "outro" if i == scene_count - 1 else "main"
+            scene_type = (
+                "intro"
+                if i == 0
+                else "outro"
+                if i == scene_count - 1
+                else "main"
+            )
 
             scenes.append(
                 {
@@ -279,7 +314,9 @@ Make sure the total duration of all scenes equals {duration} seconds.
 
         return {"full_script": text, "scenes": scenes}
 
-    async def generate_caption_text(self, narration: str, style: str = "modern") -> List[str]:
+    async def generate_caption_text(
+        self, narration: str, style: str = "modern"
+    ) -> List[str]:
         """Generate formatted captions for video"""
 
         prompt = f"""
@@ -317,13 +354,17 @@ Please provide only the JSON array of caption segments.
             else:
                 # Fallback: split narration into chunks
                 words = narration.split()
-                return [" ".join(words[i : i + 5]) for i in range(0, len(words), 5)]
+                return [
+                    " ".join(words[i : i + 5]) for i in range(0, len(words), 5)
+                ]
 
         except Exception as e:
             logger.error(f"Caption generation failed: {e}")
             # Fallback: simple word chunking
             words = narration.split()
-            return [" ".join(words[i : i + 5]) for i in range(0, len(words), 5)]
+            return [
+                " ".join(words[i : i + 5]) for i in range(0, len(words), 5)
+            ]
 
     async def close(self):
         """Close the HTTP session"""
diff --git a/services/video-service/ai/stable_diffusion_client.py b/services/video-service/ai/stable_diffusion_client.py
index 61c23ec..f8d70b2 100644
--- a/services/video-service/ai/stable_diffusion_client.py
+++ b/services/video-service/ai/stable_diffusion_client.py
@@ -88,14 +88,18 @@ class StableDiffusionClient:
                 "User-Agent": "AutoVideoGeneration/1.0",
             }
             timeout = aiohttp.ClientTimeout(total=180)  # 3 minutes timeout
-            self.session = aiohttp.ClientSession(headers=headers, timeout=timeout)
+            self.session = aiohttp.ClientSession(
+                headers=headers, timeout=timeout
+            )
         return self.session
 
     async def health_check(self) -> Dict[str, Any]:
         """Check Stable Diffusion API health status"""
         try:
             session = await self._get_session()
-            async with session.get(f"{self.base_url}/user/account") as response:
+            async with session.get(
+                f"{self.base_url}/user/account"
+            ) as response:
                 if response.status == 200:
                     return {"status": "healthy", "service": "stable-diffusion"}
                 else:
@@ -105,7 +109,11 @@ class StableDiffusionClient:
                         "error": f"HTTP {response.status}",
                     }
         except Exception as e:
-            return {"status": "unhealthy", "service": "stable-diffusion", "error": str(e)}
+            return {
+                "status": "unhealthy",
+                "service": "stable-diffusion",
+                "error": str(e),
+            }
 
     async def generate_image(
         self,
@@ -120,7 +128,9 @@ class StableDiffusionClient:
             session = await self._get_session()
 
             # Get style configuration
-            style_config = self.style_presets.get(style, self.style_presets["modern"])
+            style_config = self.style_presets.get(
+                style, self.style_presets["modern"]
+            )
 
             # Convert aspect ratio to dimensions
             width, height = self._get_dimensions(aspect_ratio)
@@ -147,17 +157,20 @@ class StableDiffusionClient:
                 "sampler": "K_DPM_2_ANCESTRAL",
             }
 
-            logger.info(f"Generating image with Stable Diffusion: {enhanced_prompt[:100]}...")
+            logger.info(
+                f"Generating image with Stable Diffusion: {enhanced_prompt[:100]}..."
+            )
 
             # Submit generation request
             async with session.post(
                 f"{self.base_url}/generation/stable-diffusion-xl-1024-v1-0/text-to-image",
                 json=payload,
             ) as response:
-
                 if response.status != 200:
                     error_text = await response.text()
-                    raise Exception(f"Stable Diffusion API error: {response.status} - {error_text}")
+                    raise Exception(
+                        f"Stable Diffusion API error: {response.status} - {error_text}"
+                    )
 
                 result = await response.json()
 
@@ -170,7 +183,9 @@ class StableDiffusionClient:
 
                 # Save image and create thumbnail
                 generation_id = f"sd_{datetime.utcnow().timestamp()}"
-                image_url, thumbnail_url = await self._save_image(image_data, generation_id)
+                image_url, thumbnail_url = await self._save_image(
+                    image_data, generation_id
+                )
 
                 return ImageGenerationResponse(
                     url=image_url,
@@ -188,7 +203,10 @@ class StableDiffusionClient:
             raise Exception(f"Failed to generate image: {str(e)}")
 
     async def generate_image_batch(
-        self, prompts: List[str], style: str = "modern", aspect_ratio: str = "16:9"
+        self,
+        prompts: List[str],
+        style: str = "modern",
+        aspect_ratio: str = "16:9",
     ) -> List[ImageGenerationResponse]:
         """Generate multiple images in batch"""
 
@@ -203,7 +221,9 @@ class StableDiffusionClient:
         results = []
         for i in range(0, len(tasks), 3):  # Process 3 at a time
             batch = tasks[i : i + 3]
-            batch_results = await asyncio.gather(*batch, return_exceptions=True)
+            batch_results = await asyncio.gather(
+                *batch, return_exceptions=True
+            )
 
             for result in batch_results:
                 if isinstance(result, Exception):
@@ -243,13 +263,17 @@ class StableDiffusionClient:
 
         keywords = style_keywords.get(style, "")
         if keywords:
-            enhanced = f"{prompt}, {keywords}, high quality, detailed, sharp focus"
+            enhanced = (
+                f"{prompt}, {keywords}, high quality, detailed, sharp focus"
+            )
         else:
             enhanced = f"{prompt}, high quality, detailed, sharp focus"
 
         return enhanced
 
-    async def _save_image(self, image_data: bytes, generation_id: str) -> Tuple[str, str]:
+    async def _save_image(
+        self, image_data: bytes, generation_id: str
+    ) -> Tuple[str, str]:
         """Save image and create thumbnail, return URLs"""
 
         # Create directories if they don't exist
@@ -280,7 +304,9 @@ class StableDiffusionClient:
         base_url = os.getenv("MEDIA_BASE_URL", "http://localhost:8003")
         image_url = f"{base_url}/media/images/{image_filename}"
         thumbnail_url = (
-            f"{base_url}/media/thumbnails/{thumbnail_filename}" if thumbnail_path else None
+            f"{base_url}/media/thumbnails/{thumbnail_filename}"
+            if thumbnail_path
+            else None
         )
 
         return image_url, thumbnail_url
@@ -296,7 +322,9 @@ class StableDiffusionClient:
             # Download the original image
             async with session.get(image_url) as response:
                 if response.status != 200:
-                    raise Exception(f"Failed to download image: {response.status}")
+                    raise Exception(
+                        f"Failed to download image: {response.status}"
+                    )
 
                 image_data = await response.read()
                 image_b64 = base64.b64encode(image_data).decode()
@@ -308,12 +336,14 @@ class StableDiffusionClient:
             }
 
             async with session.post(
-                f"{self.base_url}/generation/esrgan-v1-x2plus/image-to-image/upscale", json=payload
+                f"{self.base_url}/generation/esrgan-v1-x2plus/image-to-image/upscale",
+                json=payload,
             ) as response:
-
                 if response.status != 200:
                     error_text = await response.text()
-                    raise Exception(f"Upscale API error: {response.status} - {error_text}")
+                    raise Exception(
+                        f"Upscale API error: {response.status} - {error_text}"
+                    )
 
                 result = await response.json()
                 artifact = result["artifacts"][0]
@@ -321,7 +351,9 @@ class StableDiffusionClient:
 
                 # Save upscaled image
                 generation_id = f"upscale_{datetime.utcnow().timestamp()}"
-                upscaled_url, thumbnail_url = await self._save_image(upscaled_data, generation_id)
+                upscaled_url, thumbnail_url = await self._save_image(
+                    upscaled_data, generation_id
+                )
 
                 return ImageGenerationResponse(
                     url=upscaled_url,
diff --git a/services/video-service/ai/suno_client.py b/services/video-service/ai/suno_client.py
index f743aa7..6200688 100644
--- a/services/video-service/ai/suno_client.py
+++ b/services/video-service/ai/suno_client.py
@@ -50,7 +50,9 @@ class SunoAIClient:
                 "User-Agent": "AutoVideoGeneration/1.0",
             }
             timeout = aiohttp.ClientTimeout(total=300)  # 5 minutes timeout
-            self.session = aiohttp.ClientSession(headers=headers, timeout=timeout)
+            self.session = aiohttp.ClientSession(
+                headers=headers, timeout=timeout
+            )
         return self.session
 
     async def health_check(self) -> Dict[str, Any]:
@@ -67,7 +69,11 @@ class SunoAIClient:
                         "error": f"HTTP {response.status}",
                     }
         except Exception as e:
-            return {"status": "unhealthy", "service": "suno.ai", "error": str(e)}
+            return {
+                "status": "unhealthy",
+                "service": "suno.ai",
+                "error": str(e),
+            }
 
     async def generate_voice(
         self,
@@ -102,19 +108,27 @@ class SunoAIClient:
                 "quality": "high",
             }
 
-            logger.info(f"Generating voice with Suno.ai: {len(text)} characters")
+            logger.info(
+                f"Generating voice with Suno.ai: {len(text)} characters"
+            )
 
             # Submit generation request
-            async with session.post(f"{self.base_url}/generate", json=payload) as response:
+            async with session.post(
+                f"{self.base_url}/generate", json=payload
+            ) as response:
                 if response.status != 200:
                     error_text = await response.text()
-                    raise Exception(f"Suno.ai API error: {response.status} - {error_text}")
+                    raise Exception(
+                        f"Suno.ai API error: {response.status} - {error_text}"
+                    )
 
                 result = await response.json()
                 generation_id = result["generation_id"]
 
             # Poll for completion
-            audio_url, music_url, duration = await self._wait_for_completion(generation_id)
+            audio_url, music_url, duration = await self._wait_for_completion(
+                generation_id
+            )
 
             return VoiceGenerationResponse(
                 audio_url=audio_url,
@@ -138,27 +152,41 @@ class SunoAIClient:
 
         while True:
             try:
-                async with session.get(f"{self.base_url}/generate/{generation_id}") as response:
+                async with session.get(
+                    f"{self.base_url}/generate/{generation_id}"
+                ) as response:
                     if response.status != 200:
-                        raise Exception(f"Failed to check generation status: {response.status}")
+                        raise Exception(
+                            f"Failed to check generation status: {response.status}"
+                        )
 
                     result = await response.json()
                     status = result["status"]
 
                     if status == "completed":
-                        return (result["audio_url"], result.get("music_url"), result["duration"])
+                        return (
+                            result["audio_url"],
+                            result.get("music_url"),
+                            result["duration"],
+                        )
                     elif status == "failed":
                         raise Exception(
                             f"Voice generation failed: {result.get('error', 'Unknown error')}"
                         )
                     elif status in ["queued", "processing"]:
                         # Check timeout
-                        elapsed = (datetime.utcnow() - start_time).total_seconds()
+                        elapsed = (
+                            datetime.utcnow() - start_time
+                        ).total_seconds()
                         if elapsed > max_wait:
-                            raise Exception(f"Voice generation timeout after {max_wait} seconds")
+                            raise Exception(
+                                f"Voice generation timeout after {max_wait} seconds"
+                            )
 
                         logger.info(f"Voice generation in progress: {status}")
-                        await asyncio.sleep(5)  # Wait 5 seconds before next check
+                        await asyncio.sleep(
+                            5
+                        )  # Wait 5 seconds before next check
                     else:
                         raise Exception(f"Unknown generation status: {status}")
 
@@ -185,9 +213,13 @@ class SunoAIClient:
         """Get list of available music genres"""
         try:
             session = await self._get_session()
-            async with session.get(f"{self.base_url}/music/genres") as response:
+            async with session.get(
+                f"{self.base_url}/music/genres"
+            ) as response:
                 if response.status != 200:
-                    raise Exception(f"Failed to get music genres: {response.status}")
+                    raise Exception(
+                        f"Failed to get music genres: {response.status}"
+                    )
 
                 result = await response.json()
                 return result["genres"]
@@ -196,7 +228,9 @@ class SunoAIClient:
             logger.error(f"Failed to get available music genres: {str(e)}")
             return ["ambient", "cinematic", "upbeat", "calm", "dramatic"]
 
-    async def clone_voice(self, voice_sample_url: str, text: str) -> VoiceGenerationResponse:
+    async def clone_voice(
+        self, voice_sample_url: str, text: str
+    ) -> VoiceGenerationResponse:
         """Clone a voice from a sample and generate speech"""
 
         try:
@@ -205,23 +239,35 @@ class SunoAIClient:
             payload = {
                 "voice_sample_url": voice_sample_url,
                 "text": text,
-                "clone_settings": {"similarity_boost": True, "stability": 0.75, "clarity": 0.75},
+                "clone_settings": {
+                    "similarity_boost": True,
+                    "stability": 0.75,
+                    "clarity": 0.75,
+                },
                 "output_format": "mp3",
                 "quality": "high",
             }
 
-            logger.info(f"Cloning voice and generating speech: {len(text)} characters")
+            logger.info(
+                f"Cloning voice and generating speech: {len(text)} characters"
+            )
 
-            async with session.post(f"{self.base_url}/clone", json=payload) as response:
+            async with session.post(
+                f"{self.base_url}/clone", json=payload
+            ) as response:
                 if response.status != 200:
                     error_text = await response.text()
-                    raise Exception(f"Voice cloning API error: {response.status} - {error_text}")
+                    raise Exception(
+                        f"Voice cloning API error: {response.status} - {error_text}"
+                    )
 
                 result = await response.json()
                 generation_id = result["generation_id"]
 
             # Wait for completion
-            audio_url, _, duration = await self._wait_for_completion(generation_id)
+            audio_url, _, duration = await self._wait_for_completion(
+                generation_id
+            )
 
             return VoiceGenerationResponse(
                 audio_url=audio_url,
diff --git a/services/video-service/auth.py b/services/video-service/auth.py
index 9292b37..ff46522 100644
--- a/services/video-service/auth.py
+++ b/services/video-service/auth.py
@@ -37,7 +37,9 @@ async def verify_token(token: str) -> Optional[str]:
         # Get JWT settings from environment
         jwt_secret = os.getenv("JWT_SECRET_KEY")
         jwt_algorithm = os.getenv("JWT_ALGORITHM", "HS256")
-        auth_service_url = os.getenv("AUTH_SERVICE_URL", "http://localhost:8001")
+        auth_service_url = os.getenv(
+            "AUTH_SERVICE_URL", "http://localhost:8001"
+        )
 
         if not jwt_secret:
             # If no local JWT secret, validate with auth service
@@ -46,7 +48,10 @@ async def verify_token(token: str) -> Optional[str]:
         # Decode and verify token locally
         try:
             payload = jwt.decode(
-                token, jwt_secret, algorithms=[jwt_algorithm], options={"verify_exp": True}
+                token,
+                jwt_secret,
+                algorithms=[jwt_algorithm],
+                options={"verify_exp": True},
             )
 
             # Extract user ID from payload
@@ -76,7 +81,9 @@ async def verify_token(token: str) -> Optional[str]:
         return None
 
 
-async def verify_token_remote(token: str, auth_service_url: str) -> Optional[str]:
+async def verify_token_remote(
+    token: str, auth_service_url: str
+) -> Optional[str]:
     """
     Verify token with remote authentication service
 
@@ -97,16 +104,19 @@ async def verify_token_remote(token: str, auth_service_url: str) -> Optional[str
                 headers=headers,
                 timeout=aiohttp.ClientTimeout(total=10),
             ) as response:
-
                 if response.status == 200:
                     result = await response.json()
                     user_id = result.get("user_id")
 
                     if user_id:
-                        logger.debug(f"Remote token validated for user: {user_id}")
+                        logger.debug(
+                            f"Remote token validated for user: {user_id}"
+                        )
                         return user_id
                     else:
-                        logger.warning("Remote verification returned no user ID")
+                        logger.warning(
+                            "Remote verification returned no user ID"
+                        )
                         return None
 
                 elif response.status == 401:
@@ -136,7 +146,9 @@ async def get_user_info(token: str) -> Optional[Dict[str, Any]]:
     """
 
     try:
-        auth_service_url = os.getenv("AUTH_SERVICE_URL", "http://localhost:8001")
+        auth_service_url = os.getenv(
+            "AUTH_SERVICE_URL", "http://localhost:8001"
+        )
 
         async with aiohttp.ClientSession() as session:
             headers = {"Authorization": f"Bearer {token}"}
@@ -146,13 +158,16 @@ async def get_user_info(token: str) -> Optional[Dict[str, Any]]:
                 headers=headers,
                 timeout=aiohttp.ClientTimeout(total=10),
             ) as response:
-
                 if response.status == 200:
                     user_info = await response.json()
-                    logger.debug(f"Retrieved user info for: {user_info.get('id')}")
+                    logger.debug(
+                        f"Retrieved user info for: {user_info.get('id')}"
+                    )
                     return user_info
                 else:
-                    logger.warning(f"Failed to get user info: {response.status}")
+                    logger.warning(
+                        f"Failed to get user info: {response.status}"
+                    )
                     return None
 
     except Exception as e:
@@ -185,7 +200,9 @@ def create_service_token(service_name: str, expires_in: int = 3600) -> str:
             "service": service_name,
         }
 
-        token = jwt.encode(payload, jwt_secret, algorithm=os.getenv("JWT_ALGORITHM", "HS256"))
+        token = jwt.encode(
+            payload, jwt_secret, algorithm=os.getenv("JWT_ALGORITHM", "HS256")
+        )
 
         logger.debug(f"Created service token for: {service_name}")
         return token
@@ -195,7 +212,9 @@ def create_service_token(service_name: str, expires_in: int = 3600) -> str:
         raise AuthenticationError(f"Failed to create service token: {str(e)}")
 
 
-async def check_user_permissions(user_id: str, resource: str, action: str) -> bool:
+async def check_user_permissions(
+    user_id: str, resource: str, action: str
+) -> bool:
     """
     Check if user has permission to perform action on resource
 
@@ -209,13 +228,19 @@ async def check_user_permissions(user_id: str, resource: str, action: str) -> bo
     """
 
     try:
-        auth_service_url = os.getenv("AUTH_SERVICE_URL", "http://localhost:8001")
+        auth_service_url = os.getenv(
+            "AUTH_SERVICE_URL", "http://localhost:8001"
+        )
         service_token = create_service_token("video-service")
 
         async with aiohttp.ClientSession() as session:
             headers = {"Authorization": f"Bearer {service_token}"}
 
-            payload = {"user_id": user_id, "resource": resource, "action": action}
+            payload = {
+                "user_id": user_id,
+                "resource": resource,
+                "action": action,
+            }
 
             async with session.post(
                 f"{auth_service_url}/api/v1/auth/permissions/check",
@@ -223,7 +248,6 @@ async def check_user_permissions(user_id: str, resource: str, action: str) -> bo
                 json=payload,
                 timeout=aiohttp.ClientTimeout(total=10),
             ) as response:
-
                 if response.status == 200:
                     result = await response.json()
                     has_permission = result.get("allowed", False)
@@ -233,7 +257,9 @@ async def check_user_permissions(user_id: str, resource: str, action: str) -> bo
                     )
                     return has_permission
                 else:
-                    logger.warning(f"Permission check failed: {response.status}")
+                    logger.warning(
+                        f"Permission check failed: {response.status}"
+                    )
                     return False
 
     except Exception as e:
@@ -300,19 +326,28 @@ class TokenValidator:
 
         try:
             payload = jwt.decode(
-                token, self.jwt_secret, algorithms=[self.algorithm], options={"verify_exp": True}
+                token,
+                self.jwt_secret,
+                algorithms=[self.algorithm],
+                options={"verify_exp": True},
             )
 
             return payload
 
         except jwt.ExpiredSignatureError:
             raise HTTPException(
-                status_code=status.HTTP_401_UNAUTHORIZED, detail="Token has expired"
+                status_code=status.HTTP_401_UNAUTHORIZED,
+                detail="Token has expired",
             )
         except jwt.InvalidTokenError:
-            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token")
+            raise HTTPException(
+                status_code=status.HTTP_401_UNAUTHORIZED,
+                detail="Invalid token",
+            )
 
-    async def validate_service_token(self, token: str, required_service: str) -> bool:
+    async def validate_service_token(
+        self, token: str, required_service: str
+    ) -> bool:
         """
         Validate service-to-service token
 
diff --git a/services/video-service/database.py b/services/video-service/database.py
index 44760b1..a07504f 100644
--- a/services/video-service/database.py
+++ b/services/video-service/database.py
@@ -33,7 +33,9 @@ class DatabaseManager:
 
         return f"postgresql://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}"
 
-    async def initialize(self, min_connections: int = 5, max_connections: int = 20):
+    async def initialize(
+        self, min_connections: int = 5, max_connections: int = 20
+    ):
         """Initialize database connection pool"""
 
         try:
@@ -70,7 +72,9 @@ class DatabaseManager:
         try:
             async with self.pool.acquire() as conn:
                 # Create extensions if needed
-                await conn.execute('CREATE EXTENSION IF NOT EXISTS "uuid-ossp";')
+                await conn.execute(
+                    'CREATE EXTENSION IF NOT EXISTS "uuid-ossp";'
+                )
                 await conn.execute('CREATE EXTENSION IF NOT EXISTS "pg_trgm";')
 
                 # Import and create tables
@@ -125,7 +129,11 @@ class DatabaseManager:
                 }
 
         except Exception as e:
-            return {"status": "unhealthy", "database": "postgresql", "error": str(e)}
+            return {
+                "status": "unhealthy",
+                "database": "postgresql",
+                "error": str(e),
+            }
 
 
 # Global database manager instance
@@ -243,7 +251,12 @@ async def run_migrations():
             )
 
             # Get current version
-            current_version = await conn.fetchval("SELECT MAX(version) FROM schema_migrations") or 0
+            current_version = (
+                await conn.fetchval(
+                    "SELECT MAX(version) FROM schema_migrations"
+                )
+                or 0
+            )
 
             # Define migrations
             migrations = {
@@ -273,10 +286,13 @@ async def run_migrations():
                     async with conn.transaction():
                         await conn.execute(sql)
                         await conn.execute(
-                            "INSERT INTO schema_migrations (version) VALUES ($1)", version
+                            "INSERT INTO schema_migrations (version) VALUES ($1)",
+                            version,
                         )
 
-                    logger.info(f"Migration version {version} applied successfully")
+                    logger.info(
+                        f"Migration version {version} applied successfully"
+                    )
 
             logger.info("All migrations completed")
 
diff --git a/services/video-service/main.py b/services/video-service/main.py
index d6222a2..45b00a3 100644
--- a/services/video-service/main.py
+++ b/services/video-service/main.py
@@ -49,7 +49,9 @@ security = HTTPBearer()
 # AI Clients initialization
 suno_client = SunoAIClient(api_key=os.getenv("SUNO_API_KEY"))
 gemini_client = GeminiClient(api_key=os.getenv("GEMINI_API_KEY"))
-stable_diffusion_client = StableDiffusionClient(api_key=os.getenv("STABLE_DIFFUSION_API_KEY"))
+stable_diffusion_client = StableDiffusionClient(
+    api_key=os.getenv("STABLE_DIFFUSION_API_KEY")
+)
 video_composer = VideoComposer()
 
 
@@ -57,11 +59,21 @@ class VideoGenerationRequest(BaseModel):
     title: str = Field(..., min_length=1, max_length=200)
     description: Optional[str] = Field(None, max_length=1000)
     theme: str = Field(..., description="Video theme/topic")
-    style: Optional[str] = Field("modern", description="Visual style preference")
-    duration: Optional[int] = Field(60, ge=15, le=300, description="Video duration in seconds")
-    voice_type: Optional[str] = Field("default", description="Voice style for narration")
-    music_genre: Optional[str] = Field("ambient", description="Background music genre")
-    include_captions: bool = Field(True, description="Whether to include captions")
+    style: Optional[str] = Field(
+        "modern", description="Visual style preference"
+    )
+    duration: Optional[int] = Field(
+        60, ge=15, le=300, description="Video duration in seconds"
+    )
+    voice_type: Optional[str] = Field(
+        "default", description="Voice style for narration"
+    )
+    music_genre: Optional[str] = Field(
+        "ambient", description="Background music genre"
+    )
+    include_captions: bool = Field(
+        True, description="Whether to include captions"
+    )
     target_platform: Optional[str] = Field(
         "youtube", description="Target platform (youtube, tiktok, instagram)"
     )
@@ -105,7 +117,9 @@ async def create_video_project(
     # Verify user authentication
     user_id = await verify_token(credentials.credentials)
     if not user_id:
-        raise HTTPException(status_code=401, detail="Invalid authentication token")
+        raise HTTPException(
+            status_code=401, detail="Invalid authentication token"
+        )
 
     # Create project record
     project_id = str(uuid.uuid4())
@@ -146,7 +160,9 @@ async def create_video_project(
     )
 
 
-@app.get("/api/v1/video/projects/{project_id}", response_model=VideoProjectResponse)
+@app.get(
+    "/api/v1/video/projects/{project_id}", response_model=VideoProjectResponse
+)
 async def get_video_project(
     project_id: str,
     credentials: HTTPAuthorizationCredentials = Depends(security),
@@ -156,7 +172,9 @@ async def get_video_project(
 
     user_id = await verify_token(credentials.credentials)
     if not user_id:
-        raise HTTPException(status_code=401, detail="Invalid authentication token")
+        raise HTTPException(
+            status_code=401, detail="Invalid authentication token"
+        )
 
     project = await VideoProject.get_by_id(db, project_id)
     if not project:
@@ -188,9 +206,13 @@ async def list_user_projects(
 
     user_id = await verify_token(credentials.credentials)
     if not user_id:
-        raise HTTPException(status_code=401, detail="Invalid authentication token")
+        raise HTTPException(
+            status_code=401, detail="Invalid authentication token"
+        )
 
-    projects = await VideoProject.get_by_user(db, user_id, limit=limit, offset=offset)
+    projects = await VideoProject.get_by_user(
+        db, user_id, limit=limit, offset=offset
+    )
 
     return [
         VideoProjectResponse(
@@ -217,7 +239,9 @@ async def delete_video_project(
 
     user_id = await verify_token(credentials.credentials)
     if not user_id:
-        raise HTTPException(status_code=401, detail="Invalid authentication token")
+        raise HTTPException(
+            status_code=401, detail="Invalid authentication token"
+        )
 
     project = await VideoProject.get_by_id(db, project_id)
     if not project:
@@ -233,7 +257,9 @@ async def delete_video_project(
     return {"message": "Project deleted successfully"}
 
 
-async def generate_video_pipeline(project_id: str, request: VideoGenerationRequest):
+async def generate_video_pipeline(
+    project_id: str, request: VideoGenerationRequest
+):
     """Background video generation pipeline"""
 
     try:
@@ -322,9 +348,13 @@ async def generate_video_pipeline(project_id: str, request: VideoGenerationReque
         logger.info(f"Video generation completed for project {project_id}")
 
     except Exception as e:
-        logger.error(f"Video generation failed for project {project_id}: {str(e)}")
+        logger.error(
+            f"Video generation failed for project {project_id}: {str(e)}"
+        )
         try:
-            await project.update_status(db, VideoStatus.FAILED, project.progress)
+            await project.update_status(
+                db, VideoStatus.FAILED, project.progress
+            )
             project.error_message = str(e)
             await project.save(db)
         except:
@@ -333,7 +363,12 @@ async def generate_video_pipeline(project_id: str, request: VideoGenerationReque
 
 def get_aspect_ratio(platform: str) -> str:
     """Get aspect ratio based on target platform"""
-    ratios = {"youtube": "16:9", "tiktok": "9:16", "instagram": "1:1", "default": "16:9"}
+    ratios = {
+        "youtube": "16:9",
+        "tiktok": "9:16",
+        "instagram": "1:1",
+        "default": "16:9",
+    }
     return ratios.get(platform, "16:9")
 
 
diff --git a/services/video-service/models/video_project.py b/services/video-service/models/video_project.py
index 8a856dd..71752d4 100644
--- a/services/video-service/models/video_project.py
+++ b/services/video-service/models/video_project.py
@@ -247,12 +247,16 @@ class VideoProject(BaseModel):
         )
 
     @classmethod
-    async def get_by_id(cls, db_pool, project_id: str) -> Optional["VideoProject"]:
+    async def get_by_id(
+        cls, db_pool, project_id: str
+    ) -> Optional["VideoProject"]:
         """Get video project by ID"""
 
         try:
             async with db_pool.acquire() as conn:
-                row = await conn.fetchrow("SELECT * FROM video_projects WHERE id = $1", project_id)
+                row = await conn.fetchrow(
+                    "SELECT * FROM video_projects WHERE id = $1", project_id
+                )
 
                 if not row:
                     return None
@@ -292,7 +296,7 @@ class VideoProject(BaseModel):
                 SELECT * FROM video_projects 
                 {where_clause}
                 ORDER BY created_at DESC 
-                LIMIT {param_nums.split(', ')[0]} OFFSET {param_nums.split(', ')[1]}
+                LIMIT {param_nums.split(", ")[0]} OFFSET {param_nums.split(", ")[1]}
                 """
 
                 rows = await conn.fetch(query, *params)
@@ -300,7 +304,9 @@ class VideoProject(BaseModel):
                 return [cls._from_db_row(row) for row in rows]
 
         except Exception as e:
-            logger.error(f"Failed to get video projects for user {user_id}: {str(e)}")
+            logger.error(
+                f"Failed to get video projects for user {user_id}: {str(e)}"
+            )
             return []
 
     @classmethod
@@ -323,10 +329,14 @@ class VideoProject(BaseModel):
             progress=row["progress"],
             error_message=row["error_message"],
             script_content=row["script_content"],
-            script_scenes=json.loads(row["script_scenes"]) if row["script_scenes"] else None,
+            script_scenes=json.loads(row["script_scenes"])
+            if row["script_scenes"]
+            else None,
             voice_url=row["voice_url"],
             music_url=row["music_url"],
-            image_urls=json.loads(row["image_urls"]) if row["image_urls"] else None,
+            image_urls=json.loads(row["image_urls"])
+            if row["image_urls"]
+            else None,
             preview_url=row["preview_url"],
             final_url=row["final_url"],
             thumbnail_url=row["thumbnail_url"],
@@ -340,7 +350,11 @@ class VideoProject(BaseModel):
         )
 
     async def update_status(
-        self, db_pool, status: VideoStatus, progress: int, error_message: Optional[str] = None
+        self,
+        db_pool,
+        status: VideoStatus,
+        progress: int,
+        error_message: Optional[str] = None,
     ):
         """Update project status and progress"""
 
@@ -362,8 +376,12 @@ class VideoProject(BaseModel):
             VideoStatus.RENDERING,
         ]:
             # Rough estimation based on current progress
-            remaining_time = max(0, (100 - progress) * 2)  # 2 seconds per percent
-            self.estimated_completion = datetime.utcnow() + timedelta(seconds=remaining_time)
+            remaining_time = max(
+                0, (100 - progress) * 2
+            )  # 2 seconds per percent
+            self.estimated_completion = datetime.utcnow() + timedelta(
+                seconds=remaining_time
+            )
 
         await self.save(db_pool)
 
@@ -372,7 +390,9 @@ class VideoProject(BaseModel):
 
         try:
             async with db_pool.acquire() as conn:
-                await conn.execute("DELETE FROM video_projects WHERE id = $1", self.id)
+                await conn.execute(
+                    "DELETE FROM video_projects WHERE id = $1", self.id
+                )
 
                 logger.info(f"Deleted video project: {self.id}")
 
@@ -386,13 +406,16 @@ class VideoProject(BaseModel):
         try:
             async with db_pool.acquire() as conn:
                 await conn.execute(
-                    "UPDATE video_projects SET view_count = view_count + 1 WHERE id = $1", self.id
+                    "UPDATE video_projects SET view_count = view_count + 1 WHERE id = $1",
+                    self.id,
                 )
 
                 self.view_count += 1
 
         except Exception as e:
-            logger.error(f"Failed to increment view count for {self.id}: {str(e)}")
+            logger.error(
+                f"Failed to increment view count for {self.id}: {str(e)}"
+            )
 
     async def increment_download_count(self, db_pool):
         """Increment download count"""
@@ -407,7 +430,9 @@ class VideoProject(BaseModel):
                 self.download_count += 1
 
         except Exception as e:
-            logger.error(f"Failed to increment download count for {self.id}: {str(e)}")
+            logger.error(
+                f"Failed to increment download count for {self.id}: {str(e)}"
+            )
 
     async def toggle_like(self, db_pool, increment: bool = True):
         """Toggle like count"""
@@ -446,11 +471,19 @@ class VideoProject(BaseModel):
             "preview_url": self.preview_url,
             "final_url": self.final_url,
             "thumbnail_url": self.thumbnail_url,
-            "created_at": self.created_at.isoformat() if self.created_at else None,
-            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
-            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
+            "created_at": self.created_at.isoformat()
+            if self.created_at
+            else None,
+            "updated_at": self.updated_at.isoformat()
+            if self.updated_at
+            else None,
+            "completed_at": self.completed_at.isoformat()
+            if self.completed_at
+            else None,
             "estimated_completion": (
-                self.estimated_completion.isoformat() if self.estimated_completion else None
+                self.estimated_completion.isoformat()
+                if self.estimated_completion
+                else None
             ),
             "view_count": self.view_count,
             "download_count": self.download_count,
diff --git a/services/video-service/social/platforms.py b/services/video-service/social/platforms.py
index c0c9533..62e0d84 100644
--- a/services/video-service/social/platforms.py
+++ b/services/video-service/social/platforms.py
@@ -101,10 +101,14 @@ class TikTokClient(SocialPlatform):
             upload_result = await self._upload_video(request.video_url)
 
             if not upload_result.get("success"):
-                raise Exception(f"Video upload failed: {upload_result.get('error')}")
+                raise Exception(
+                    f"Video upload failed: {upload_result.get('error')}"
+                )
 
             # Step 2: Create post
-            post_result = await self._create_post(upload_result["video_id"], request)
+            post_result = await self._create_post(
+                upload_result["video_id"], request
+            )
 
             return PublishResult(
                 platform="tiktok",
@@ -141,26 +145,36 @@ class TikTokClient(SocialPlatform):
 
         # Upload to TikTok
         data = aiohttp.FormData()
-        data.add_field("video", video_data, filename="video.mp4", content_type="video/mp4")
+        data.add_field(
+            "video", video_data, filename="video.mp4", content_type="video/mp4"
+        )
 
-        headers = {"Authorization": f"Bearer {self.api_key}", "Content-Type": "multipart/form-data"}
+        headers = {
+            "Authorization": f"Bearer {self.api_key}",
+            "Content-Type": "multipart/form-data",
+        }
 
         async with session.post(
             f"{self.upload_url}/video/upload", data=data, headers=headers
         ) as response:
-
             if response.status != 200:
                 error_text = await response.text()
-                raise Exception(f"TikTok upload API error: {response.status} - {error_text}")
+                raise Exception(
+                    f"TikTok upload API error: {response.status} - {error_text}"
+                )
 
             result = await response.json()
 
             if result.get("error"):
-                raise Exception(f"TikTok upload error: {result['error']['message']}")
+                raise Exception(
+                    f"TikTok upload error: {result['error']['message']}"
+                )
 
             return {"success": True, "video_id": result["data"]["video_id"]}
 
-    async def _create_post(self, video_id: str, request: PublishRequest) -> Dict[str, Any]:
+    async def _create_post(
+        self, video_id: str, request: PublishRequest
+    ) -> Dict[str, Any]:
         """Create TikTok post"""
 
         session = await self._get_session()
@@ -168,27 +182,35 @@ class TikTokClient(SocialPlatform):
         payload = {
             "video_id": video_id,
             "text": request.description or request.title,
-            "privacy_level": "PUBLIC_TO_EVERYONE" if request.privacy == "public" else "SELF_ONLY",
+            "privacy_level": "PUBLIC_TO_EVERYONE"
+            if request.privacy == "public"
+            else "SELF_ONLY",
             "disable_duet": False,
             "disable_comment": False,
             "disable_stitch": False,
             "video_cover_timestamp_ms": 1000,
         }
 
-        headers = {"Authorization": f"Bearer {self.api_key}", "Content-Type": "application/json"}
+        headers = {
+            "Authorization": f"Bearer {self.api_key}",
+            "Content-Type": "application/json",
+        }
 
         async with session.post(
             f"{self.base_url}/video/publish", json=payload, headers=headers
         ) as response:
-
             if response.status != 200:
                 error_text = await response.text()
-                raise Exception(f"TikTok publish API error: {response.status} - {error_text}")
+                raise Exception(
+                    f"TikTok publish API error: {response.status} - {error_text}"
+                )
 
             result = await response.json()
 
             if result.get("error"):
-                raise Exception(f"TikTok publish error: {result['error']['message']}")
+                raise Exception(
+                    f"TikTok publish error: {result['error']['message']}"
+                )
 
             return {
                 "video_id": result["data"]["video_id"],
@@ -207,9 +229,10 @@ class TikTokClient(SocialPlatform):
             }
 
             async with session.get(
-                f"{self.base_url}/video/query", params={"video_id": platform_id}, headers=headers
+                f"{self.base_url}/video/query",
+                params={"video_id": platform_id},
+                headers=headers,
             ) as response:
-
                 if response.status != 200:
                     return {"error": f"API error: {response.status}"}
 
@@ -244,9 +267,10 @@ class TikTokClient(SocialPlatform):
             }
 
             async with session.delete(
-                f"{self.base_url}/video/delete", params={"video_id": platform_id}, headers=headers
+                f"{self.base_url}/video/delete",
+                params={"video_id": platform_id},
+                headers=headers,
             ) as response:
-
                 return response.status == 200
 
         except Exception as e:
@@ -290,7 +314,9 @@ class YouTubeClient(SocialPlatform):
                 published_at=datetime.utcnow(),
             )
 
-    async def _upload_video_with_metadata(self, request: PublishRequest) -> Dict[str, Any]:
+    async def _upload_video_with_metadata(
+        self, request: PublishRequest
+    ) -> Dict[str, Any]:
         """Upload video to YouTube with metadata"""
 
         session = await self._get_session()
@@ -303,7 +329,10 @@ class YouTubeClient(SocialPlatform):
             "categoryId": "22",  # People & Blogs
         }
 
-        status = {"privacyStatus": request.privacy, "selfDeclaredMadeForKids": False}
+        status = {
+            "privacyStatus": request.privacy,
+            "selfDeclaredMadeForKids": False,
+        }
 
         metadata = {"snippet": snippet, "status": status}
 
@@ -348,17 +377,20 @@ class YouTubeClient(SocialPlatform):
             data=body,
             headers=headers,
         ) as response:
-
             if response.status != 200:
                 error_text = await response.text()
-                raise Exception(f"YouTube upload API error: {response.status} - {error_text}")
+                raise Exception(
+                    f"YouTube upload API error: {response.status} - {error_text}"
+                )
 
             result = await response.json()
 
             return {
                 "video_id": result["id"],
                 "upload_status": result.get("status", {}).get("uploadStatus"),
-                "privacy_status": result.get("status", {}).get("privacyStatus"),
+                "privacy_status": result.get("status", {}).get(
+                    "privacyStatus"
+                ),
             }
 
     async def get_video_stats(self, platform_id: str) -> Dict[str, Any]:
@@ -367,9 +399,15 @@ class YouTubeClient(SocialPlatform):
         try:
             session = await self._get_session()
 
-            params = {"part": "statistics,status", "id": platform_id, "key": self.api_key}
+            params = {
+                "part": "statistics,status",
+                "id": platform_id,
+                "key": self.api_key,
+            }
 
-            async with session.get(f"{self.base_url}/videos", params=params) as response:
+            async with session.get(
+                f"{self.base_url}/videos", params=params
+            ) as response:
                 if response.status != 200:
                     return {"error": f"API error: {response.status}"}
 
@@ -404,9 +442,10 @@ class YouTubeClient(SocialPlatform):
             }
 
             async with session.delete(
-                f"{self.base_url}/videos", params={"id": platform_id}, headers=headers
+                f"{self.base_url}/videos",
+                params={"id": platform_id},
+                headers=headers,
             ) as response:
-
                 return response.status == 204
 
         except Exception as e:
@@ -440,7 +479,10 @@ class InstagramClient(SocialPlatform):
                 platform_id=result["media_id"],
                 url=result.get("permalink"),
                 published_at=datetime.utcnow(),
-                metadata={"container_id": container_id, "media_id": result["media_id"]},
+                metadata={
+                    "container_id": container_id,
+                    "media_id": result["media_id"],
+                },
             )
 
         except Exception as e:
@@ -459,7 +501,9 @@ class InstagramClient(SocialPlatform):
 
         params = {
             "video_url": request.video_url,
-            "media_type": "REELS" if request.custom_metadata.get("is_reels") else "VIDEO",
+            "media_type": "REELS"
+            if request.custom_metadata.get("is_reels")
+            else "VIDEO",
             "caption": f"{request.title}\n\n{request.description or ''}",
             "access_token": self.api_key,
         }
@@ -471,15 +515,18 @@ class InstagramClient(SocialPlatform):
         async with session.post(
             f"{self.base_url}/{self.business_account_id}/media", params=params
         ) as response:
-
             if response.status != 200:
                 error_text = await response.text()
-                raise Exception(f"Instagram media creation error: {response.status} - {error_text}")
+                raise Exception(
+                    f"Instagram media creation error: {response.status} - {error_text}"
+                )
 
             result = await response.json()
 
             if "error" in result:
-                raise Exception(f"Instagram API error: {result['error']['message']}")
+                raise Exception(
+                    f"Instagram API error: {result['error']['message']}"
+                )
 
             return result["id"]
 
@@ -491,17 +538,21 @@ class InstagramClient(SocialPlatform):
         params = {"creation_id": container_id, "access_token": self.api_key}
 
         async with session.post(
-            f"{self.base_url}/{self.business_account_id}/media_publish", params=params
+            f"{self.base_url}/{self.business_account_id}/media_publish",
+            params=params,
         ) as response:
-
             if response.status != 200:
                 error_text = await response.text()
-                raise Exception(f"Instagram publish error: {response.status} - {error_text}")
+                raise Exception(
+                    f"Instagram publish error: {response.status} - {error_text}"
+                )
 
             result = await response.json()
 
             if "error" in result:
-                raise Exception(f"Instagram API error: {result['error']['message']}")
+                raise Exception(
+                    f"Instagram API error: {result['error']['message']}"
+                )
 
             # Get media permalink
             media_id = result["id"]
@@ -517,8 +568,9 @@ class InstagramClient(SocialPlatform):
 
             params = {"fields": "permalink", "access_token": self.api_key}
 
-            async with session.get(f"{self.base_url}/{media_id}", params=params) as response:
-
+            async with session.get(
+                f"{self.base_url}/{media_id}", params=params
+            ) as response:
                 if response.status == 200:
                     result = await response.json()
                     return result.get("permalink")
@@ -540,8 +592,9 @@ class InstagramClient(SocialPlatform):
                 "access_token": self.api_key,
             }
 
-            async with session.get(f"{self.base_url}/{platform_id}", params=params) as response:
-
+            async with session.get(
+                f"{self.base_url}/{platform_id}", params=params
+            ) as response:
                 if response.status != 200:
                     return {"error": f"API error: {response.status}"}
 
@@ -576,8 +629,9 @@ class InstagramClient(SocialPlatform):
 
             params = {"access_token": self.api_key}
 
-            async with session.delete(f"{self.base_url}/{platform_id}", params=params) as response:
-
+            async with session.delete(
+                f"{self.base_url}/{platform_id}", params=params
+            ) as response:
                 return response.status == 200
 
         except Exception as e:
@@ -610,16 +664,22 @@ class SocialMediaManager:
         youtube_oauth_token = os.getenv("YOUTUBE_OAUTH_TOKEN")
 
         if all([youtube_api_key, youtube_oauth_token]):
-            self.platforms["youtube"] = YouTubeClient(youtube_api_key, youtube_oauth_token)
+            self.platforms["youtube"] = YouTubeClient(
+                youtube_api_key, youtube_oauth_token
+            )
 
         # Instagram
         instagram_api_key = os.getenv("INSTAGRAM_API_KEY")
         instagram_business_id = os.getenv("INSTAGRAM_BUSINESS_ACCOUNT_ID")
 
         if all([instagram_api_key, instagram_business_id]):
-            self.platforms["instagram"] = InstagramClient(instagram_api_key, instagram_business_id)
+            self.platforms["instagram"] = InstagramClient(
+                instagram_api_key, instagram_business_id
+            )
 
-    async def publish_to_platform(self, platform: str, request: PublishRequest) -> PublishResult:
+    async def publish_to_platform(
+        self, platform: str, request: PublishRequest
+    ) -> PublishResult:
         """Publish video to specific platform"""
 
         if platform not in self.platforms:
@@ -669,7 +729,9 @@ class SocialMediaManager:
 
         return []
 
-    async def get_platform_stats(self, platform: str, platform_id: str) -> Dict[str, Any]:
+    async def get_platform_stats(
+        self, platform: str, platform_id: str
+    ) -> Dict[str, Any]:
         """Get video statistics from platform"""
 
         if platform not in self.platforms:
@@ -677,7 +739,9 @@ class SocialMediaManager:
 
         return await self.platforms[platform].get_video_stats(platform_id)
 
-    async def delete_from_platform(self, platform: str, platform_id: str) -> bool:
+    async def delete_from_platform(
+        self, platform: str, platform_id: str
+    ) -> bool:
         """Delete video from platform"""
 
         if platform not in self.platforms:
diff --git a/services/video-service/tests/test_video_service.py b/services/video-service/tests/test_video_service.py
index 488a3d3..9ae8898 100644
--- a/services/video-service/tests/test_video_service.py
+++ b/services/video-service/tests/test_video_service.py
@@ -14,8 +14,15 @@ from httpx import AsyncClient
 from main import app
 from models.video_project import VideoProject, VideoStatus
 from ai.suno_client import SunoAIClient, VoiceGenerationResponse
-from ai.gemini_client import GeminiClient, ScriptGenerationResponse, ScriptScene
-from ai.stable_diffusion_client import StableDiffusionClient, ImageGenerationResponse
+from ai.gemini_client import (
+    GeminiClient,
+    ScriptGenerationResponse,
+    ScriptScene,
+)
+from ai.stable_diffusion_client import (
+    StableDiffusionClient,
+    ImageGenerationResponse,
+)
 
 client = TestClient(app)
 
@@ -109,7 +116,9 @@ class TestVideoGeneration:
 
     @patch("main.verify_token")
     @patch("main.get_db_connection")
-    def test_create_video_project_success(self, mock_db, mock_verify_token, sample_video_request):
+    def test_create_video_project_success(
+        self, mock_db, mock_verify_token, sample_video_request
+    ):
         """Test successful video project creation"""
 
         # Mock authentication
@@ -119,7 +128,11 @@ class TestVideoGeneration:
         # Mock headers
         headers = {"Authorization": "Bearer valid_token"}
 
-        response = client.post("/api/v1/video/generate", json=sample_video_request, headers=headers)
+        response = client.post(
+            "/api/v1/video/generate",
+            json=sample_video_request,
+            headers=headers,
+        )
 
         assert response.status_code == 200
         data = response.json()
@@ -132,7 +145,9 @@ class TestVideoGeneration:
     def test_create_video_project_unauthorized(self, sample_video_request):
         """Test video project creation without authentication"""
 
-        response = client.post("/api/v1/video/generate", json=sample_video_request)
+        response = client.post(
+            "/api/v1/video/generate", json=sample_video_request
+        )
         assert response.status_code == 403  # Missing Authorization header
 
     @patch("main.verify_token")
@@ -154,9 +169,14 @@ class TestVideoGeneration:
             created_at=datetime.utcnow(),
         )
 
-        with patch("models.video_project.VideoProject.get_by_id", return_value=mock_project):
+        with patch(
+            "models.video_project.VideoProject.get_by_id",
+            return_value=mock_project,
+        ):
             headers = {"Authorization": "Bearer valid_token"}
-            response = client.get("/api/v1/video/projects/project123", headers=headers)
+            response = client.get(
+                "/api/v1/video/projects/project123", headers=headers
+            )
 
             assert response.status_code == 200
             data = response.json()
@@ -189,7 +209,9 @@ class TestAIIntegration:
         client = GeminiClient("test_api_key")
 
         with patch.object(client, "_generate_content") as mock_generate:
-            mock_generate.return_value = '{"full_script": "test script", "scenes": []}'
+            mock_generate.return_value = (
+                '{"full_script": "test script", "scenes": []}'
+            )
 
             with patch.object(
                 client,
@@ -237,10 +259,15 @@ class TestAIIntegration:
             with patch.object(
                 client,
                 "_save_image",
-                return_value=("http://test.com/image.png", "http://test.com/thumb.jpg"),
+                return_value=(
+                    "http://test.com/image.png",
+                    "http://test.com/thumb.jpg",
+                ),
             ):
                 result = await client.generate_image(
-                    prompt="A modern office scene", style="modern", aspect_ratio="16:9"
+                    prompt="A modern office scene",
+                    style="modern",
+                    aspect_ratio="16:9",
                 )
 
                 assert isinstance(result, ImageGenerationResponse)
@@ -268,11 +295,14 @@ class TestVideoComposition:
                 "/tmp/img3.png",
             ]
 
-            with patch.object(composer, "_create_preview", return_value="/tmp/preview.mp4"):
+            with patch.object(
+                composer, "_create_preview", return_value="/tmp/preview.mp4"
+            ):
                 with patch.object(
-                    composer, "_upload_media", return_value="http://test.com/preview.mp4"
+                    composer,
+                    "_upload_media",
+                    return_value="http://test.com/preview.mp4",
                 ):
-
                     result = await composer.create_video(
                         script_scenes=sample_script_response.scenes,
                         voice_url="http://test.com/voice.mp3",
@@ -298,7 +328,11 @@ class TestSocialMediaIntegration:
     async def test_social_media_manager_publish(self):
         """Test social media publishing"""
 
-        from social.platforms import SocialMediaManager, PublishRequest, PublishResult
+        from social.platforms import (
+            SocialMediaManager,
+            PublishRequest,
+            PublishResult,
+        )
 
         manager = SocialMediaManager()
 
@@ -364,7 +398,9 @@ class TestDatabase:
         )
 
         with patch.object(project, "save") as mock_save:
-            await project.update_status(mock_db, VideoStatus.GENERATING_SCRIPT, 25, None)
+            await project.update_status(
+                mock_db, VideoStatus.GENERATING_SCRIPT, 25, None
+            )
 
             assert project.status == VideoStatus.GENERATING_SCRIPT
             assert project.progress == 25
diff --git a/services/video-service/video/composer.py b/services/video-service/video/composer.py
index 0b5eeb4..e7b78bf 100644
--- a/services/video-service/video/composer.py
+++ b/services/video-service/video/composer.py
@@ -118,38 +118,55 @@ class VideoComposer:
             logger.info(f"Starting video composition: {composition_id}")
 
             # Download all media assets
-            voice_path = await self._download_media(voice_url, f"{composition_id}_voice.mp3")
+            voice_path = await self._download_media(
+                voice_url, f"{composition_id}_voice.mp3"
+            )
             music_path = (
-                await self._download_media(music_url, f"{composition_id}_music.mp3")
+                await self._download_media(
+                    music_url, f"{composition_id}_music.mp3"
+                )
                 if music_url
                 else None
             )
 
             image_paths = []
             for i, image_url in enumerate(image_urls):
-                image_path = await self._download_media(image_url, f"{composition_id}_img_{i}.png")
+                image_path = await self._download_media(
+                    image_url, f"{composition_id}_img_{i}.png"
+                )
                 image_paths.append(image_path)
 
             # Create scene compositions
             scenes = []
             current_time = 0.0
 
-            for i, (script_scene, image_path) in enumerate(zip(script_scenes, image_paths)):
+            for i, (script_scene, image_path) in enumerate(
+                zip(script_scenes, image_paths)
+            ):
                 scene = SceneComposition(
                     sequence=i,
                     start_time=current_time,
                     duration=script_scene.duration,
                     image_url=image_path,
                     narration_text=script_scene.narration_text,
-                    visual_effects=self._get_scene_effects(script_scene.scene_type),
-                    transition_type=self._get_transition_type(i, len(script_scenes)),
+                    visual_effects=self._get_scene_effects(
+                        script_scene.scene_type
+                    ),
+                    transition_type=self._get_transition_type(
+                        i, len(script_scenes)
+                    ),
                 )
                 scenes.append(scene)
                 current_time += script_scene.duration
 
             # Generate preview video
             preview_path = await self._create_preview(
-                composition_id, scenes, voice_path, music_path, target_platform, include_captions
+                composition_id,
+                scenes,
+                voice_path,
+                music_path,
+                target_platform,
+                include_captions,
             )
 
             # Upload preview and get URL
@@ -169,14 +186,18 @@ class VideoComposer:
             logger.error(f"Video composition failed: {str(e)}")
             raise Exception(f"Failed to create video composition: {str(e)}")
 
-    async def render_final(self, composition_id: str, quality: str = "high") -> FinalRenderResult:
+    async def render_final(
+        self, composition_id: str, quality: str = "high"
+    ) -> FinalRenderResult:
         """Render final high-quality video"""
 
         try:
             logger.info(f"Starting final render: {composition_id}")
 
             # Load composition data (in real implementation, this would be from database)
-            composition_data = await self._load_composition_data(composition_id)
+            composition_data = await self._load_composition_data(
+                composition_id
+            )
 
             if not composition_data:
                 raise Exception(f"Composition {composition_id} not found")
@@ -187,14 +208,18 @@ class VideoComposer:
             )
 
             # Generate thumbnail
-            thumbnail_path = await self._generate_thumbnail(final_video_path, composition_id)
+            thumbnail_path = await self._generate_thumbnail(
+                final_video_path, composition_id
+            )
 
             # Get video metadata
             metadata = await self._get_video_metadata(final_video_path)
 
             # Upload final video and thumbnail
             video_url = await self._upload_media(final_video_path, "videos")
-            thumbnail_url = await self._upload_media(thumbnail_path, "thumbnails")
+            thumbnail_url = await self._upload_media(
+                thumbnail_path, "thumbnails"
+            )
 
             logger.info(f"Final render completed: {composition_id}")
 
@@ -221,7 +246,9 @@ class VideoComposer:
             async with aiohttp.ClientSession() as session:
                 async with session.get(url) as response:
                     if response.status != 200:
-                        raise Exception(f"Failed to download media: {response.status}")
+                        raise Exception(
+                            f"Failed to download media: {response.status}"
+                        )
 
                     file_path = os.path.join(self.temp_dir, filename)
                     with open(file_path, "wb") as f:
@@ -245,11 +272,18 @@ class VideoComposer:
         """Create preview video with lower quality for quick review"""
 
         settings = self.platform_settings[target_platform]
-        preview_path = os.path.join(self.temp_dir, f"{composition_id}_preview.mp4")
+        preview_path = os.path.join(
+            self.temp_dir, f"{composition_id}_preview.mp4"
+        )
 
         # Create FFmpeg filter complex for preview
         filter_complex = await self._build_filter_complex(
-            scenes, voice_path, music_path, settings, include_captions, preview=True
+            scenes,
+            voice_path,
+            music_path,
+            settings,
+            include_captions,
+            preview=True,
         )
 
         # Build FFmpeg command for preview
@@ -288,7 +322,9 @@ class VideoComposer:
 
         # Run FFmpeg
         process = await asyncio.create_subprocess_exec(
-            *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
+            *cmd,
+            stdout=asyncio.subprocess.PIPE,
+            stderr=asyncio.subprocess.PIPE,
         )
 
         stdout, stderr = await process.communicate()
@@ -300,11 +336,16 @@ class VideoComposer:
         return preview_path
 
     async def _render_final_video(
-        self, composition_id: str, composition_data: Dict[str, Any], quality: str
+        self,
+        composition_id: str,
+        composition_data: Dict[str, Any],
+        quality: str,
     ) -> str:
         """Render final high-quality video"""
 
-        final_path = os.path.join(self.output_dir, f"{composition_id}_final.mp4")
+        final_path = os.path.join(
+            self.output_dir, f"{composition_id}_final.mp4"
+        )
 
         # Quality settings
         quality_settings = {
@@ -315,7 +356,9 @@ class VideoComposer:
         }
 
         settings = quality_settings.get(quality, quality_settings["high"])
-        platform_settings = self.platform_settings[composition_data["target_platform"]]
+        platform_settings = self.platform_settings[
+            composition_data["target_platform"]
+        ]
 
         # Build comprehensive FFmpeg command for final render
         cmd = ["ffmpeg", "-y", "-i", composition_data["voice_path"]]
@@ -361,7 +404,9 @@ class VideoComposer:
 
         # Run final render
         process = await asyncio.create_subprocess_exec(
-            *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
+            *cmd,
+            stdout=asyncio.subprocess.PIPE,
+            stderr=asyncio.subprocess.PIPE,
         )
 
         stdout, stderr = await process.communicate()
@@ -388,7 +433,9 @@ class VideoComposer:
 
         # Scale and process images
         for i, scene in enumerate(scenes):
-            input_idx = i + (2 if music_path else 1)  # Account for audio inputs
+            input_idx = i + (
+                2 if music_path else 1
+            )  # Account for audio inputs
             filter_parts.append(
                 f"[{input_idx}:v]scale={settings['resolution']}:force_original_aspect_ratio=increase,"
                 f"crop={settings['resolution']},setsar=1[img{i}]"
@@ -396,11 +443,15 @@ class VideoComposer:
 
         # Concatenate video segments
         concat_inputs = "".join(f"[img{i}]" for i in range(len(scenes)))
-        filter_parts.append(f"{concat_inputs}concat=n={len(scenes)}:v=1:a=0[video]")
+        filter_parts.append(
+            f"{concat_inputs}concat=n={len(scenes)}:v=1:a=0[video]"
+        )
 
         # Audio mixing
         if music_path:
-            filter_parts.append("[0:a][1:a]amix=inputs=2:duration=first[audio]")
+            filter_parts.append(
+                "[0:a][1:a]amix=inputs=2:duration=first[audio]"
+            )
             audio_output = "[audio]"
         else:
             audio_output = "[0:a]"
@@ -429,10 +480,14 @@ class VideoComposer:
         else:
             return "crossfade"
 
-    async def _generate_thumbnail(self, video_path: str, composition_id: str) -> str:
+    async def _generate_thumbnail(
+        self, video_path: str, composition_id: str
+    ) -> str:
         """Generate thumbnail from video"""
 
-        thumbnail_path = os.path.join(self.temp_dir, f"{composition_id}_thumb.jpg")
+        thumbnail_path = os.path.join(
+            self.temp_dir, f"{composition_id}_thumb.jpg"
+        )
 
         cmd = [
             "ffmpeg",
@@ -449,7 +504,9 @@ class VideoComposer:
         ]
 
         process = await asyncio.create_subprocess_exec(
-            *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
+            *cmd,
+            stdout=asyncio.subprocess.PIPE,
+            stderr=asyncio.subprocess.PIPE,
         )
 
         await process.communicate()
@@ -475,20 +532,32 @@ class VideoComposer:
         ]
 
         process = await asyncio.create_subprocess_exec(
-            *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
+            *cmd,
+            stdout=asyncio.subprocess.PIPE,
+            stderr=asyncio.subprocess.PIPE,
         )
 
         stdout, _ = await process.communicate()
 
         if process.returncode != 0:
-            return {"duration": 0, "file_size": 0, "resolution": "unknown", "format": "mp4"}
+            return {
+                "duration": 0,
+                "file_size": 0,
+                "resolution": "unknown",
+                "format": "mp4",
+            }
 
         metadata = json.loads(stdout.decode())
 
         # Extract relevant information
         format_info = metadata.get("format", {})
         video_stream = next(
-            (s for s in metadata.get("streams", []) if s["codec_type"] == "video"), {}
+            (
+                s
+                for s in metadata.get("streams", [])
+                if s["codec_type"] == "video"
+            ),
+            {},
         )
 
         return {
@@ -515,7 +584,9 @@ class VideoComposer:
         base_url = os.getenv("MEDIA_BASE_URL", "http://localhost:8003")
         return f"{base_url}/media/{media_type}/{filename}"
 
-    async def _load_composition_data(self, composition_id: str) -> Optional[Dict[str, Any]]:
+    async def _load_composition_data(
+        self, composition_id: str
+    ) -> Optional[Dict[str, Any]]:
         """Load composition data (placeholder - would be from database)"""
 
         # This is a placeholder - in real implementation,
